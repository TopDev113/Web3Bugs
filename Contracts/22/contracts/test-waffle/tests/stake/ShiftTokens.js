// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var Curry = require("rescript/lib/js/curry.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");

function testUnit(contracts, accounts) {
  describe("shiftTokens", (function () {
          var marketIndex = Helpers.randomJsInteger(undefined);
          var amountSyntheticTokensToShift = Helpers.randomTokenAmount(undefined);
          var amountSyntheticTokensToShiftBeforeValue = Helpers.randomTokenAmount(undefined);
          Globals.before_once$p(function (param) {
                var match = contracts.contents;
                return LetOps.Await.let_(match.staker.setLongShort(match.longShortSmocked.address), (function (param) {
                              return StakerSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.staker, "shiftTokens");
                            }));
              });
          var setup = function (isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, batched_stakerNextTokenShiftIndex, userAmountStaked) {
            var user = accounts.contents[0].address;
            var match = contracts.contents;
            var staker = match.staker;
            return LetOps.Await.let_(staker.setShiftTokensParams(marketIndex, isShiftFromLong, user, amountSyntheticTokensToShiftBeforeValue, userAmountStaked, userNextPrice_stakedSyntheticTokenShiftIndex, batched_stakerNextTokenShiftIndex, match.syntheticTokenSmocked.address), (function (param) {
                          return staker.shiftTokens(amountSyntheticTokensToShift, marketIndex, isShiftFromLong);
                        }));
          };
          it("reverts if market doesn't exist or user doesn't have any staked tokens", (function () {
                  return Chai.expectRevert(contracts.contents.staker.shiftTokens(amountSyntheticTokensToShift, marketIndex, true), "Not enough tokens to shift");
                }));
          it("calls _mintAccumulatedFloat with the correct argumetns if the user has a 'confirmed' shift that needs to be settled", (function () {
                  var user = accounts.contents[0].address;
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Helpers.randomInteger(undefined);
                  var batched_stakerNextTokenShiftIndex = Globals.add(userNextPrice_stakedSyntheticTokenShiftIndex, Helpers.randomInteger(undefined));
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                var mintAccumulatedFloatCalls = StakerSmocked.InternalMock._mintAccumulatedFloatCalls(undefined);
                                return Chai.recordArrayDeepEqualFlat(undefined, mintAccumulatedFloatCalls, [{
                                              marketIndex: marketIndex,
                                              user: user
                                            }]);
                              }));
                }));
          it("doesn't call _mintAccumulatedFloat if userNextPrice_stakedSyntheticTokenShiftIndex == 0", (function () {
                  var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                var mintAccumulatedFloatCalls = StakerSmocked.InternalMock._mintAccumulatedFloatCalls(undefined);
                                return Chai.recordArrayDeepEqualFlat(undefined, mintAccumulatedFloatCalls, []);
                              }));
                }));
          it("doesn't call _mintAccumulatedFloat if userNextPrice_stakedSyntheticTokenShiftIndex == batched_stakerNextTokenShiftIndex", (function () {
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Helpers.randomInteger(undefined);
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, userNextPrice_stakedSyntheticTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                var mintAccumulatedFloatCalls = StakerSmocked.InternalMock._mintAccumulatedFloatCalls(undefined);
                                return Chai.recordArrayDeepEqualFlat(undefined, mintAccumulatedFloatCalls, []);
                              }));
                }));
          it("doesn't call _mintAccumulatedFloat if userNextPrice_stakedSyntheticTokenShiftIndex > batched_stakerNextTokenShiftIndex", (function () {
                  var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Globals.add(batched_stakerNextTokenShiftIndex, Helpers.randomInteger(undefined));
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                var mintAccumulatedFloatCalls = StakerSmocked.InternalMock._mintAccumulatedFloatCalls(undefined);
                                return Chai.recordArrayDeepEqualFlat(undefined, mintAccumulatedFloatCalls, []);
                              }));
                }));
          it("sets the userNextPrice_stakedSyntheticTokenShiftIndex for the user to the batched_stakerNextTokenShiftIndex value", (function () {
                  var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                  var user = accounts.contents[0].address;
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                return LetOps.Await.let_(contracts.contents.staker.userNextPrice_stakedSyntheticTokenShiftIndex(marketIndex, user), (function (userNextPrice_stakedSyntheticTokenShiftIndexAfter) {
                                              return Chai.bnEqual(undefined, userNextPrice_stakedSyntheticTokenShiftIndexAfter, batched_stakerNextTokenShiftIndex);
                                            }));
                              }));
                }));
          var sideSpecificTests = function (isShiftFromLong) {
            it("calls the shiftPositionFrom" + ((
                    isShiftFromLong ? "Long" : "Short"
                  ) + "NextPrice function on long short with the correct parameters"), (function () {
                    var match = contracts.contents;
                    var longShortSmocked = match.longShortSmocked;
                    var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                    return LetOps.Await.let_(setup(isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                  var shiftPositionFromLongNextPriceCalls = LongShortSmocked.shiftPositionFromLongNextPriceCalls(longShortSmocked);
                                  var shiftPositionFromShortNextPriceCalls = LongShortSmocked.shiftPositionFromShortNextPriceCalls(longShortSmocked);
                                  if (isShiftFromLong) {
                                    Chai.recordArrayDeepEqualFlat(undefined, shiftPositionFromLongNextPriceCalls, [{
                                            marketIndex: marketIndex,
                                            amountSyntheticTokensToShift: amountSyntheticTokensToShift
                                          }]);
                                    return Chai.recordArrayDeepEqualFlat(undefined, shiftPositionFromShortNextPriceCalls, []);
                                  } else {
                                    Chai.recordArrayDeepEqualFlat(undefined, shiftPositionFromLongNextPriceCalls, []);
                                    return Chai.recordArrayDeepEqualFlat(undefined, shiftPositionFromShortNextPriceCalls, [{
                                                  marketIndex: marketIndex,
                                                  amountSyntheticTokensToShift: amountSyntheticTokensToShift
                                                }]);
                                  }
                                }));
                  }));
            it("updates the amountToShiftFrom" + ((
                    isShiftFromLong ? "Long" : "Short"
                  ) + "User value with the amount to shift"), (function () {
                    var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                    var user = accounts.contents[0].address;
                    return LetOps.Await.let_(setup(isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, batched_stakerNextTokenShiftIndex, amountSyntheticTokensToShift), (function (param) {
                                  var getTotalAmountToShiftFromSide = isShiftFromLong ? (function (prim0, prim1, prim2) {
                                        return prim0.userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long(prim1, prim2);
                                      }) : (function (prim0, prim1, prim2) {
                                        return prim0.userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short(prim1, prim2);
                                      });
                                  return LetOps.Await.let_(Curry._3(getTotalAmountToShiftFromSide, contracts.contents.staker, marketIndex, user), (function (totalAmountToShiftFromSide) {
                                                return Chai.bnEqual(undefined, totalAmountToShiftFromSide, Globals.add(amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift));
                                              }));
                                }));
                  }));
            
          };
          describe("Shift from Long", (function () {
                  return sideSpecificTests(true);
                }));
          describe("Shift from Short", (function () {
                  return sideSpecificTests(false);
                }));
          
        }));
  
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
