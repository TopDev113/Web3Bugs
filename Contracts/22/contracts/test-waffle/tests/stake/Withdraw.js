// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Js_math = require("rescript/lib/js/js_math.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");
var SyntheticTokenSmocked = require("../../library/smock/SyntheticTokenSmocked.js");

function testUnit(contracts, accounts) {
  return Globals.describeUnit("Withdraw functions", (function (param) {
                var marketIndex = Helpers.randomJsInteger(undefined);
                var amountStaked = Helpers.randomTokenAmount(undefined);
                describe("_withdraw", (function () {
                        var userWallet = {
                          contents: undefined
                        };
                        var treasury = Helpers.randomAddress(undefined);
                        var amountWithdrawn = Globals.div(amountStaked, Globals.bnFromInt(Js_math.random_int(1, 20)));
                        var fees = Helpers.randomRatio1e18(undefined);
                        var call = {
                          contents: undefined
                        };
                        var connectedStaker = {
                          contents: undefined
                        };
                        var setup = function (amountStaked) {
                          userWallet.contents = accounts.contents[5];
                          var match = contracts.contents;
                          var syntheticTokenSmocked = match.syntheticTokenSmocked;
                          var staker = match.staker;
                          return LetOps.Await.let_(staker.set_withdrawGlobals(marketIndex, syntheticTokenSmocked.address, userWallet.contents.address, amountStaked, fees, treasury), (function (param) {
                                        SyntheticTokenSmocked.mockTransferToReturn(syntheticTokenSmocked, true);
                                        StakerSmocked.InternalMock.mock_mintAccumulatedFloatToReturn(undefined);
                                        connectedStaker.contents = staker.connect(userWallet.contents);
                                        call.contents = connectedStaker.contents._withdrawExposed(marketIndex, syntheticTokenSmocked.address, amountWithdrawn);
                                        
                                      }));
                        };
                        describe("happy case", (function () {
                                Globals.before_once$p(function (param) {
                                      return LetOps.AwaitThen.let_(setup(amountStaked), (function (param) {
                                                    return call.contents;
                                                  }));
                                    });
                                it("calls transfer on the synthetic token with correct args", (function () {
                                        var fees$1 = Globals.div(Globals.mul(amountWithdrawn, fees), Globals.tenToThe18);
                                        return Chai.recordArrayDeepEqualFlat(undefined, SyntheticTokenSmocked.transferCalls(contracts.contents.syntheticTokenSmocked), [
                                                    {
                                                      recipient: treasury,
                                                      amount: fees$1
                                                    },
                                                    {
                                                      recipient: userWallet.contents.address,
                                                      amount: Globals.sub(amountWithdrawn, fees$1)
                                                    }
                                                  ]);
                                      }));
                                it("calls _mintAccumulatedFloat with correct args", (function () {
                                        return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._mintAccumulatedFloatCalls(undefined), [{
                                                      marketIndex: marketIndex,
                                                      user: userWallet.contents.address
                                                    }]);
                                      }));
                                it("mutates userAmountStaked", (function () {
                                        return LetOps.Await.let_(contracts.contents.staker.userAmountStaked(contracts.contents.syntheticTokenSmocked.address, userWallet.contents.address), (function (amountStakedAfter) {
                                                      return Chai.bnEqual(undefined, amountStakedAfter, Globals.sub(amountStaked, amountWithdrawn));
                                                    }));
                                      }));
                                it("emits a StakeWithdrawn event with correct args", (function () {
                                        return Chai.callEmitEvents(call.contents, connectedStaker.contents, "StakeWithdrawn").withArgs(userWallet.contents.address, contracts.contents.syntheticTokenSmocked.address, amountWithdrawn);
                                      }));
                                
                              }));
                        describe("sad case", (function () {
                                Globals.before_once$p(function (param) {
                                      return setup(Globals.zeroBn);
                                    });
                                it("reverts if nothing to withdraw", (function () {
                                        return Chai.expectRevert(call.contents, "nothing to withdraw");
                                      }));
                                
                              }));
                        
                      }));
                describe("withdraw", (function () {
                        var token = Helpers.randomAddress(undefined);
                        var amountWithdrawn = Helpers.randomTokenAmount(undefined);
                        Globals.before_once$p(function (param) {
                              return LetOps.AwaitThen.let_(contracts.contents.staker.setWithdrawGlobals(marketIndex, contracts.contents.longShortSmocked.address, token), (function (param) {
                                            LongShortSmocked.mockUpdateSystemStateToReturn(contracts.contents.longShortSmocked);
                                            return contracts.contents.staker.withdraw(token, amountWithdrawn);
                                          }));
                            });
                        it("calls updateSystemState on longShort with correct args", (function () {
                                return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.updateSystemStateCalls(contracts.contents.longShortSmocked), [{
                                              marketIndex: marketIndex
                                            }]);
                              }));
                        it("calls _withdraw with correct args", (function () {
                                return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._withdrawCalls(undefined), [{
                                              marketIndex: marketIndex,
                                              token: token,
                                              amount: amountWithdrawn
                                            }]);
                              }));
                        
                      }));
                describe("withdrawAll", (function () {
                        var token = Helpers.randomAddress(undefined);
                        var userWallet = {
                          contents: undefined
                        };
                        Globals.before_once$p(function (param) {
                              userWallet.contents = accounts.contents[5];
                              return LetOps.AwaitThen.let_(contracts.contents.staker.setWithdrawAllGlobals(marketIndex, contracts.contents.longShortSmocked.address, userWallet.contents.address, amountStaked, token), (function (param) {
                                            LongShortSmocked.mockUpdateSystemStateToReturn(contracts.contents.longShortSmocked);
                                            return contracts.contents.staker.connect(userWallet.contents).withdrawAll(token);
                                          }));
                            });
                        it("calls updateSystemState on longShort with correct args", (function () {
                                return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.updateSystemStateCalls(contracts.contents.longShortSmocked), [{
                                              marketIndex: marketIndex
                                            }]);
                              }));
                        it("calls _withdraw with correct args", (function () {
                                return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._withdrawCalls(undefined), [{
                                              marketIndex: marketIndex,
                                              token: token,
                                              amount: amountStaked
                                            }]);
                              }));
                        
                      }));
                
              }));
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
