// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function testUnit(contracts, param) {
  var marketIndex = Helpers.randomJsInteger(undefined);
  var match = Helpers.Tuple.make5(Helpers.randomInteger);
  var timeDeltaGreaterThanZero = match[4];
  var shortValue = match[3];
  var longValue = match[2];
  var shortPrice = match[1];
  var longPrice = match[0];
  describe("pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations", (function () {
          Globals.before_once$p(function (param) {
                return StakerSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.staker, "pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations");
              });
          var setup = function (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted, timeDelta) {
            StakerSmocked.InternalMock.mock_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotToReturn(timeDelta);
            return contracts.contents.staker.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(marketIndex, longPrice, shortPrice, longValue, shortValue, stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted);
          };
          describe("modifiers", (function () {
                  it("calls the onlyLongShort modifier", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(marketIndex, longPrice, shortPrice, longValue, shortValue, Globals.zeroBn), (function (param) {
                                        return Chai.intEqual(undefined, StakerSmocked.InternalMock.onlyLongShortModifierLogicCalls(undefined).length, 1);
                                      }));
                        }));
                  
                }));
          describe("case timeDelta > 0", (function () {
                  var stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted = Helpers.randomTokenAmount(undefined);
                  Globals.before_once$p(function (param) {
                        return setup(stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted, timeDeltaGreaterThanZero);
                      });
                  it("calls calculateTimeDelta with correct arguments", (function () {
                          return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotCalls(undefined), [{
                                        marketIndex: marketIndex
                                      }]);
                        }));
                  it("calls setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot with correct arguments", (function () {
                          return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotCalls(undefined), [{
                                        marketIndex: marketIndex,
                                        longPrice: longPrice,
                                        shortPrice: shortPrice,
                                        longValue: longValue,
                                        shortValue: shortValue
                                      }]);
                        }));
                  
                }));
          describe("case stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0", (function () {
                  var batched_stakerNextTokenShiftIndex = Helpers.randomInteger(undefined);
                  var latestRewardIndex = Helpers.randomInteger(undefined);
                  var stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted = Helpers.randomInteger(undefined);
                  var pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsTxPromise = {
                    contents: "Not set yet"
                  };
                  Globals.before_once$p(function (param) {
                        return LetOps.Await.let_(contracts.contents.staker.setAddNewStateForFloatRewardsGlobals(marketIndex, batched_stakerNextTokenShiftIndex, latestRewardIndex), (function (param) {
                                      pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsTxPromise.contents = setup(stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted, timeDeltaGreaterThanZero);
                                      return pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsTxPromise.contents;
                                    }));
                      });
                  it("updates takerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping to the 'stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted' value recieved from long short", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping(batched_stakerNextTokenShiftIndex), (function (takerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping) {
                                        return Chai.bnEqual(undefined, takerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping, stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted);
                                      }));
                        }));
                  it("increments the stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping(batched_stakerNextTokenShiftIndex), (function (stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping) {
                                        return Chai.bnEqual(undefined, stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping, Globals.add(latestRewardIndex, Globals.oneBn));
                                      }));
                        }));
                  it("increments the batched_stakerNextTokenShiftIndex", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.batched_stakerNextTokenShiftIndex(marketIndex), (function (updatedNextTokenShiftIndex) {
                                        return Chai.bnEqual(undefined, updatedNextTokenShiftIndex, Globals.add(batched_stakerNextTokenShiftIndex, Globals.oneBn));
                                      }));
                        }));
                  it("emits the SyntheticTokensShifted event", (function () {
                          return Chai.callEmitEvents(pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsTxPromise.contents, contracts.contents.staker, "SyntheticTokensShifted").withArgs();
                        }));
                  
                }));
          describe("case timeDelta == 0", (function () {
                  it("doesn't call setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot", (function () {
                          return LetOps.Await.let_(setup(Globals.zeroBn, CONSTANTS.zeroBn), (function (param) {
                                        return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotCalls(undefined), []);
                                      }));
                        }));
                  
                }));
          
        }));
  
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
