// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerHelpers = require("./StakerHelpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function test(contracts, accounts) {
  describe("addNewStakingFund", (function () {
          var sampleLongAddress = Helpers.randomAddress(undefined);
          var sampleShortAddress = Helpers.randomAddress(undefined);
          var sampleMockAddress = Helpers.randomAddress(undefined);
          var kInitialMultiplier = Helpers.randomInteger(undefined);
          var kPeriod = Helpers.randomInteger(undefined);
          var unstakeFee_e18 = Helpers.randomInteger(undefined);
          var timestampRef = {
            contents: 0
          };
          var promiseRef = {
            contents: Promise.resolve(undefined)
          };
          Globals.before_once$p(function (param) {
                return LetOps.Await.let_(StakerHelpers.deployAndSetupStakerToUnitTest("addNewStakingFund", contracts, accounts), (function (param) {
                              StakerSmocked.InternalMock.mock_changeMarketLaunchIncentiveParametersToReturn(undefined);
                              StakerSmocked.InternalMock.mock_changeUnstakeFeeToReturn(undefined);
                              var longShortAddress = accounts.contents[5];
                              return LetOps.AwaitThen.let_(contracts.contents.staker.setAddNewStakingFundParams(1, sampleLongAddress, sampleShortAddress, sampleMockAddress, longShortAddress.address), (function (param) {
                                            return LetOps.AwaitThen.let_(Helpers.getBlock(undefined), (function (param) {
                                                          timestampRef.contents = param.timestamp;
                                                          var promise = contracts.contents.staker.connect(longShortAddress).addNewStakingFund(1, sampleLongAddress, sampleShortAddress, kInitialMultiplier, kPeriod, unstakeFee_e18, Globals.bnFromInt(5), Globals.bnFromInt(0));
                                                          promiseRef.contents = promise;
                                                          return LetOps.Await.let_(promise, (function (param) {
                                                                        
                                                                      }));
                                                        }));
                                          }));
                            }));
              });
          it.skip("calls the onlyLongShortModifier", (function () {
                  
                }));
          it("calls _changeMarketLaunchIncentiveParameters with correct arguments", (function () {
                  return Chai.recordEqualFlat(StakerSmocked.InternalMock._changeMarketLaunchIncentiveParametersCalls(undefined)[0], {
                              marketIndex: 1,
                              period: kPeriod,
                              initialMultiplier: kInitialMultiplier
                            });
                }));
          it("calls _changeUnstakeFee with correct arguments", (function () {
                  return Chai.recordEqualFlat(StakerSmocked.InternalMock._changeUnstakeFeeCalls(undefined)[0], {
                              marketIndex: 1,
                              newMarketUnstakeFee_e18: unstakeFee_e18
                            });
                }));
          it("mutates accumulativeFloatPerSyntheticTokenSnapshots", (function () {
                  return LetOps.Await.let_(contracts.contents.staker.accumulativeFloatPerSyntheticTokenSnapshots(1, CONSTANTS.zeroBn), (function (params) {
                                return Chai.recordEqualFlat(params, {
                                            timestamp: ethers.BigNumber.from(timestampRef.contents + 1 | 0),
                                            accumulativeFloatPerSyntheticToken_long: CONSTANTS.zeroBn,
                                            accumulativeFloatPerSyntheticToken_short: CONSTANTS.zeroBn
                                          });
                              }));
                }));
          it("mutates syntheticTokens", (function () {
                  return LetOps.Await.let_(contracts.contents.staker.syntheticTokens(1, true), (function (tokenLong) {
                                return LetOps.Await.let_(contracts.contents.staker.syntheticTokens(1, false), (function (tokenShort) {
                                              Chai.addressEqual(undefined, tokenLong, sampleLongAddress);
                                              return Chai.addressEqual(undefined, tokenShort, sampleShortAddress);
                                            }));
                              }));
                }));
          it("mutates marketIndexOfTokens", (function () {
                  return LetOps.AwaitThen.let_(contracts.contents.staker.marketIndexOfToken(sampleLongAddress), (function (longMarketIndex) {
                                return LetOps.Await.let_(contracts.contents.staker.marketIndexOfToken(sampleShortAddress), (function (shortMarketIndex) {
                                              Chai.intEqual(undefined, 1, longMarketIndex);
                                              return Chai.intEqual(undefined, 1, shortMarketIndex);
                                            }));
                              }));
                }));
          it("emits AccumulativeIssuancePerStakedSynthSnapshotCreated event", (function () {
                  return Chai.callEmitEvents(promiseRef.contents, contracts.contents.staker, "AccumulativeIssuancePerStakedSynthSnapshotCreated").withArgs(1, CONSTANTS.zeroBn, CONSTANTS.zeroBn, CONSTANTS.zeroBn);
                }));
          
        }));
  
}

exports.test = test;
/* Chai Not a pure module */
