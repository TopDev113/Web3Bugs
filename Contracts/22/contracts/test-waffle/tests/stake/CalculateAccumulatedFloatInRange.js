// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function testUnit(contracts, param) {
  describe("_calculateAccumulatedFloatInRange", (function () {
          var marketIndex = Helpers.randomJsInteger(undefined);
          var rewardIndexTo = Helpers.randomTokenAmount(undefined);
          var rewardIndexFrom = Helpers.randomTokenAmount(undefined);
          var syntheticRewardFromLongToken = Helpers.randomTokenAmount(undefined);
          var syntheticRewardToLongToken = Globals.add(syntheticRewardFromLongToken, Helpers.randomTokenAmount(undefined));
          var syntheticRewardFromShortToken = Helpers.randomTokenAmount(undefined);
          var syntheticRewardToShortToken = Globals.add(syntheticRewardFromShortToken, Helpers.randomTokenAmount(undefined));
          var amountStakedLong = Helpers.randomTokenAmount(undefined);
          var amountStakedShort = Helpers.randomTokenAmount(undefined);
          Globals.before_once$p(function (param) {
                var match = contracts.contents;
                return LetOps.Await.let_(match.staker.setLongShort(match.longShortSmocked.address), (function (param) {
                              return StakerSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.staker, "_calculateAccumulatedFloatInRange");
                            }));
              });
          var setup = function (param) {
            var match = contracts.contents;
            var staker = match.staker;
            return LetOps.AwaitThen.let_(staker.setCalculateAccumulatedFloatInRangeGlobals(marketIndex, rewardIndexTo, rewardIndexFrom, syntheticRewardToLongToken, syntheticRewardFromLongToken, syntheticRewardToShortToken, syntheticRewardFromShortToken), (function (param) {
                          return staker._calculateAccumulatedFloatInRangeExposed(marketIndex, amountStakedLong, amountStakedShort, rewardIndexFrom, rewardIndexTo);
                        }));
          };
          it("[Happy Path] it calculates all the values correctly", (function () {
                  return LetOps.Await.let_(setup(undefined), (function (floatDue) {
                                var expectedFloatDueLong = Globals.div(Globals.mul(Globals.sub(syntheticRewardToLongToken, syntheticRewardFromLongToken), amountStakedLong), CONSTANTS.floatIssuanceFixedDecimal);
                                var expectedFloatDueShort = Globals.div(Globals.mul(Globals.sub(syntheticRewardToShortToken, syntheticRewardFromShortToken), amountStakedShort), CONSTANTS.floatIssuanceFixedDecimal);
                                return Chai.bnEqual("calculated float due is incorrect", floatDue, Globals.add(expectedFloatDueLong, expectedFloatDueShort));
                              }));
                }));
          
        }));
  
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
