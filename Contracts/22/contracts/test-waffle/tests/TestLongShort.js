// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../bindings/chai/Chai.js");
var LetOps = require("../library/LetOps.js");
var Globals = require("../library/Globals.js");
var Helpers = require("../library/Helpers.js");
var Contract = require("../library/Contract.js");
var DepositFunds = require("./longShort/depositFunds.js");
var UtilsHelpers = require("./longShort/UtilsHelpers.js");
var HelperActions = require("../library/HelperActions.js");
var MintNextPrice = require("./longShort/MintNextPrice.js");
var ShiftNextPrice = require("./longShort/ShiftNextPrice.js");
var RedeemNextPrice = require("./longShort/RedeemNextPrice.js");
var InitializeMarket = require("./longShort/InitializeMarket.js");
var BatchedSettlement = require("./longShort/BatchedSettlement.js");
var UpdateSystemState = require("./longShort/UpdateSystemState.js");
var ExecuteNextPriceAction = require("./longShort/ExecuteNextPriceAction.js");
var PriceCalculationFunctions = require("./longShort/PriceCalculationFunctions.js");
var GetUsersConfirmedButNotSettledBalance = require("./longShort/GetUsersConfirmedButNotSettledBalance.js");
var ExecuteOutstandingNextPriceSettlements = require("./longShort/ExecuteOutstandingNextPriceSettlements.js");
var ClaimAndDistributeYieldThenRebalanceMarket = require("./longShort/ClaimAndDistributeYieldThenRebalanceMarket.js");

describe("Float System", (function () {
        Globals.describeIntegration("LongShort", (function (param) {
                var contracts = {
                  contents: undefined
                };
                var accounts = {
                  contents: undefined
                };
                beforeEach(function () {
                      return LetOps.Await.let_(ethers.getSigners(), (function (loadedAccounts) {
                                    accounts.contents = loadedAccounts;
                                    return LetOps.AwaitThen.let_(Helpers.initialize(accounts.contents[0], false), (function (deployedContracts) {
                                                  contracts.contents = deployedContracts;
                                                  var setupUser = accounts.contents[2];
                                                  return HelperActions.stakeRandomlyInBothSidesOfMarket(deployedContracts.markets, setupUser, deployedContracts.longShort);
                                                }));
                                  }));
                    });
                UpdateSystemState.testIntegration(contracts, accounts);
                MintNextPrice.testIntegration(contracts, accounts);
                ShiftNextPrice.testIntegration(contracts, accounts);
                RedeemNextPrice.testIntegration(contracts, accounts);
                return InitializeMarket.testIntegration(contracts, accounts);
              }));
        Globals.describeBoth("LongShort - Admin functions", (function (param) {
                var contracts = {
                  contents: undefined
                };
                var accounts = {
                  contents: undefined
                };
                before(function () {
                      return LetOps.Await.let_(ethers.getSigners(), (function (loadedAccounts) {
                                    accounts.contents = loadedAccounts;
                                    return LetOps.Await.let_(Helpers.initialize(accounts.contents[0], false), (function (deployedContracts) {
                                                  contracts.contents = deployedContracts;
                                                  
                                                }));
                                  }));
                    });
                describe("updateMarketOracle", (function () {
                        var newOracleManager = ethers.Wallet.createRandom().address;
                        it("should allow admin to update the oracle", (function () {
                                return LetOps.Await.let_(contracts.contents.longShort.oracleManagers(1), (function (originalOracleAddress) {
                                              return LetOps.Await.let_(contracts.contents.longShort.updateMarketOracle(1, newOracleManager), (function (param) {
                                                            return LetOps.Await.let_(contracts.contents.longShort.oracleManagers(1), (function (updatedOracleAddress) {
                                                                          Chai.addressEqual(undefined, updatedOracleAddress, newOracleManager);
                                                                          return LetOps.Await.let_(contracts.contents.longShort.updateMarketOracle(1, originalOracleAddress), (function (param) {
                                                                                        
                                                                                      }));
                                                                        }));
                                                          }));
                                            }));
                              }));
                        it("shouldn't allow non admin to update the oracle", (function () {
                                var attackerAddress = accounts.contents[5];
                                return Chai.expectRevert(contracts.contents.longShort.connect(attackerAddress).updateMarketOracle(1, newOracleManager), "only admin");
                              }));
                        
                      }));
                describe("changeAdmin", (function () {
                        it("should allow admin to update the admin address", (function () {
                                var originalAdminAddress = accounts.contents[0].address;
                                var newAdmin = accounts.contents[5];
                                var newAdminAddress = newAdmin.address;
                                return LetOps.Await.let_(contracts.contents.longShort.changeAdmin(newAdminAddress), (function (param) {
                                              return LetOps.Await.let_(contracts.contents.longShort.admin(), (function (adminFromContract) {
                                                            Chai.addressEqual("Admin should be updated by 'changeAdmin' function", adminFromContract, newAdminAddress);
                                                            return LetOps.Await.let_(contracts.contents.longShort.connect(newAdmin).changeAdmin(originalAdminAddress), (function (param) {
                                                                          
                                                                        }));
                                                          }));
                                            }));
                              }));
                        it("shouldn't allow non admin to update the Admin", (function () {
                                var attackerAddress = accounts.contents[5];
                                var newAdminAddress = accounts.contents[6].address;
                                return Chai.expectRevert(contracts.contents.longShort.connect(attackerAddress).changeAdmin(newAdminAddress), "only admin");
                              }));
                        
                      }));
                describe("changeTreasury", (function () {
                        var newTreasuryAddress = ethers.Wallet.createRandom().address;
                        it("should allow admin to update the treasury address", (function () {
                                return LetOps.Await.let_(contracts.contents.longShort.changeTreasury(newTreasuryAddress), (function (param) {
                                              return LetOps.Await.let_(contracts.contents.longShort.treasury(), (function (treasuryFromContract) {
                                                            return Chai.addressEqual(undefined, treasuryFromContract, newTreasuryAddress);
                                                          }));
                                            }));
                              }));
                        it("shouldn't allow non admin to update the treasury address", (function () {
                                var attackerAddress = accounts.contents[5];
                                return Chai.expectRevert(contracts.contents.longShort.connect(attackerAddress).changeTreasury(newTreasuryAddress), "only admin");
                              }));
                        
                      }));
                describe("changeMarketTreasurySplitGradient", (function () {
                        it("should allow admin to update a gradient", (function () {
                                return LetOps.Await.let_(contracts.contents.longShort.changeMarketTreasurySplitGradient(1, Globals.twoBn), (function (param) {
                                              return LetOps.Await.let_(contracts.contents.longShort.marketTreasurySplitGradient_e18(1), (function (updatedGradient) {
                                                            return Chai.bnEqual(undefined, updatedGradient, Globals.twoBn);
                                                          }));
                                            }));
                              }));
                        it("shouldn't allow non admin to update the treasury address", (function () {
                                var attackerAddress = accounts.contents[5];
                                return Chai.expectRevert(contracts.contents.longShort.connect(attackerAddress).changeMarketTreasurySplitGradient(1, Globals.twoBn), "only admin");
                              }));
                        
                      }));
                
              }));
        Globals.describeUnit("LongShort - internals exposed", (function (param) {
                var contracts = {
                  contents: undefined
                };
                var accounts = {
                  contents: undefined
                };
                before(function () {
                      return LetOps.Await.let_(ethers.getSigners(), (function (loadedAccounts) {
                                    accounts.contents = loadedAccounts;
                                    
                                  }));
                    });
                beforeEach(function () {
                      return LetOps.Await.let_(Helpers.initialize(accounts.contents[0], true), (function (deployedContracts) {
                                    contracts.contents = deployedContracts;
                                    var firstMarketPaymentToken = deployedContracts.markets[1].paymentToken;
                                    var testUser = accounts.contents[1];
                                    return Contract.PaymentTokenHelpers.mintAndApprove(firstMarketPaymentToken, testUser, ethers.BigNumber.from("10000000000000000000000"), deployedContracts.longShort.address);
                                  }));
                    });
                InitializeMarket.testUnit(contracts, accounts);
                UpdateSystemState.testUnit(contracts, accounts);
                UtilsHelpers.testUnit(contracts, accounts);
                GetUsersConfirmedButNotSettledBalance.testUnit(contracts, accounts);
                PriceCalculationFunctions.testUnit(contracts, accounts);
                BatchedSettlement.testUnit(contracts, accounts);
                MintNextPrice.testUnit(contracts, accounts);
                ShiftNextPrice.testUnit(contracts, accounts);
                ExecuteNextPriceAction.testUnit(contracts, accounts);
                ExecuteOutstandingNextPriceSettlements.testUnit(contracts, accounts);
                RedeemNextPrice.testUnit(contracts, accounts);
                return DepositFunds.testUnit(contracts, accounts);
              }));
        describe("Smocked", (function () {
                var contracts = {
                  contents: "NOT INITIALIZED"
                };
                var accounts = {
                  contents: "NOT INITIALIZED"
                };
                before(function () {
                      return LetOps.Await.let_(ethers.getSigners(), (function (loadedAccounts) {
                                    accounts.contents = loadedAccounts;
                                    return LetOps.Await.let_(Helpers.initializeLongShortUnit(undefined), (function (deployedContracts) {
                                                  contracts.contents = deployedContracts;
                                                  
                                                }));
                                  }));
                    });
                return Globals.describeUnit("Unit tests", (function (param) {
                              return ClaimAndDistributeYieldThenRebalanceMarket.testUnit(contracts, accounts);
                            }));
              }));
        
      }));

/*  Not a pure module */
