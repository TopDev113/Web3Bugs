// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Js_math = require("rescript/lib/js/js_math.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var HelperActions = require("../../library/HelperActions.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");
var Smock = require("@eth-optimism/smock");
var SyntheticTokenSmocked = require("../../library/smock/SyntheticTokenSmocked.js");
var OracleManagerMockSmocked = require("../../library/smock/OracleManagerMockSmocked.js");

function randomValueChange(tokenAmount) {
  return Globals.div(Globals.mul(tokenAmount, ethers.BigNumber.from(Js_math.random_int(-100, 101))), ethers.BigNumber.from("100"));
}

function testUnit(contracts, accounts) {
  return Globals.describeUnit("updateSystemState", (function (param) {
                describe("_updateSystemStateInternal", (function () {
                        var getWalletBinding = ((_r) => { return _r.wallet;});
                        var send1Ether = ((wallet, address) => {
          const tx = {
              to: address,
              value: ethers.utils.parseUnits('1.0', 'ether')
          };
          return wallet.sendTransaction(tx);
        });
                        var marketIndex = Helpers.randomJsInteger(undefined);
                        var match = Helpers.Tuple.make7(Helpers.randomTokenAmount);
                        var oldShortValueAfterYield = match[6];
                        var oldLongValueAfterYield = match[5];
                        var oldShortValue = match[4];
                        var oldLongValue = match[3];
                        var oldShortPrice = match[2];
                        var oldLongPrice = match[1];
                        var oldAssetPrice = match[0];
                        var match$1 = Helpers.Tuple.make2(Helpers.randomTokenAmount);
                        var shortSynthSupply = match$1[1];
                        var longSynthSupply = match$1[0];
                        var valueChangeLong = randomValueChange(oldLongValueAfterYield);
                        var valueChangeShort = randomValueChange(oldShortValueAfterYield);
                        var newAssetPrice = Globals.add(oldAssetPrice, Globals.oneBn);
                        var latestUpdateIndexForMarket = Helpers.randomInteger(undefined);
                        var staker = {
                          contents: undefined
                        };
                        var oracle = {
                          contents: undefined
                        };
                        var longSynth = {
                          contents: undefined
                        };
                        var shortSynth = {
                          contents: undefined
                        };
                        var potentialNewLongPrice = {
                          contents: Globals.zeroBn
                        };
                        var potentialNewShortPrice = {
                          contents: Globals.zeroBn
                        };
                        var setup = function (oldAssetPrice, newAssetPrice, oldLongPrice, oldShortPrice, fromStaker, stakerNextPrice_currentUpdateIndex) {
                          return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setup(contracts.contents.longShort), (function (param) {
                                        return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.longShort, "_updateSystemStateInternal"), (function (param) {
                                                      LongShortSmocked.InternalMock.mock_claimAndDistributeYieldThenRebalanceMarketToReturn(oldLongValueAfterYield, oldShortValueAfterYield);
                                                      LongShortSmocked.InternalMock.mock_batchConfirmOutstandingPendingActionsToReturn(valueChangeLong, valueChangeShort);
                                                      return LetOps.AwaitThen.let_(Smock.smockit(contracts.contents.staker), (function (stakerSmocked) {
                                                                    var stakerWallet = getWalletBinding(stakerSmocked);
                                                                    return LetOps.AwaitThen.let_(send1Ether(accounts.contents[0], stakerWallet.address), (function (param) {
                                                                                  StakerSmocked.mockPushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsToReturn(stakerSmocked);
                                                                                  return LetOps.AwaitThen.let_(Smock.smockit(Belt_Array.getExn(contracts.contents.markets, 1).oracleManager), (function (oracleSmocked) {
                                                                                                OracleManagerMockSmocked.mockUpdatePriceToReturn(oracleSmocked, newAssetPrice);
                                                                                                oracle.contents = oracleSmocked;
                                                                                                staker.contents = stakerSmocked;
                                                                                                return LetOps.AwaitThen.let_(Smock.smockit(Belt_Array.getExn(contracts.contents.markets, 1).longSynth), (function (longSynthSmocked) {
                                                                                                              SyntheticTokenSmocked.mockTotalSupplyToReturn(longSynthSmocked, longSynthSupply);
                                                                                                              longSynth.contents = longSynthSmocked;
                                                                                                              return LetOps.AwaitThen.let_(Smock.smockit(Belt_Array.getExn(contracts.contents.markets, 1).shortSynth), (function (shortSynthSmocked) {
                                                                                                                            SyntheticTokenSmocked.mockTotalSupplyToReturn(shortSynthSmocked, shortSynthSupply);
                                                                                                                            shortSynth.contents = shortSynthSmocked;
                                                                                                                            var longShort = fromStaker ? contracts.contents.longShort.connect(stakerWallet) : contracts.contents.longShort;
                                                                                                                            return LetOps.AwaitThen.let_(longShort._getSyntheticTokenPriceExposed(oldLongValueAfterYield, longSynthSupply), (function (predictedLongPrice) {
                                                                                                                                          potentialNewLongPrice.contents = predictedLongPrice;
                                                                                                                                          return LetOps.AwaitThen.let_(longShort._getSyntheticTokenPriceExposed(oldShortValueAfterYield, shortSynthSupply), (function (predictedShortPrice) {
                                                                                                                                                        potentialNewShortPrice.contents = predictedShortPrice;
                                                                                                                                                        return LetOps.AwaitThen.let_(longShort.set_updateSystemStateInternalGlobals(marketIndex, latestUpdateIndexForMarket, oldLongPrice, oldShortPrice, oldAssetPrice, oldLongValue, oldShortValue, oracleSmocked.address, stakerSmocked.address, longSynthSmocked.address, shortSynthSmocked.address, stakerNextPrice_currentUpdateIndex), (function (param) {
                                                                                                                                                                      return longShort._updateSystemStateInternalExposed(marketIndex);
                                                                                                                                                                    }));
                                                                                                                                                      }));
                                                                                                                                        }));
                                                                                                                          }));
                                                                                                            }));
                                                                                              }));
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                        };
                        var setupWithoutPriceChange = function (param, param$1) {
                          return setup(oldAssetPrice, oldAssetPrice, oldLongPrice, oldShortPrice, param, param$1);
                        };
                        var assertNoUpdateStateOrNonOracleCalls = function (checkNoStakerCalls) {
                          if (checkNoStakerCalls) {
                            var numberOfStakerCalls = StakerSmocked.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsCalls(staker.contents).length;
                            Chai.intEqual(undefined, numberOfStakerCalls, 0);
                          }
                          var numberOfClaimAndAdjustCalls = LongShortSmocked.InternalMock._claimAndDistributeYieldThenRebalanceMarketCalls(undefined).length;
                          var numberOfGetTokenPriceCalls = LongShortSmocked.InternalMock._getSyntheticTokenPriceCalls(undefined).length;
                          var numberOfOutstandingSettlementCalls = LongShortSmocked.InternalMock._batchConfirmOutstandingPendingActionsCalls(undefined).length;
                          var numberOfTotalSupplyLongCalls = SyntheticTokenSmocked.totalSupplyCalls(longSynth.contents).length;
                          var numberOfTotalSupplyShortCalls = SyntheticTokenSmocked.totalSupplyCalls(shortSynth.contents).length;
                          return LetOps.AwaitThen.let_(contracts.contents.longShort.marketUpdateIndex(marketIndex), (function (updateIndex) {
                                        return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, true, updateIndex), (function (newLongPrice) {
                                                      return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, false, updateIndex), (function (newShortPrice) {
                                                                    return LetOps.Await.let_(contracts.contents.longShort.assetPrice(marketIndex), (function (assetPrice) {
                                                                                  Chai.bnEqual(undefined, oldAssetPrice, assetPrice);
                                                                                  Chai.bnEqual(undefined, updateIndex, latestUpdateIndexForMarket);
                                                                                  Chai.bnEqual(undefined, newLongPrice, oldLongPrice);
                                                                                  Chai.bnEqual(undefined, newShortPrice, oldShortPrice);
                                                                                  Chai.intEqual(undefined, numberOfClaimAndAdjustCalls, 0);
                                                                                  Chai.intEqual(undefined, numberOfGetTokenPriceCalls, 0);
                                                                                  Chai.intEqual(undefined, numberOfTotalSupplyLongCalls, 0);
                                                                                  Chai.intEqual(undefined, numberOfTotalSupplyShortCalls, 0);
                                                                                  return Chai.intEqual(undefined, numberOfOutstandingSettlementCalls, 0);
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                        };
                        it("calls for the latest price from the oracle", (function () {
                                return LetOps.Await.let_(setupWithoutPriceChange(true, Globals.zeroBn), (function (param) {
                                              return Chai.intEqual(undefined, OracleManagerMockSmocked.updatePriceCalls(oracle.contents).length, 1);
                                            }));
                              }));
                        it("calls pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations on the staker if the staker has pending nextPrice shifts", (function () {
                                var stakerNextPrice_currentUpdateIndex = Globals.add(latestUpdateIndexForMarket, Globals.oneBn);
                                return LetOps.Await.let_(setup(oldAssetPrice, newAssetPrice, oldLongPrice, oldShortPrice, true, stakerNextPrice_currentUpdateIndex), (function (param) {
                                              return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsCalls(staker.contents), [{
                                                            marketIndex: marketIndex,
                                                            longPrice: oldLongPrice,
                                                            shortPrice: oldShortPrice,
                                                            longValue: oldLongValue,
                                                            shortValue: oldShortValue,
                                                            stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted: stakerNextPrice_currentUpdateIndex
                                                          }]);
                                            }));
                              }));
                        it("it shouldn't modify state or call other functions IF the `msg.sender` isn't the staker AND the price didn't change", (function () {
                                return LetOps.AwaitThen.let_(setupWithoutPriceChange(false, Globals.zeroBn), (function (param) {
                                              return assertNoUpdateStateOrNonOracleCalls(true);
                                            }));
                              }));
                        it("it should call the pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations on the staker function if the `msg.sender` is the staker (with NO price change) but not update any state or call other functions in the LongShort contract", (function () {
                                return LetOps.AwaitThen.let_(setupWithoutPriceChange(true, Globals.zeroBn), (function (param) {
                                              Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsCalls(staker.contents), [{
                                                      marketIndex: marketIndex,
                                                      longPrice: oldLongPrice,
                                                      shortPrice: oldShortPrice,
                                                      longValue: oldLongValue,
                                                      shortValue: oldShortValue,
                                                      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted: Globals.zeroBn
                                                    }]);
                                              return assertNoUpdateStateOrNonOracleCalls(false);
                                            }));
                              }));
                        describe("There is a price change", (function () {
                                var setupWithPriceChange = function (param, param$1) {
                                  return setup(oldAssetPrice, newAssetPrice, oldLongPrice, oldShortPrice, param, param$1);
                                };
                                it("it should call the pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations on the staker function if the `msg.sender` is the staker (WITH a price change)", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(true, Globals.zeroBn), (function (param) {
                                                      return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsCalls(staker.contents), [{
                                                                    marketIndex: marketIndex,
                                                                    longPrice: oldLongPrice,
                                                                    shortPrice: oldShortPrice,
                                                                    longValue: oldLongValue,
                                                                    shortValue: oldShortValue,
                                                                    stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted: Globals.zeroBn
                                                                  }]);
                                                    }));
                                      }));
                                it("it should call `_claimAndDistributeYieldThenRebalanceMarket` with correct arguments", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.InternalMock._claimAndDistributeYieldThenRebalanceMarketCalls(undefined), [{
                                                                    marketIndex: marketIndex,
                                                                    newAssetPrice: newAssetPrice,
                                                                    oldAssetPrice: oldAssetPrice
                                                                  }]);
                                                    }));
                                      }));
                                it("it should call `_performOustandingSettlements` with correct arguments", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.InternalMock._batchConfirmOutstandingPendingActionsCalls(undefined), [{
                                                                    marketIndex: marketIndex,
                                                                    syntheticTokenPrice_inPaymentTokens_long: potentialNewLongPrice.contents,
                                                                    syntheticTokenPrice_inPaymentTokens_short: potentialNewShortPrice.contents
                                                                  }]);
                                                    }));
                                      }));
                                it("should call `totalSupply` on the long and short synth tokens", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      Chai.intEqual(undefined, SyntheticTokenSmocked.totalSupplyCalls(longSynth.contents).length, 1);
                                                      return Chai.intEqual(undefined, SyntheticTokenSmocked.totalSupplyCalls(shortSynth.contents).length, 1);
                                                    }));
                                      }));
                                it("should mutate syntheticToken_priceSnapshots for long and short correctly", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      var newUpdateIndex = Globals.add(latestUpdateIndexForMarket, Globals.oneBn);
                                                      return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, true, newUpdateIndex), (function (newLongPrice) {
                                                                    return LetOps.Await.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, false, newUpdateIndex), (function (newShortPrice) {
                                                                                  Chai.bnEqual(undefined, newLongPrice, potentialNewLongPrice.contents);
                                                                                  return Chai.bnEqual(undefined, newShortPrice, potentialNewShortPrice.contents);
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                                it("should mutate marketSideValueInPaymentTokens for long and short correctly", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      return LetOps.AwaitThen.let_(contracts.contents.longShort.marketSideValueInPaymentToken(marketIndex, true), (function (newLongValue) {
                                                                    return LetOps.Await.let_(contracts.contents.longShort.marketSideValueInPaymentToken(marketIndex, false), (function (newShortValue) {
                                                                                  Chai.bnEqual(undefined, newLongValue, Globals.add(oldLongValueAfterYield, valueChangeLong));
                                                                                  return Chai.bnEqual(undefined, newShortValue, Globals.add(oldShortValueAfterYield, valueChangeShort));
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                                it("it should update the (underlying) asset price correctly", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      return LetOps.Await.let_(contracts.contents.longShort.assetPrice(marketIndex), (function (assetPrice) {
                                                                    return Chai.bnEqual(undefined, assetPrice, newAssetPrice);
                                                                  }));
                                                    }));
                                      }));
                                it("it should increment the marketUpdateIndex by 1", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(false, Globals.zeroBn), (function (param) {
                                                      return LetOps.Await.let_(contracts.contents.longShort.marketUpdateIndex(marketIndex), (function (updateIndex) {
                                                                    return Chai.bnEqual(undefined, Globals.add(latestUpdateIndexForMarket, Globals.oneBn), updateIndex);
                                                                  }));
                                                    }));
                                      }));
                                it("it should emit the SystemStateUpdated event with the correct arguments", (function () {
                                        return Chai.callEmitEvents(setupWithPriceChange(false, Globals.zeroBn), contracts.contents.longShort, "SystemStateUpdated").withArgs(marketIndex, Globals.add(latestUpdateIndexForMarket, Globals.oneBn), newAssetPrice, Globals.add(oldLongValueAfterYield, valueChangeLong), Globals.add(oldShortValueAfterYield, valueChangeShort), potentialNewLongPrice.contents, potentialNewShortPrice.contents);
                                      }));
                                
                              }));
                        
                      }));
                var setupWithUpdateSystemStateInternalMocked = function (functionName) {
                  return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setup(contracts.contents.longShort), (function (param) {
                                return LetOps.Await.let_(LongShortSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.longShort, functionName), (function (param) {
                                              return LongShortSmocked.InternalMock.mock_updateSystemStateInternalToReturn(undefined);
                                            }));
                              }));
                };
                describe("updateSystemStateMulti", (function () {
                        it("should call `_updateSystemStateInternal` for each market in the array", (function () {
                                var marketIndexes = Belt_Array.makeBy(Js_math.random_int(0, 51), (function (param) {
                                        return Helpers.randomJsInteger(undefined);
                                      }));
                                return LetOps.AwaitThen.let_(setupWithUpdateSystemStateInternalMocked("updateSystemStateMulti"), (function (param) {
                                              return LetOps.AwaitThen.let_(contracts.contents.longShort.setMarketExistsMulti(marketIndexes), (function (param) {
                                                            return LetOps.Await.let_(contracts.contents.longShort.updateSystemStateMulti(marketIndexes), (function (param) {
                                                                          return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.InternalMock._updateSystemStateInternalCalls(undefined), Belt_Array.map(marketIndexes, (function (index) {
                                                                                            return {
                                                                                                    marketIndex: index
                                                                                                  };
                                                                                          })));
                                                                        }));
                                                          }));
                                            }));
                              }));
                        
                      }));
                describe("updateSystemState", (function () {
                        it("should call to `_updateSystemStateInternal` with the correct market as an argument", (function () {
                                var marketIndex = Helpers.randomJsInteger(undefined);
                                return LetOps.AwaitThen.let_(setupWithUpdateSystemStateInternalMocked("updateSystemState"), (function (param) {
                                              return LetOps.AwaitThen.let_(contracts.contents.longShort.setMarketExistsMulti([marketIndex]), (function (param) {
                                                            return LetOps.Await.let_(contracts.contents.longShort.updateSystemState(marketIndex), (function (param) {
                                                                          return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.InternalMock._updateSystemStateInternalCalls(undefined), [{
                                                                                        marketIndex: marketIndex
                                                                                      }]);
                                                                        }));
                                                          }));
                                            }));
                              }));
                        
                      }));
                
              }));
}

function testIntegration(contracts, accounts) {
  describe("updateSystemState", (function () {
          var testDistributeYield = function (longIsOverBalanced) {
            it("distribute yield to markets flow " + (
                  longIsOverBalanced ? "(long over balanced)" : "(short over balanced)"
                ), (function () {
                    var match = contracts.contents;
                    var longShort = match.longShort;
                    var match$1 = match.markets[0];
                    var marketIndex = match$1.marketIndex;
                    var yieldManager = match$1.yieldManager;
                    var oracleManager = match$1.oracleManager;
                    var paymentToken = match$1.paymentToken;
                    var testUser = accounts.contents[2];
                    var amountOfYieldToAward = Globals.bnFromString("3216543216543216542");
                    return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, !longIsOverBalanced), (function (amountToMintToGuaranteeImbalance) {
                                  return LetOps.AwaitThen.let_(HelperActions.mintDirect(marketIndex, amountToMintToGuaranteeImbalance, paymentToken, testUser, longShort, oracleManager, longIsOverBalanced), (function (param) {
                                                return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, true), (function (longTokenPoolValueBefore) {
                                                              return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, false), (function (shortTokenPoolValueBefore) {
                                                                            return LetOps.Await.let_(yieldManager.totalReservedForTreasury(), (function (totalDueForTreasuryBefore) {
                                                                                          var totalValueRelatedToMarketBefore = Globals.add(Globals.add(longTokenPoolValueBefore, shortTokenPoolValueBefore), totalDueForTreasuryBefore);
                                                                                          yieldManager.settleWithYieldAbsolute(amountOfYieldToAward);
                                                                                          return LetOps.Await.let_(oracleManager.getLatestPrice(), (function (currentOraclePrice) {
                                                                                                        return LetOps.Await.let_(oracleManager.setPrice(Globals.add(currentOraclePrice, Globals.bnFromInt(1))), (function (param) {
                                                                                                                      return LetOps.Await.let_(longShort.updateSystemState(marketIndex), (function (param) {
                                                                                                                                    return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, true), (function (longTokenPoolValueAfter) {
                                                                                                                                                  return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, false), (function (shortTokenPoolValueAfter) {
                                                                                                                                                                return LetOps.Await.let_(yieldManager.totalReservedForTreasury(), (function (totalDueForTreasuryAfter) {
                                                                                                                                                                              var totalValueRelatedToMarketAfter = Globals.add(Globals.add(longTokenPoolValueAfter, shortTokenPoolValueAfter), totalDueForTreasuryAfter);
                                                                                                                                                                              return Chai.bnEqual("yield is either being lost or over-allocated - should be exactly the same", Globals.add(totalValueRelatedToMarketBefore, amountOfYieldToAward), totalValueRelatedToMarketAfter);
                                                                                                                                                                            }));
                                                                                                                                                              }));
                                                                                                                                                }));
                                                                                                                                  }));
                                                                                                                    }));
                                                                                                      }));
                                                                                        }));
                                                                          }));
                                                            }));
                                              }));
                                }));
                  }));
            
          };
          testDistributeYield(true);
          testDistributeYield(false);
          it("cannot call updateSystemState on a market that doesn't exist", (function () {
                  return Chai.expectRevert(contracts.contents.longShort.updateSystemState(321321654), "market doesn't exist");
                }));
          
        }));
  
}

exports.randomValueChange = randomValueChange;
exports.testUnit = testUnit;
exports.testIntegration = testIntegration;
/* Chai Not a pure module */
