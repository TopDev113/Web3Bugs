// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var StakerHelpers = require("./StakerHelpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function test(contracts, accounts) {
  var marketIndex = Helpers.randomJsInteger(undefined);
  var match = Helpers.Tuple.make6(Helpers.randomInteger);
  var timeDelta = match[5];
  var accumFloatShort = match[4];
  var accumFloatLong = match[3];
  var latestRewardIndexForMarket = match[2];
  var shortFloatPerSecond = match[1];
  var longFloatPerSecond = match[0];
  var match$1 = Helpers.Tuple.make4(Helpers.randomInteger);
  var shortPrice = match$1[3];
  var longPrice = match$1[2];
  var shortValue = match$1[1];
  var longValue = match$1[0];
  describe("calculateNewCumulativeValue", (function () {
          var promiseRef = {
            contents: undefined
          };
          Globals.before_once$p(function (param) {
                return LetOps.AwaitThen.let_(StakerHelpers.deployAndSetupStakerToUnitTest("calculateNewCumulativeValue", contracts, accounts), (function (param) {
                              var match = contracts.contents;
                              var staker = match.staker;
                              StakerSmocked.InternalMock.mock_calculateFloatPerSecondToReturn(longFloatPerSecond, shortFloatPerSecond);
                              StakerSmocked.InternalMock.mock_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotToReturn(timeDelta);
                              return LetOps.Await.let_(staker.setCalculateNewCumulativeRateParams(marketIndex, latestRewardIndexForMarket, accumFloatLong, accumFloatShort), (function (param) {
                                            promiseRef.contents = staker._calculateNewCumulativeIssuancePerStakedSynthExposed(marketIndex, longPrice, shortPrice, longValue, shortValue);
                                            return LetOps.Await.let_(promiseRef.contents, (function (param) {
                                                          
                                                        }));
                                          }));
                            }));
              });
          it("returns the old cumulative float + (timeDelta * floatPerSecond) for each market side", (function () {
                  var mockFn = function (oldCumulative, timeDelta, fps) {
                    return oldCumulative.add(timeDelta.mul(fps));
                  };
                  return LetOps.Await.let_(promiseRef.contents, (function (result) {
                                var longCumulative = result[0];
                                var shortCumulative = result[1];
                                Chai.bnEqual(undefined, longCumulative, mockFn(accumFloatLong, timeDelta, longFloatPerSecond));
                                return Chai.bnEqual(undefined, shortCumulative, mockFn(accumFloatShort, timeDelta, shortFloatPerSecond));
                              }));
                }));
          it("calls calculateFloatPerSecond with correct arguments", (function () {
                  var call = Belt_Array.getExn(StakerSmocked.InternalMock._calculateFloatPerSecondCalls(undefined), 0);
                  return Chai.recordEqualFlat(call, {
                              marketIndex: marketIndex,
                              longPrice: longPrice,
                              shortPrice: shortPrice,
                              longValue: longValue,
                              shortValue: shortValue
                            });
                }));
          it("calls calculateTimeDelta with correct arguments", (function () {
                  var call = StakerSmocked.InternalMock._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotCalls(undefined)[0];
                  return Chai.recordEqualFlat(call, {
                              marketIndex: marketIndex
                            });
                }));
          
        }));
  
}

exports.test = test;
/* Chai Not a pure module */
