// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var StakerHelpers = require("./StakerHelpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function test(contracts, accounts) {
  var promiseRef = {
    contents: undefined
  };
  var timestampRef = {
    contents: CONSTANTS.zeroBn
  };
  var marketIndex = Helpers.randomJsInteger(undefined);
  var match = Helpers.Tuple.make7(Helpers.randomInteger);
  var shortValue = match[6];
  var longValue = match[5];
  var shortPrice = match[4];
  var longPrice = match[3];
  var latestRewardIndexForMarket = match[2];
  var shortAccum = match[1];
  var longAccum = match[0];
  describe("setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot", (function () {
          Globals.before_once$p(function (param) {
                return LetOps.AwaitThen.let_(StakerHelpers.deployAndSetupStakerToUnitTest("setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot", contracts, accounts), (function (param) {
                              StakerSmocked.InternalMock.mock_calculateNewCumulativeIssuancePerStakedSynthToReturn(longAccum, shortAccum);
                              return LetOps.AwaitThen.let_(contracts.contents.staker.setSetRewardObjectsParams(marketIndex, latestRewardIndexForMarket), (function (param) {
                                            return LetOps.Await.let_(Helpers.getBlock(undefined), (function (param) {
                                                          timestampRef.contents = ethers.BigNumber.from(param.timestamp + 1 | 0);
                                                          promiseRef.contents = contracts.contents.staker._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotExposed(marketIndex, longPrice, shortPrice, longValue, shortValue);
                                                          return LetOps.Await.let_(promiseRef.contents, (function (param) {
                                                                        
                                                                      }));
                                                        }));
                                          }));
                            }));
              });
          it("calls calculateNewCumulativeIssuancePerStakedSynth with correct arguments", (function () {
                  return Chai.recordEqualFlat(Belt_Array.getExn(StakerSmocked.InternalMock._calculateNewCumulativeIssuancePerStakedSynthCalls(undefined), 0), {
                              marketIndex: marketIndex,
                              longPrice: longPrice,
                              shortPrice: shortPrice,
                              longValue: longValue,
                              shortValue: shortValue
                            });
                }));
          var mutatedIndex = latestRewardIndexForMarket.add(CONSTANTS.oneBn);
          it("mutates latestRewardIndex", (function () {
                  return LetOps.Await.let_(contracts.contents.staker.latestRewardIndex(marketIndex), (function (latestRewardIndex) {
                                return Chai.bnEqual(undefined, latestRewardIndex, mutatedIndex);
                              }));
                }));
          it("mutates accumulativeFloatPerSyntheticTokenSnapshots", (function () {
                  return LetOps.Await.let_(contracts.contents.staker.accumulativeFloatPerSyntheticTokenSnapshots(marketIndex, mutatedIndex), (function (rewardParams) {
                                return Chai.recordEqualFlat(rewardParams, {
                                            timestamp: timestampRef.contents,
                                            accumulativeFloatPerSyntheticToken_long: longAccum,
                                            accumulativeFloatPerSyntheticToken_short: shortAccum
                                          });
                              }));
                }));
          it("emits AccumulativeIssuancePerStakedSynthSnapshotCreated event", (function () {
                  return Chai.callEmitEvents(promiseRef.contents, contracts.contents.staker, "AccumulativeIssuancePerStakedSynthSnapshotCreated").withArgs(marketIndex, mutatedIndex, longAccum, shortAccum);
                }));
          
        }));
  
}

exports.test = test;
/* Chai Not a pure module */
