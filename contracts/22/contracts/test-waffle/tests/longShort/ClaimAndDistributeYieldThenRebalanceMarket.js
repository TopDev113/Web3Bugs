// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");
var YieldManagerAaveSmocked = require("../../library/smock/YieldManagerAaveSmocked.js");

function testUnit(contracts, param) {
  return Globals.describeUnit("_claimAndDistributeYieldThenRebalanceMarket", (function (param) {
                var marketIndex = Helpers.randomJsInteger(undefined);
                var oldAssetPrice = Helpers.randomTokenAmount(undefined);
                var treasuryYieldPercent_e18 = Helpers.randomRatio1e18(undefined);
                var marketAmountFromYieldManager = Helpers.randomTokenAmount(undefined);
                Globals.before_once$p(function (param) {
                      return LongShortSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.longShort, "_claimAndDistributeYieldThenRebalanceMarket");
                    });
                var setup = function (newAssetPrice) {
                  return contracts.contents.longShort.callStatic._claimAndDistributeYieldThenRebalanceMarketExposed(marketIndex, newAssetPrice, oldAssetPrice);
                };
                var runTests = function (marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort) {
                  var totalValueLockedInMarket = Globals.add(marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort);
                  var match = Globals.bnGt(marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort) ? [
                      marketSideValueInPaymentTokenLong,
                      Globals.add(marketSideValueInPaymentTokenShort, marketAmountFromYieldManager)
                    ] : [
                      Globals.add(marketSideValueInPaymentTokenLong, marketAmountFromYieldManager),
                      marketSideValueInPaymentTokenShort
                    ];
                  var yieldDistributedValueShort = match[1];
                  var yieldDistributedValueLong = match[0];
                  Globals.before_once$p(function (param) {
                        return LetOps.Await.let_(contracts.contents.longShort.setClaimAndDistributeYieldThenRebalanceMarketGlobals(marketIndex, marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort, contracts.contents.yieldManagerSmocked.address), (function (param) {
                                      var isLongSideUnderbalanced = Globals.bnLt(marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort);
                                      LongShortSmocked.InternalMock.mock_getYieldSplitToReturn(isLongSideUnderbalanced, treasuryYieldPercent_e18);
                                      return YieldManagerAaveSmocked.mockDistributeYieldForTreasuryAndReturnMarketAllocationToReturn(contracts.contents.yieldManagerSmocked, marketAmountFromYieldManager);
                                    }));
                      });
                  describe("Function calls", (function () {
                          Globals.before_once$p(function (param) {
                                return setup(Helpers.adjustNumberRandomlyWithinRange(-99999, 99999, oldAssetPrice));
                              });
                          it("calls _getYieldSplit with correct parameters", (function () {
                                  return Chai.recordArrayDeepEqualFlat(undefined, LongShortSmocked.InternalMock._getYieldSplitCalls(undefined), [{
                                                marketIndex: marketIndex,
                                                longValue: marketSideValueInPaymentTokenLong,
                                                shortValue: marketSideValueInPaymentTokenShort,
                                                totalValueLockedInMarket: totalValueLockedInMarket
                                              }]);
                                }));
                          it("gets the treasuryYieldPercent from _getYieldSplit and calls distributeYieldForTreasuryAndReturnMarketAllocation on the yieldManager with correct amount", (function () {
                                  return Chai.recordArrayDeepEqualFlat(undefined, YieldManagerAaveSmocked.distributeYieldForTreasuryAndReturnMarketAllocationCalls(contracts.contents.yieldManagerSmocked), [{
                                                totalValueRealizedForMarket: totalValueLockedInMarket,
                                                treasuryYieldPercent_e18: treasuryYieldPercent_e18
                                              }]);
                                }));
                          
                        }));
                  it("returns the correct updated long and short values when price has remained the same (newAssetPrice == oldAssetPrice)", (function () {
                          return LetOps.Await.let_(setup(oldAssetPrice), (function (param) {
                                        Chai.bnEqual(undefined, yieldDistributedValueLong, param.longValue);
                                        return Chai.bnEqual(undefined, yieldDistributedValueShort, param.shortValue);
                                      }));
                        }));
                  it("returns the correct updated long and short values when price has increased (newAssetPrice > oldAssetPrice)", (function () {
                          var newAssetPrice = Helpers.adjustNumberRandomlyWithinRange(0, 99999, oldAssetPrice);
                          return LetOps.Await.let_(setup(newAssetPrice), (function (param) {
                                        var unbalancedSidePoolValue = Globals.bnMin(yieldDistributedValueLong, yieldDistributedValueShort);
                                        var valueChange = Globals.div(Globals.mul(Globals.sub(newAssetPrice, oldAssetPrice), unbalancedSidePoolValue), oldAssetPrice);
                                        Chai.bnEqual(undefined, Globals.add(yieldDistributedValueLong, valueChange), param.longValue);
                                        return Chai.bnEqual(undefined, Globals.sub(yieldDistributedValueShort, valueChange), param.shortValue);
                                      }));
                        }));
                  it("returns the correct updated long and short values when price has decreased (newAssetPrice < oldAssetPrice)", (function () {
                          var newAssetPrice = Helpers.adjustNumberRandomlyWithinRange(-99999, 0, oldAssetPrice);
                          return LetOps.Await.let_(setup(newAssetPrice), (function (param) {
                                        var unbalancedSidePoolValue = Globals.bnMin(yieldDistributedValueLong, yieldDistributedValueShort);
                                        var valueChange = Globals.div(Globals.mul(Globals.sub(newAssetPrice, oldAssetPrice), unbalancedSidePoolValue), oldAssetPrice);
                                        Chai.bnEqual(undefined, Globals.add(yieldDistributedValueLong, valueChange), param.longValue);
                                        return Chai.bnEqual(undefined, Globals.sub(yieldDistributedValueShort, valueChange), param.shortValue);
                                      }));
                        }));
                  
                };
                describe("Long Side is Overvalued", (function () {
                        var marketSideValueInPaymentTokenShort = Helpers.randomTokenAmount(undefined);
                        var marketSideValueInPaymentTokenLong = Globals.add(marketSideValueInPaymentTokenShort, Helpers.randomTokenAmount(undefined));
                        return runTests(marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort);
                      }));
                describe("Short Side is Overvalued", (function () {
                        var marketSideValueInPaymentTokenLong = Helpers.randomTokenAmount(undefined);
                        var marketSideValueInPaymentTokenShort = Globals.add(marketSideValueInPaymentTokenLong, Helpers.randomTokenAmount(undefined));
                        return runTests(marketSideValueInPaymentTokenLong, marketSideValueInPaymentTokenShort);
                      }));
                
              }));
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
