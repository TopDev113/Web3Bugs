{
  "language": "Solidity",
  "sources": {
    "contracts/mini-sales/AllowlistPurchaseHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IAllowlistPurchaseHook.sol\";\nimport \"../ppo/interfaces/IAccountList.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract AllowlistPurchaseHook is IAllowlistPurchaseHook, SafeOwnable {\n  IAccountList private _allowlist;\n\n  constructor() {}\n\n  function hook(\n    address _purchaser,\n    address _recipient,\n    uint256 _amount,\n    uint256 _price,\n    bytes calldata _data\n  ) public virtual override {\n    require(_allowlist.isIncluded(_recipient), \"Recipient not allowed\");\n  }\n\n  function setAllowlist(IAccountList _newAllowlist)\n    external\n    override\n    onlyOwner\n  {\n    _allowlist = _newAllowlist;\n    emit AllowlistChange(_newAllowlist);\n  }\n\n  function getAllowlist() external view override returns (IAccountList) {\n    return _allowlist;\n  }\n}\n"
    },
    "contracts/mini-sales/interfaces/IAllowlistPurchaseHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./IPurchaseHook.sol\";\nimport \"../../ppo/interfaces/IAccountList.sol\";\n\n/**\n * @notice Hook that provides allowlist functionality for a `MiniSales`\n * purchase. Only allowed addresses can participate in a sale with this hook\n * enabled.\n */\ninterface IAllowlistPurchaseHook is IPurchaseHook {\n  /**\n   * @dev Emitted via `setAllowlist()`.\n   * @param newAllowlist Address of the new allowlist\n   */\n  event AllowlistChange(IAccountList newAllowlist);\n\n  /**\n   * @notice Sets the allowlist containing addresses that are allowed to\n   * purchase.\n   * @dev Only callable by `owner()`.\n   * @param newAllowlist Address of the new allowlist\n   */\n  function setAllowlist(IAccountList newAllowlist) external;\n\n  /// @return The allowlist contract\n  function getAllowlist() external view returns (IAccountList);\n}\n"
    },
    "contracts/ppo/interfaces/IAccountList.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice Stores whether an address is included in a set.\n */\ninterface IAccountList {\n  /**\n   * @notice Sets whether an address in `accounts` is included.\n   * @dev Whether an account is included is based on the boolean value at its\n   * respective index in `included`. This function will only edit the\n   * inclusion of addresses in `accounts`.\n   *\n   * The length of `accounts` and `included` must match.\n   *\n   * Only callable by `owner()`.\n   * @param accounts Addresses to change inclusion for\n   * @param included Whether to include corresponding address in `accounts`\n   */\n  function set(address[] calldata accounts, bool[] calldata included) external;\n\n  /**\n   * @notice Removes every address from the set. Atomically includes any\n   * addresses in `newIncludedAccounts`.\n   * @dev Only callable by `owner()`.\n   * @param newIncludedAccounts Addresses to include after reset\n   */\n  function reset(address[] calldata newIncludedAccounts) external;\n\n  /**\n   * @param account Address to check inclusion for\n   * @return Whether `account` is included\n   */\n  function isIncluded(address account) external view returns (bool);\n}\n"
    },
    "prepo-shared-contracts/contracts/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ISafeOwnable.sol\";\n\ncontract SafeOwnable is ISafeOwnable, Ownable {\n  address private _nominee;\n\n  modifier onlyNominee() {\n    require(_msgSender() == _nominee, \"msg.sender != nominee\");\n    _;\n  }\n\n  function transferOwnership(address _newNominee)\n    public\n    virtual\n    override(ISafeOwnable, Ownable)\n    onlyOwner\n  {\n    _setNominee(_newNominee);\n  }\n\n  function acceptOwnership() public virtual override onlyNominee {\n    _transferOwnership(_nominee);\n    _setNominee(address(0));\n  }\n\n  function renounceOwnership()\n    public\n    virtual\n    override(ISafeOwnable, Ownable)\n    onlyOwner\n  {\n    super.renounceOwnership();\n    _setNominee(address(0));\n  }\n\n  function getNominee() public view virtual override returns (address) {\n    return _nominee;\n  }\n\n  function _setNominee(address _newNominee) internal virtual {\n    address _oldNominee = _nominee;\n    _nominee = _newNominee;\n    emit NomineeUpdate(_oldNominee, _newNominee);\n  }\n}\n"
    },
    "contracts/mini-sales/interfaces/IPurchaseHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice Hook to be called when a user makes a `MiniSales` purchase.\n * @dev A hook could contain purchase restriction logic and/or update\n * auxiliary data.\n */\ninterface IPurchaseHook {\n  /**\n   * @notice Hook to be called when a user makes a `MiniSales` purchase.\n   * @param purchaser Address that payment token was taken from\n   * @param recipient Address that sale token was delivered to\n   * @param amount Amount of sale token purchased\n   * @param price Sale token price in terms of payment token\n   * @param data Data payload for supporting additional hook functionality\n   */\n  function hook(\n    address purchaser,\n    address recipient,\n    uint256 amount,\n    uint256 price,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "prepo-shared-contracts/contracts/interfaces/ISafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice An extension of OpenZeppelin's `Ownable.sol` contract that requires\n * an address to be nominated, and then accept that nomination, before\n * ownership is transferred.\n */\ninterface ISafeOwnable {\n  /**\n   * @dev Emitted via `transferOwnership()`.\n   * @param previousNominee The previous nominee\n   * @param newNominee The new nominee\n   */\n  event NomineeUpdate(\n    address indexed previousNominee,\n    address indexed newNominee\n  );\n\n  /**\n   * @notice Nominates an address to be owner of the contract.\n   * @dev Only callable by `owner()`.\n   * @param nominee The address that will be nominated\n   */\n  function transferOwnership(address nominee) external;\n\n  /**\n   * @notice Renounces ownership of contract and leaves the contract\n   * without any owner.\n   * @dev Only callable by `owner()`.\n   * Sets nominee back to zero address.\n   * It will not be possible to call `onlyOwner` functions anymore.\n   */\n  function renounceOwnership() external;\n\n  /**\n   * @notice Accepts ownership nomination.\n   * @dev Only callable by the current nominee. Sets nominee back to zero\n   * address.\n   */\n  function acceptOwnership() external;\n\n  /// @return The current nominee\n  function getNominee() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "prepo-shared-contracts/contracts/WithdrawERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"./interfaces/IWithdrawERC1155.sol\";\nimport \"./SafeOwnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract WithdrawERC1155 is IWithdrawERC1155, SafeOwnable, ReentrancyGuard {\n  constructor() {}\n\n  function withdrawERC1155(\n    address[] calldata _erc1155Tokens,\n    address[] calldata _recipients,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts\n  ) external override onlyOwner nonReentrant {\n    require(\n      _erc1155Tokens.length == _recipients.length &&\n        _recipients.length == _ids.length &&\n        _ids.length == _amounts.length,\n      \"Array length mismatch\"\n    );\n    uint256 _arrayLength = _erc1155Tokens.length;\n    for (uint256 i; i < _arrayLength; ) {\n      IERC1155(_erc1155Tokens[i]).safeTransferFrom(\n        address(this),\n        _recipients[i],\n        _ids[i],\n        _amounts[i],\n        \"\"\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes memory\n  ) external pure returns (bytes4) {\n    return this.onERC1155Received.selector;\n  }\n\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] memory,\n    uint256[] memory,\n    bytes memory\n  ) external pure returns (bytes4) {\n    return this.onERC1155BatchReceived.selector;\n  }\n}\n"
    },
    "prepo-shared-contracts/contracts/interfaces/IWithdrawERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @notice Allows a contract owner to withdraw any ERC1155s residing\n * within the contract to destinations of their choosing.\n */\ninterface IWithdrawERC1155 {\n  /**\n   * @notice Withdraws corresponding `amounts` of `ids` of each ERC1155 in\n   * `erc1155Tokens` and sends them to their respective addresses in\n   * `recipients`.\n   * @dev Length of `erc1155Tokens`, `recipients`, `ids`, `amounts` must\n   * match.\n   *\n   * Only callable by `owner()`.\n   * @param erc1155Tokens ERC1155 tokens to be withdrawn\n   * @param recipients Addresses to send tokens to\n   * @param ids IDs of tokens to be withdrawn\n   * @param amounts Amount of each token to be withdrawn\n   */\n  function withdrawERC1155(\n    address[] calldata erc1155Tokens,\n    address[] calldata recipients,\n    uint256[] calldata ids,\n    uint256[] calldata amounts\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "prepo-shared-contracts/contracts/WithdrawERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"./interfaces/IWithdrawERC721.sol\";\nimport \"./SafeOwnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract WithdrawERC721 is IWithdrawERC721, SafeOwnable, ReentrancyGuard {\n  constructor() {}\n\n  function withdrawERC721(\n    address[] calldata _erc721Tokens,\n    address[] calldata _recipients,\n    uint256[] calldata _ids\n  ) external override onlyOwner nonReentrant {\n    require(_erc721Tokens.length == _ids.length, \"Array length mismatch\");\n    uint256 _arrayLength = _erc721Tokens.length;\n    for (uint256 i; i < _arrayLength; ) {\n      IERC721(_erc721Tokens[i]).transferFrom(\n        address(this),\n        _recipients[i],\n        _ids[i]\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "prepo-shared-contracts/contracts/interfaces/IWithdrawERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @notice Allows a contract owner to withdraw any ERC721s residing\n * within the contract to destinations of their choosing.\n */\ninterface IWithdrawERC721 {\n  /**\n   * @notice Withdraws corresponding `ids` of each ERC721 in `erc721Tokens`\n   * and sends them to their respective address in `recipients`.\n   * @dev Length of `erc721Tokens`, `recipients` and `ids` must match.\n   *\n   * Only callable by `owner()`.\n   * @param erc721Tokens ERC721 tokens to be withdrawn\n   * @param recipients Addresses to send tokens to\n   * @param ids IDs of tokens to be withdrawn\n   */\n  function withdrawERC721(\n    address[] calldata erc721Tokens,\n    address[] calldata recipients,\n    uint256[] calldata ids\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/token-shop/TokenShop.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./interfaces/ITokenShop.sol\";\nimport \"./interfaces/IPurchaseHook.sol\";\nimport \"prepo-shared-contracts/contracts/Pausable.sol\";\nimport \"prepo-shared-contracts/contracts/WithdrawERC20.sol\";\nimport \"prepo-shared-contracts/contracts/WithdrawERC721.sol\";\nimport \"prepo-shared-contracts/contracts/WithdrawERC1155.sol\";\n\ncontract TokenShop is\n  ITokenShop,\n  Pausable,\n  WithdrawERC20,\n  WithdrawERC721,\n  WithdrawERC1155\n{\n  using SafeERC20 for IERC20;\n\n  IERC20 private _paymentToken;\n  IPurchaseHook private _purchaseHook;\n  mapping(address => mapping(uint256 => uint256)) private _contractToIdToPrice;\n  mapping(address => mapping(address => uint256))\n    private _userToERC721ToPurchaseCount;\n  mapping(address => mapping(address => mapping(uint256 => uint256)))\n    private _userToERC1155ToIdToPurchaseCount;\n\n  constructor(address _newPaymentToken) {\n    _paymentToken = IERC20(_newPaymentToken);\n  }\n\n  function setContractToIdToPrice(\n    address[] memory _tokenContracts,\n    uint256[] memory _ids,\n    uint256[] memory _prices\n  ) external override onlyOwner {\n    require(\n      _tokenContracts.length == _prices.length &&\n        _ids.length == _prices.length,\n      \"Array length mismatch\"\n    );\n    uint256 _arrayLength = _tokenContracts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      _contractToIdToPrice[_tokenContracts[i]][_ids[i]] = _prices[i];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setPurchaseHook(address _newPurchaseHook)\n    external\n    override\n    onlyOwner\n  {\n    _purchaseHook = IPurchaseHook(_newPurchaseHook);\n  }\n\n  function purchase(\n    address[] memory _tokenContracts,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    uint256[] memory _purchasePrices\n  ) external override nonReentrant whenNotPaused {\n    require(\n      _tokenContracts.length == _ids.length &&\n        _ids.length == _amounts.length &&\n        _amounts.length == _purchasePrices.length,\n      \"Array length mismatch\"\n    );\n    IPurchaseHook _hook = _purchaseHook;\n    require(address(_hook) != address(0), \"Purchase hook not set\");\n    uint256 _arrayLength = _tokenContracts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      uint256 _price = _contractToIdToPrice[_tokenContracts[i]][_ids[i]];\n      require(_price != 0, \"Non-purchasable item\");\n      require(_purchasePrices[i] >= _price, \"Purchase price < Price\");\n      uint256 _totalPaymentAmount = _price * _amounts[i];\n      _paymentToken.transferFrom(\n        _msgSender(),\n        address(this),\n        _totalPaymentAmount\n      );\n      bool _isERC1155 = IERC1155(_tokenContracts[i]).supportsInterface(\n        type(IERC1155).interfaceId\n      );\n      if (_isERC1155) {\n        _hook.hookERC1155(\n          msg.sender,\n          _tokenContracts[i],\n          _ids[i],\n          _amounts[i]\n        );\n        _userToERC1155ToIdToPurchaseCount[msg.sender][_tokenContracts[i]][\n          _ids[i]\n        ] += _amounts[i];\n        IERC1155(_tokenContracts[i]).safeTransferFrom(\n          address(this),\n          _msgSender(),\n          _ids[i],\n          _amounts[i],\n          \"\"\n        );\n      } else {\n        _hook.hookERC721(msg.sender, _tokenContracts[i], _ids[i]);\n        ++_userToERC721ToPurchaseCount[msg.sender][_tokenContracts[i]];\n        IERC721(_tokenContracts[i]).safeTransferFrom(\n          address(this),\n          _msgSender(),\n          _ids[i]\n        );\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function getPrice(address _tokenContract, uint256 _id)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _contractToIdToPrice[_tokenContract][_id];\n  }\n\n  function getPaymentToken() external view override returns (address) {\n    return address(_paymentToken);\n  }\n\n  function getPurchaseHook() external view override returns (IPurchaseHook) {\n    return _purchaseHook;\n  }\n\n  function getERC721PurchaseCount(address _user, address _tokenContract)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _userToERC721ToPurchaseCount[_user][_tokenContract];\n  }\n\n  function getERC1155PurchaseCount(\n    address _user,\n    address _tokenContract,\n    uint256 _id\n  ) external view override returns (uint256) {\n    return _userToERC1155ToIdToPurchaseCount[_user][_tokenContract][_id];\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external pure returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/token-shop/interfaces/ITokenShop.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./IPurchaseHook.sol\";\n\n/**\n * @notice Makes ERC721 and ERC1155 tokens avaiable for purchase in exchange\n * for a set payment token.\n */\ninterface ITokenShop {\n  /**\n   * @notice Sets prices for corresponding `ids` of each ERC721/1155 in\n   * `tokenContracts` from `prices`.\n   * @dev Only callable by `owner()`.\n   * @param tokenContracts ERC721/1155s to be listed\n   * @param ids Token IDs to be listed\n   * @param prices Price of each ERC721/1155 in payment token\n   */\n  function setContractToIdToPrice(\n    address[] memory tokenContracts,\n    uint256[] memory ids,\n    uint256[] memory prices\n  ) external;\n\n  /**\n   * @notice Sets the purchase hook to be called during a purchase.\n   * @dev Only callable by `owner()`.\n   * @param newPurchaseHook Address of the new purchase hook\n   */\n  function setPurchaseHook(address newPurchaseHook) external;\n\n  /**\n   * @notice Purchases corresponding `amounts` of `ids` of each ERC721/1155\n   * in `tokenContracts` for their listed price.\n   * @dev `amounts` entries for ERC721s can be left as 0 since they will be\n   * ignored.\n   * @param tokenContracts ERC721/1155s to be purchased\n   * @param ids Token IDs to be purchased\n   * @param amounts Amounts to be purchased\n   * @param purchasePrices Purchase price of each ERC721/1155 in payment token\n   */\n  function purchase(\n    address[] memory tokenContracts,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256[] memory purchasePrices\n  ) external;\n\n  /**\n   * @param tokenContract The ERC721/1155 contract\n   * @param id The ERC721/1155 token ID\n   * @return Price of `id` in `tokenContract` in payment token\n   */\n  function getPrice(address tokenContract, uint256 id)\n    external\n    view\n    returns (uint256);\n\n  /// @return ERC20 token that is accepted as payment\n  function getPaymentToken() external view returns (address);\n\n  /// @return The purchase hook contract\n  function getPurchaseHook() external view returns (IPurchaseHook);\n\n  /**\n   * @param user The address to retrieve data for\n   * @param tokenContract The ERC721 contract\n   * @return Amount of `tokenContract` tokens that `user` has purchased\n   */\n  function getERC721PurchaseCount(address user, address tokenContract)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @param user The address to retrieve data for\n   * @param tokenContract The ERC1155 contract\n   * @param id The ERC1155 token ID\n   * @return Amount of `id` of `tokenContract` that `user` has purchased\n   */\n  function getERC1155PurchaseCount(\n    address user,\n    address tokenContract,\n    uint256 id\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/token-shop/interfaces/IPurchaseHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./ITokenShop.sol\";\n\n/**\n * @notice Hook to be called when a user makes a `TokenShop` purchase.\n * @dev A different hook is called based on whether a buyer is purchasing a\n * ERC721 or ERC1155 token.\n */\ninterface IPurchaseHook {\n  /**\n   * @notice A hook called for each ERC721 token a user purchases.\n   * @dev Limits the amount of a certain token a user can purchase.\n   * @param user Address of buyer\n   * @param tokenContract ERC721 contract of the token to be bought\n   * @param tokenId ID of the token to be bought\n   */\n  function hookERC721(\n    address user,\n    address tokenContract,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @notice A hook called for each ERC1155 token a user purchases.\n   * @dev Limits the amount of a certain token a user can purchase.\n   * @param user Address of buyer\n   * @param tokenContract ERC1155 contract of the token to be bought\n   * @param tokenId Token ID to be bought\n   * @param amount Amount of token to be bought\n   */\n  function hookERC1155(\n    address user,\n    address tokenContract,\n    uint256 tokenId,\n    uint256 amount\n  ) external;\n\n  //TODO: move this into a sub-interface\n  /**\n   * @notice Sets the limit on purchases for each token, based on\n   * corresponding `amounts` of each ERC721 in `contracts`.\n   * @dev A limit of 0 allows users to buy unlimited amounts of a token.\n   * @param contracts ERC721s a purchase limit is to be set for\n   * @param amounts Purchase limits to be set\n   */\n  function setMaxERC721PurchasesPerUser(\n    address[] memory contracts,\n    uint256[] memory amounts\n  ) external;\n\n  /**\n   * @notice Sets the limit on purchases for each token, based on\n   * corresponding `amounts` of each ERC1155 in `contracts`.\n   * @dev A limit of 0 allows users to buy unlimited amounts of a token.\n   * @param contracts ERC1155s a purchase limit is to be set for\n   * @param ids Token IDs a purchase limit is to be set for\n   * @param amounts Purchase limits to be set\n   */\n  function setMaxERC1155PurchasesPerUser(\n    address[] memory contracts,\n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) external;\n\n  /**\n   * @notice Sets the TokenShop contract that will be allowed to call hooks.\n   * @param newTokenShop Address of the new TokenShop contract\n   */\n  function setTokenShop(address newTokenShop) external;\n\n  /**\n   * @param tokenContract The ERC721 contract\n   * @return Limit on the amount of `tokenContract` tokens a user can buy\n   */\n  function getMaxERC721PurchasesPerUser(address tokenContract)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @param tokenContract The ERC1155 contract\n   * @param id The ERC1155 token ID\n   * @return Limit on the amount of `id` of `tokenContract` a user can buy\n   */\n  function getMaxERC1155PurchasesPerUser(address tokenContract, uint256 id)\n    external\n    view\n    returns (uint256);\n\n  /// @return The TokenShop contract\n  function getTokenShop() external view returns (ITokenShop);\n}\n"
    },
    "prepo-shared-contracts/contracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./SafeOwnable.sol\";\nimport \"./interfaces/IPausable.sol\";\n\ncontract Pausable is IPausable, SafeOwnable {\n  bool private _paused;\n\n  modifier whenNotPaused() {\n    require(!_paused, \"Paused\");\n    _;\n  }\n\n  constructor() {}\n\n  function setPaused(bool _newPaused) external override onlyOwner {\n    _paused = _newPaused;\n    emit PausedChange(_newPaused);\n  }\n\n  function isPaused() external view override returns (bool) {\n    return _paused;\n  }\n}\n"
    },
    "prepo-shared-contracts/contracts/WithdrawERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IWithdrawERC20.sol\";\nimport \"./SafeOwnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract WithdrawERC20 is IWithdrawERC20, SafeOwnable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  constructor() {}\n\n  function withdrawERC20(\n    address[] calldata _erc20Tokens,\n    uint256[] calldata _amounts\n  ) external override onlyOwner nonReentrant {\n    require(_erc20Tokens.length == _amounts.length, \"Array length mismatch\");\n    address _owner = owner();\n    uint256 _arrayLength = _erc20Tokens.length;\n    for (uint256 i; i < _arrayLength; ) {\n      IERC20(_erc20Tokens[i]).safeTransfer(_owner, _amounts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function withdrawERC20(address[] calldata _erc20Tokens)\n    external\n    override\n    onlyOwner\n    nonReentrant\n  {\n    address _owner = owner();\n    uint256 _arrayLength = _erc20Tokens.length;\n    for (uint256 i; i < _arrayLength; ) {\n      IERC20(_erc20Tokens[i]).safeTransfer(\n        _owner,\n        IERC20(_erc20Tokens[i]).balanceOf(address(this))\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "prepo-shared-contracts/contracts/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice Allows a contract owner to pause their contract.\n * @dev Pausing a contract will only affect functions using the included\n * `whenNotPaused` modifier.\n */\ninterface IPausable {\n  /**\n   * @dev Emitted by `setPaused()`.\n   * @param newPaused Whether the contract was paused\n   */\n  event PausedChange(bool newPaused);\n\n  /**\n   * @notice Pauses or unpauses the contract.\n   * @dev Only callable by `owner()`.\n   * @param newPaused Whether the contract is to be paused\n   */\n  function setPaused(bool newPaused) external;\n\n  /// @return Whether the contract is currently paused\n  function isPaused() external view returns (bool);\n}\n"
    },
    "prepo-shared-contracts/contracts/interfaces/IWithdrawERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice Allows a contract owner to withdraw any ERC20 tokens residing\n * within the contract to themselves.\n */\ninterface IWithdrawERC20 {\n  /**\n   * @notice Withdraws corresponding `amounts` of each ERC20 in `erc20Tokens`.\n   * @dev Length of `erc20Tokens` and `amounts` must match.\n   *\n   * Only callable by `owner()`.\n   * @param erc20Tokens ERC20 tokens to be withdrawn\n   * @param amounts Amounts to be withdrawn\n   */\n  function withdrawERC20(\n    address[] calldata erc20Tokens,\n    uint256[] calldata amounts\n  ) external;\n\n  /**\n   * @notice Withdraws entire balance of each ERC20 in `erc20Tokens`.\n   * @dev Only callable by `owner()`.\n   * @param erc20Tokens ERC20 tokens to be withdrawn\n   */\n  function withdrawERC20(address[] calldata erc20Tokens) external;\n}\n"
    },
    "contracts/vesting/Vesting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IVesting.sol\";\nimport \"prepo-shared-contracts/contracts/Pausable.sol\";\nimport \"prepo-shared-contracts/contracts/WithdrawERC20.sol\";\n\ncontract Vesting is IVesting, Pausable, WithdrawERC20 {\n  using SafeERC20 for IERC20;\n\n  IERC20 private _token;\n  uint256 private _vestingStartTime;\n  uint256 private _vestingEndTime;\n\n  mapping(address => uint256) private _recipientToAllocatedAmount;\n  mapping(address => uint256) private _recipientToClaimedAmount;\n\n  uint256 private _totalAllocatedSupply;\n\n  constructor() {}\n\n  function setToken(address _newToken) external override onlyOwner {\n    _token = IERC20(_newToken);\n  }\n\n  function setVestingStartTime(uint256 _newVestingStartTime)\n    external\n    override\n    onlyOwner\n  {\n    require(\n      _newVestingStartTime < _vestingEndTime,\n      \"Vesting start time >= end time\"\n    );\n    _vestingStartTime = _newVestingStartTime;\n  }\n\n  function setVestingEndTime(uint256 _newVestingEndTime)\n    external\n    override\n    onlyOwner\n  {\n    require(\n      _newVestingEndTime > _vestingStartTime,\n      \"Vesting end time <= start time\"\n    );\n    _vestingEndTime = _newVestingEndTime;\n  }\n\n  function setAllocations(\n    address[] calldata _recipients,\n    uint256[] calldata _amounts\n  ) external override onlyOwner {\n    require(_recipients.length == _amounts.length, \"Array length mismatch\");\n    uint256 _newTotalAllocatedSupply = _totalAllocatedSupply;\n    uint256 _arrayLength = _recipients.length;\n    for (uint256 i; i < _arrayLength; ) {\n      uint256 _amount = _amounts[i];\n      address _recipient = _recipients[i];\n      uint256 _prevAllocatedAmount = _recipientToAllocatedAmount[_recipient];\n      /**\n       * If the new allocation amount is greater than _prevAllocatedAmount,\n       * the absolute difference is added to\n       * _newTotalAllocatedSupply, otherwise it is subtracted.\n       */\n      if (_amount > _prevAllocatedAmount) {\n        unchecked {\n          _newTotalAllocatedSupply += _amount - _prevAllocatedAmount;\n        }\n      } else {\n        unchecked {\n          _newTotalAllocatedSupply -= _prevAllocatedAmount - _amount;\n        }\n      }\n      _recipientToAllocatedAmount[_recipient] = _amount;\n      emit Allocation(_recipient, _amount);\n      unchecked {\n        ++i;\n      }\n    }\n\n    _totalAllocatedSupply = _newTotalAllocatedSupply;\n  }\n\n  function claim() external override nonReentrant whenNotPaused {\n    uint256 _claimableAmount = getClaimableAmount(msg.sender);\n    IERC20 _vestedToken = _token;\n    require(_claimableAmount != 0, \"Claimable amount = 0\");\n    require(\n      _vestedToken.balanceOf(address(this)) >= _claimableAmount,\n      \"Insufficient balance in contract\"\n    );\n    _recipientToClaimedAmount[msg.sender] += _claimableAmount;\n    _vestedToken.transfer(msg.sender, _claimableAmount);\n    emit Claim(msg.sender, _claimableAmount);\n  }\n\n  function getClaimableAmount(address _recipient)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    uint256 _vestedAmount = getVestedAmount(_recipient);\n    uint256 _claimedTillNow = _recipientToClaimedAmount[_recipient];\n    if (_vestedAmount > _claimedTillNow) {\n      return (_vestedAmount - _claimedTillNow);\n    } else {\n      return 0;\n    }\n  }\n\n  function getVestedAmount(address _recipient)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    uint256 _start = _vestingStartTime;\n    uint256 _end = _vestingEndTime;\n    uint256 _allocated = _recipientToAllocatedAmount[_recipient];\n    if (block.timestamp < _start) return 0;\n    uint256 _vested = (_allocated * (block.timestamp - _start)) /\n      (_end - _start);\n    return _vested < _allocated ? _vested : _allocated;\n  }\n\n  function getToken() external view override returns (address) {\n    return address(_token);\n  }\n\n  function getVestingStartTime() external view override returns (uint256) {\n    return _vestingStartTime;\n  }\n\n  function getVestingEndTime() external view override returns (uint256) {\n    return _vestingEndTime;\n  }\n\n  function getAmountAllocated(address _recipient)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _recipientToAllocatedAmount[_recipient];\n  }\n\n  function getTotalAllocatedSupply() external view override returns (uint256) {\n    return _totalAllocatedSupply;\n  }\n\n  function getClaimedAmount(address _recipient)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _recipientToClaimedAmount[_recipient];\n  }\n}\n"
    },
    "contracts/vesting/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * @notice Allows tokens to be claimed according to a vesting schedule\n * shared by all designated recipients.\n */\ninterface IVesting {\n  /// @dev Emitted via `setAllocations()`.\n  /// @param recipient Address of the recipient of tokens\n  /// @param amount Amount of tokens allocated to recipient\n  event Allocation(address recipient, uint256 amount);\n\n  /// @dev Emitted via `claim()`.\n  /// @param recipient Address of the recipient of tokens\n  /// @param amount Amount of tokens claimed by recipient\n  event Claim(address recipient, uint256 amount);\n\n  /**\n   * @dev Only callable by `owner()`.\n   * @param newToken Address of the ERC20 token to be vested\n   */\n  function setToken(address newToken) external;\n\n  /**\n   * @dev Only callable by `owner()`.\n   * @param newVestingStartTime Unix timestamp for when the vesting starts\n   */\n  function setVestingStartTime(uint256 newVestingStartTime) external;\n\n  /**\n   * @dev Only callable by `owner()`.\n   * @param newVestingEndTime Unix timestamp for when the vesting ends\n   */\n  function setVestingEndTime(uint256 newVestingEndTime) external;\n\n  /**\n   * @notice Sets/Adjusts allocation amount of ERC20 tokens\n   * to be vested for each user.\n   * @dev Only callable by `owner()`.\n   * @param recipients List of recipient addresses\n   * @param amounts Respective amount of tokens allocated to each recipient\n   */\n  function setAllocations(\n    address[] calldata recipients,\n    uint256[] calldata amounts\n  ) external;\n\n  /**\n   * @notice Transfers vested amount of tokens to the caller.\n   * @dev Only claimable when not paused.\n   * @dev Claimable amount will be 0 if the vested amount is less than the\n   * total claimed amount. This is possible if the recipient's allocation was\n   * adjusted to be lower.\n   */\n  function claim() external;\n\n  /**\n   * @return Address of the vested tokens\n   */\n  function getToken() external view returns (address);\n\n  /**\n   * @return Unix timestamp for when the vesting starts\n   */\n  function getVestingStartTime() external view returns (uint256);\n\n  /**\n   * @return Unix timestamp for when the vesting ends\n   */\n  function getVestingEndTime() external view returns (uint256);\n\n  /**\n   * @param recipient Address of the recipient of tokens\n   * @return Amount of tokens allocated to recipient\n   */\n  function getAmountAllocated(address recipient)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @return Total amount of tokens allocated to all recipients\n   */\n  function getTotalAllocatedSupply() external view returns (uint256);\n\n  /**\n   * @param recipient Address of the recipient of tokens\n   * @return Total amount that has been claimed by the recipient till now\n   */\n  function getClaimedAmount(address recipient) external view returns (uint256);\n\n  /**\n   * @param recipient Address of the recipient of tokens\n   * @return Amount that can be claimed by the recipient\n   */\n  function getClaimableAmount(address recipient)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @param recipient Address of the recipient of tokens\n   * @return Amount of tokens vested till now for the recipient\n   */\n  function getVestedAmount(address recipient) external view returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/MockPlatformIntegration.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.7;\n\n// Internal\nimport {IPlatformIntegration} from \"../../interfaces/IPlatformIntegration.sol\";\nimport {ImmutableModule} from \"../../shared/ImmutableModule.sol\";\nimport {IAaveATokenV2, IAaveLendingPoolV2, ILendingPoolAddressesProviderV2} from \"../../peripheral/Aave/IAave.sol\";\n\n// Libs\nimport {MassetHelpers} from \"../../shared/MassetHelpers.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPlatformIntegration is IPlatformIntegration, ImmutableModule {\n  using SafeERC20 for IERC20;\n\n  event PTokenAdded(address indexed _bAsset, address _pToken);\n  event Whitelisted(address indexed _address);\n\n  event Deposit(address indexed _bAsset, address _pToken, uint256 _amount);\n  event Withdrawal(address indexed _bAsset, address _pToken, uint256 _amount);\n  event PlatformWithdrawal(\n    address indexed bAsset,\n    address pToken,\n    uint256 totalAmount,\n    uint256 userAmount\n  );\n\n  // Core address for the given platform */\n  address public platformAddress;\n\n  // bAsset => pToken (Platform Specific Token Address)\n  mapping(address => address) public bAssetToPToken;\n  // Full list of all bAssets supported here\n  address[] internal bAssetsMapped;\n\n  mapping(address => bool) public whitelist;\n\n  /**\n   * @dev Modifier to allow function calls only from the whitelisted address.\n   */\n  modifier onlyWhitelisted() {\n    require(whitelist[msg.sender], \"Not a whitelisted address\");\n    _;\n  }\n\n  constructor(\n    address _nexus,\n    address _platformAddress,\n    address[] memory _bAssets,\n    address[] memory _pTokens\n  ) ImmutableModule(_nexus) {\n    platformAddress = _platformAddress;\n\n    uint256 bAssetCount = _bAssets.length;\n    require(bAssetCount == _pTokens.length, \"Invalid input arrays\");\n    for (uint256 i = 0; i < bAssetCount; i++) {\n      _setPTokenAddress(_bAssets[i], _pTokens[i]);\n    }\n  }\n\n  function addWhitelist(address[] memory _whitelisted) external {\n    require(_whitelisted.length > 0, \"Empty whitelist array\");\n\n    for (uint256 i = 0; i < _whitelisted.length; i++) {\n      _addWhitelist(_whitelisted[i]);\n    }\n  }\n\n  /**\n   * @dev Adds a new whitelist address\n   * @param _address Address to add in whitelist\n   */\n  function _addWhitelist(address _address) internal {\n    require(_address != address(0), \"Address is zero\");\n    require(!whitelist[_address], \"Already whitelisted\");\n\n    whitelist[_address] = true;\n\n    emit Whitelisted(_address);\n  }\n\n  /***************************************\n                    CONFIG\n    ****************************************/\n\n  /**\n   * @dev Provide support for bAsset by passing its pToken address.\n   * This method can only be called by the system Governor\n   * @param _bAsset   Address for the bAsset\n   * @param _pToken   Address for the corresponding platform token\n   */\n  function setPTokenAddress(address _bAsset, address _pToken)\n    external\n    onlyGovernor\n  {\n    _setPTokenAddress(_bAsset, _pToken);\n  }\n\n  function _setPTokenAddress(address _bAsset, address _pToken) internal {\n    require(bAssetToPToken[_bAsset] == address(0), \"pToken already set\");\n    require(\n      _bAsset != address(0) && _pToken != address(0),\n      \"Invalid addresses\"\n    );\n\n    bAssetToPToken[_bAsset] = _pToken;\n    bAssetsMapped.push(_bAsset);\n\n    emit PTokenAdded(_bAsset, _pToken);\n\n    _abstractSetPToken(_bAsset, _pToken);\n  }\n\n  /***************************************\n                    CORE\n    ****************************************/\n\n  /**\n   * @dev Deposit a quantity of bAsset into the platform. Credited aTokens\n   *      remain here in the vault. Can only be called by whitelisted addresses\n   *      (mAsset and corresponding BasketManager)\n   * @param _bAsset              Address for the bAsset\n   * @param _amount              Units of bAsset to deposit\n   * @param _hasTxFee            Is the bAsset known to have a tx fee?\n   * @return quantityDeposited   Quantity of bAsset that entered the platform\n   */\n  function deposit(\n    address _bAsset,\n    uint256 _amount,\n    bool _hasTxFee\n  ) external override onlyWhitelisted returns (uint256 quantityDeposited) {\n    require(_amount > 0, \"Must deposit something\");\n\n    IAaveATokenV2 aToken = _getATokenFor(_bAsset);\n\n    quantityDeposited = _amount;\n\n    if (_hasTxFee) {\n      // If we charge a fee, account for it\n      uint256 prevBal = _checkBalance(aToken);\n      _getLendingPool().deposit(_bAsset, _amount, address(this), 36);\n      uint256 newBal = _checkBalance(aToken);\n      quantityDeposited = _min(quantityDeposited, newBal - prevBal);\n    } else {\n      _getLendingPool().deposit(_bAsset, _amount, address(this), 36);\n    }\n\n    emit Deposit(_bAsset, address(aToken), quantityDeposited);\n  }\n\n  /**\n   * @dev Withdraw a quantity of bAsset from the platform\n   * @param _receiver     Address to which the bAsset should be sent\n   * @param _bAsset       Address of the bAsset\n   * @param _amount       Units of bAsset to withdraw\n   * @param _hasTxFee     Is the bAsset known to have a tx fee?\n   */\n  function withdraw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount,\n    bool _hasTxFee\n  ) external override onlyWhitelisted {\n    _withdraw(_receiver, _bAsset, _amount, _amount, _hasTxFee);\n  }\n\n  /**\n   * @dev Withdraw a quantity of bAsset from the platform\n   * @param _receiver     Address to which the bAsset should be sent\n   * @param _bAsset       Address of the bAsset\n   * @param _amount       Units of bAsset to send to recipient\n   * @param _totalAmount  Total units to pull from lending platform\n   * @param _hasTxFee     Is the bAsset known to have a tx fee?\n   */\n  function withdraw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount,\n    uint256 _totalAmount,\n    bool _hasTxFee\n  ) external override onlyWhitelisted {\n    _withdraw(_receiver, _bAsset, _amount, _totalAmount, _hasTxFee);\n  }\n\n  /** @dev Withdraws _totalAmount from the lending pool, sending _amount to user */\n  function _withdraw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount,\n    uint256 _totalAmount,\n    bool _hasTxFee\n  ) internal {\n    require(_totalAmount > 0, \"Must withdraw something\");\n\n    IAaveATokenV2 aToken = _getATokenFor(_bAsset);\n\n    if (_hasTxFee) {\n      require(_amount == _totalAmount, \"Cache inactive for assets with fee\");\n      _getLendingPool().withdraw(_bAsset, _amount, _receiver);\n    } else {\n      _getLendingPool().withdraw(_bAsset, _totalAmount, address(this));\n      // Send redeemed bAsset to the receiver\n      IERC20(_bAsset).safeTransfer(_receiver, _amount);\n    }\n\n    emit PlatformWithdrawal(_bAsset, address(aToken), _totalAmount, _amount);\n  }\n\n  /**\n   * @dev Withdraw a quantity of bAsset from the cache.\n   * @param _receiver     Address to which the bAsset should be sent\n   * @param _bAsset       Address of the bAsset\n   * @param _amount       Units of bAsset to withdraw\n   */\n  function withdrawRaw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount\n  ) external override onlyWhitelisted {\n    require(_amount > 0, \"Must withdraw something\");\n    require(_receiver != address(0), \"Must specify recipient\");\n\n    // Send redeemed bAsset to the receiver\n    IERC20(_bAsset).safeTransfer(_receiver, _amount);\n\n    emit Withdrawal(_bAsset, address(0), _amount);\n  }\n\n  /**\n   * @dev Get the total bAsset value held in the platform\n   *      This includes any interest that was generated since depositing\n   *      Aave gradually increases the balances of all aToken holders, as the interest grows\n   * @param _bAsset     Address of the bAsset\n   * @return balance    Total value of the bAsset in the platform\n   */\n  function checkBalance(address _bAsset)\n    external\n    view\n    override\n    returns (uint256 balance)\n  {\n    // balance is always with token aToken decimals\n    IAaveATokenV2 aToken = _getATokenFor(_bAsset);\n    return _checkBalance(aToken);\n  }\n\n  /***************************************\n                    APPROVALS\n    ****************************************/\n\n  /**\n   * @dev Re-approve the spending of all bAssets by the Aave lending pool core,\n   *      if for some reason is it necessary for example if the address of core changes.\n   *      Only callable through Governance.\n   */\n  function reApproveAllTokens() external onlyGovernor {\n    uint256 bAssetCount = bAssetsMapped.length;\n    address lendingPoolVault = address(_getLendingPool());\n    // approve the pool to spend the bAsset\n    for (uint256 i = 0; i < bAssetCount; i++) {\n      MassetHelpers.safeInfiniteApprove(bAssetsMapped[i], lendingPoolVault);\n    }\n  }\n\n  /**\n   * @dev Internal method to respond to the addition of new bAsset / pTokens\n   *      We need to approve the Aave lending pool core conrtact and give it permission\n   *      to spend the bAsset\n   * @param _bAsset Address of the bAsset to approve\n   */\n  function _abstractSetPToken(\n    address _bAsset,\n    address /*_pToken*/\n  ) internal {\n    address lendingPool = address(_getLendingPool());\n    // approve the pool to spend the bAsset\n    MassetHelpers.safeInfiniteApprove(_bAsset, lendingPool);\n  }\n\n  /***************************************\n                    HELPERS\n    ****************************************/\n\n  /**\n   * @dev Get the current address of the Aave lending pool, which is the gateway to\n   *      depositing.\n   * @return Current lending pool implementation\n   */\n  function _getLendingPool() internal view returns (IAaveLendingPoolV2) {\n    address lendingPool = ILendingPoolAddressesProviderV2(platformAddress)\n      .getLendingPool();\n    require(lendingPool != address(0), \"Lending pool does not exist\");\n    return IAaveLendingPoolV2(lendingPool);\n  }\n\n  /**\n   * @dev Get the pToken wrapped in the IAaveAToken interface for this bAsset, to use\n   *      for withdrawing or balance checking. Fails if the pToken doesn't exist in our mappings.\n   * @param _bAsset  Address of the bAsset\n   * @return aToken  Corresponding to this bAsset\n   */\n  function _getATokenFor(address _bAsset)\n    internal\n    view\n    returns (IAaveATokenV2)\n  {\n    address aToken = bAssetToPToken[_bAsset];\n    require(aToken != address(0), \"aToken does not exist\");\n    return IAaveATokenV2(aToken);\n  }\n\n  /**\n   * @dev Get the total bAsset value held in the platform\n   * @param _aToken     aToken for which to check balance\n   * @return balance    Total value of the bAsset in the platform\n   */\n  function _checkBalance(IAaveATokenV2 _aToken)\n    internal\n    view\n    returns (uint256 balance)\n  {\n    return _aToken.balanceOf(address(this));\n  }\n\n  /***************************************\n                    HELPERS\n    ****************************************/\n\n  /**\n   * @dev Simple helper func to get the min of two values\n   */\n  function _min(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x > y ? y : x;\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IPlatformIntegration.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IPlatformIntegration {\n  /**\n   * @dev Deposit the given bAsset to Lending platform\n   * @param _bAsset bAsset address\n   * @param _amount Amount to deposit\n   */\n  function deposit(\n    address _bAsset,\n    uint256 _amount,\n    bool isTokenFeeCharged\n  ) external returns (uint256 quantityDeposited);\n\n  /**\n   * @dev Withdraw given bAsset from Lending platform\n   */\n  function withdraw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount,\n    bool _hasTxFee\n  ) external;\n\n  /**\n   * @dev Withdraw given bAsset from Lending platform\n   */\n  function withdraw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount,\n    uint256 _totalAmount,\n    bool _hasTxFee\n  ) external;\n\n  /**\n   * @dev Withdraw given bAsset from the cache\n   */\n  function withdrawRaw(\n    address _receiver,\n    address _bAsset,\n    uint256 _amount\n  ) external;\n\n  /**\n   * @dev Returns the current balance of the given bAsset\n   */\n  function checkBalance(address _bAsset) external returns (uint256 balance);\n}\n"
    },
    "contracts/ppo-staking/shared/ImmutableModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ModuleKeys} from \"./ModuleKeys.sol\";\nimport {INexus} from \"../interfaces/INexus.sol\";\n\n/**\n * @title   ImmutableModule\n * @author  mStable\n * @dev     Subscribes to module updates from a given publisher and reads from its registry.\n *          Contract is used for upgradable proxy contracts.\n */\nabstract contract ImmutableModule is ModuleKeys {\n  INexus public immutable nexus;\n\n  /**\n   * @dev Initialization function for upgradable proxy contracts\n   * @param _nexus Nexus contract address\n   */\n  constructor(address _nexus) {\n    require(_nexus != address(0), \"Nexus address is zero\");\n    nexus = INexus(_nexus);\n  }\n\n  /**\n   * @dev Modifier to allow function calls only from the Governor.\n   */\n  modifier onlyGovernor() {\n    _onlyGovernor();\n    _;\n  }\n\n  function _onlyGovernor() internal view {\n    require(msg.sender == _governor(), \"Only governor can execute\");\n  }\n\n  /**\n   * @dev Modifier to allow function calls only from the Governor or the Keeper EOA.\n   */\n  modifier onlyKeeperOrGovernor() {\n    _keeperOrGovernor();\n    _;\n  }\n\n  function _keeperOrGovernor() internal view {\n    require(\n      msg.sender == _keeper() || msg.sender == _governor(),\n      \"Only keeper or governor\"\n    );\n  }\n\n  /**\n   * @dev Modifier to allow function calls only from the Governance.\n   *      Governance is either Governor address or Governance address.\n   */\n  modifier onlyGovernance() {\n    require(\n      msg.sender == _governor() || msg.sender == _governance(),\n      \"Only governance can execute\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Returns Governor address from the Nexus\n   * @return Address of Governor Contract\n   */\n  function _governor() internal view returns (address) {\n    return nexus.governor();\n  }\n\n  /**\n   * @dev Returns Governance Module address from the Nexus\n   * @return Address of the Governance (Phase 2)\n   */\n  function _governance() internal view returns (address) {\n    return nexus.getModule(KEY_GOVERNANCE);\n  }\n\n  /**\n   * @dev Return Keeper address from the Nexus.\n   *      This account is used for operational transactions that\n   *      don't need multiple signatures.\n   * @return  Address of the Keeper externally owned account.\n   */\n  function _keeper() internal view returns (address) {\n    return nexus.getModule(KEY_KEEPER);\n  }\n\n  /**\n   * @dev Return SavingsManager Module address from the Nexus\n   * @return Address of the SavingsManager Module contract\n   */\n  function _savingsManager() internal view returns (address) {\n    return nexus.getModule(KEY_SAVINGS_MANAGER);\n  }\n\n  /**\n   * @dev Return Recollateraliser Module address from the Nexus\n   * @return  Address of the Recollateraliser Module contract (Phase 2)\n   */\n  function _recollateraliser() internal view returns (address) {\n    return nexus.getModule(KEY_RECOLLATERALISER);\n  }\n\n  /**\n   * @dev Return Liquidator Module address from the Nexus\n   * @return  Address of the Liquidator Module contract\n   */\n  function _liquidator() internal view returns (address) {\n    return nexus.getModule(KEY_LIQUIDATOR);\n  }\n\n  /**\n   * @dev Return ProxyAdmin Module address from the Nexus\n   * @return Address of the ProxyAdmin Module contract\n   */\n  function _proxyAdmin() internal view returns (address) {\n    return nexus.getModule(KEY_PROXY_ADMIN);\n  }\n}\n"
    },
    "contracts/ppo-staking/peripheral/Aave/IAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\n */\ninterface ILendingPoolAddressesProviderV2 {\n  /**\n   * @notice Get the current address for Aave LendingPool\n   * @dev Lending pool is the core contract on which to call deposit\n   */\n  function getLendingPool() external view returns (address);\n}\n\n/**\n * @dev Interface for Aaves A Token\n * Documentation: https://developers.aave.com/#atokens\n */\ninterface IAaveATokenV2 {\n  /**\n   * @notice returns the current total aToken balance of _user all interest collected included.\n   * To obtain the user asset principal balance with interests excluded , ERC20 non-standard\n   * method principalBalanceOf() can be used.\n   */\n  function balanceOf(address _user) external view returns (uint256);\n}\n\ninterface IAaveLendingPoolV2 {\n  /**\n   * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\n   * is minted.\n   * @param reserve the address of the reserve\n   * @param amount the amount to be deposited\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n   **/\n  function deposit(\n    address reserve,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev withdraws the assets of user.\n   * @param reserve the address of the reserve\n   * @param amount the underlying amount to be redeemed\n   * @param to address that will receive the underlying\n   **/\n  function withdraw(\n    address reserve,\n    uint256 amount,\n    address to\n  ) external;\n}\n\n/** Interface for Staking AAVE Token\n * Documentation: https://docs.aave.com/developers/protocol-governance/staking-aave\n */\ninterface IStakedAave {\n  function COOLDOWN_SECONDS() external returns (uint256);\n\n  function UNSTAKE_WINDOW() external returns (uint256);\n\n  function stake(address to, uint256 amount) external;\n\n  function redeem(address to, uint256 amount) external;\n\n  function cooldown() external;\n\n  function claimRewards(address to, uint256 amount) external;\n\n  function stakersCooldowns(address staker) external returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/shared/MassetHelpers.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title   MassetHelpers\n * @author  mStable\n * @notice  Helper functions to facilitate minting and redemption from off chain\n * @dev     VERSION: 1.0\n *          DATE:    2020-03-28\n */\nlibrary MassetHelpers {\n  using SafeERC20 for IERC20;\n\n  function transferReturnBalance(\n    address _sender,\n    address _recipient,\n    address _bAsset,\n    uint256 _qty\n  ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\n    uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\n    IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\n    recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\n    receivedQty = recipientBalance - balBefore;\n  }\n\n  function safeInfiniteApprove(address _asset, address _spender) internal {\n    IERC20(_asset).safeApprove(_spender, 0);\n    IERC20(_asset).safeApprove(_spender, 2**256 - 1);\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/ModuleKeys.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title  ModuleKeys\n * @author mStable\n * @notice Provides system wide access to the byte32 represntations of system modules\n *         This allows each system module to be able to reference and update one another in a\n *         friendly way\n * @dev    keccak256() values are hardcoded to avoid re-evaluation of the constants at runtime.\n */\ncontract ModuleKeys {\n  // Governance\n  // ===========\n  // keccak256(\"Governance\");\n  bytes32 internal constant KEY_GOVERNANCE =\n    0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\n  //keccak256(\"Staking\");\n  bytes32 internal constant KEY_STAKING =\n    0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\n  //keccak256(\"ProxyAdmin\");\n  bytes32 internal constant KEY_PROXY_ADMIN =\n    0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\n\n  // mStable\n  // =======\n  // keccak256(\"OracleHub\");\n  bytes32 internal constant KEY_ORACLE_HUB =\n    0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\n  // keccak256(\"Manager\");\n  bytes32 internal constant KEY_MANAGER =\n    0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\n  //keccak256(\"Recollateraliser\");\n  bytes32 internal constant KEY_RECOLLATERALISER =\n    0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\n  //keccak256(\"MetaToken\");\n  bytes32 internal constant KEY_META_TOKEN =\n    0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\n  // keccak256(\"SavingsManager\");\n  bytes32 internal constant KEY_SAVINGS_MANAGER =\n    0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\n  // keccak256(\"Liquidator\");\n  bytes32 internal constant KEY_LIQUIDATOR =\n    0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\n  // keccak256(\"InterestValidator\");\n  bytes32 internal constant KEY_INTEREST_VALIDATOR =\n    0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\n  // keccak256(\"Keeper\");\n  bytes32 internal constant KEY_KEEPER =\n    0x4f78afe9dfc9a0cb0441c27b9405070cd2a48b490636a7bdd09f355e33a5d7de;\n}\n"
    },
    "contracts/ppo-staking/interfaces/INexus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title INexus\n * @dev Basic interface for interacting with the Nexus i.e. SystemKernel\n */\ninterface INexus {\n  function governor() external view returns (address);\n\n  function getModule(bytes32 key) external view returns (address);\n\n  function proposeModule(bytes32 _key, address _addr) external;\n\n  function cancelProposedModule(bytes32 _key) external;\n\n  function acceptProposedModule(bytes32 _key) external;\n\n  function acceptProposedModules(bytes32[] calldata _keys) external;\n\n  function requestLockModule(bytes32 _key) external;\n\n  function cancelLockModule(bytes32 _key) external;\n\n  function lockModule(bytes32 _key) external;\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/MockPlatformIntegrationWithToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {MassetHelpers} from \"../../shared/MassetHelpers.sol\";\nimport {MockPlatformIntegration} from \"./MockPlatformIntegration.sol\";\n\n// Overrides approveRewardToken\ncontract MockPlatformIntegrationWithToken is MockPlatformIntegration {\n  event RewardTokenApproved(address token, address spender);\n\n  address rewardToken;\n\n  constructor(\n    address _nexus,\n    address _platformAddress,\n    address[] memory _bAssets,\n    address[] memory _pTokens\n  ) MockPlatformIntegration(_nexus, _platformAddress, _bAssets, _pTokens) {}\n\n  // @override\n  function approveRewardToken() external {\n    address liquidator = nexus.getModule(keccak256(\"Liquidator\"));\n    require(liquidator != address(0), \"Liquidator address cannot be zero\");\n\n    MassetHelpers.safeInfiniteApprove(rewardToken, liquidator);\n\n    emit RewardTokenApproved(rewardToken, liquidator);\n  }\n\n  function setRewardToken(address _token) external {\n    rewardToken = _token;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/MockRewardToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {MassetHelpers} from \"../../shared/MassetHelpers.sol\";\nimport {ImmutableModule} from \"../../shared/ImmutableModule.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Overrides approveRewardToken\ncontract MockRewardToken is ImmutableModule {\n  event RewardTokenApproved(address token, address spender);\n\n  address rewardToken;\n  uint256 rewardAmount = 1000;\n\n  constructor(address _nexus) ImmutableModule(_nexus) {}\n\n  // @override\n  function approveRewardToken() external {\n    address liquidator = nexus.getModule(keccak256(\"Liquidator\"));\n    require(liquidator != address(0), \"Liquidator address cannot be zero\");\n\n    MassetHelpers.safeInfiniteApprove(rewardToken, liquidator);\n\n    emit RewardTokenApproved(rewardToken, liquidator);\n  }\n\n  function setRewardToken(address _token) external {\n    rewardToken = _token;\n  }\n\n  function setRewardAmount(uint256 _rewardAmount) external {\n    rewardAmount = _rewardAmount;\n  }\n\n  /// @dev this assumes some reward tokens have been transferred to this contract\n  function claimRewards() external {\n    IERC20(rewardToken).transfer(msg.sender, rewardAmount);\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockERC20WithFee.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {StableMath} from \"../../shared/StableMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20WithFee is IERC20 {\n  using StableMath for uint256;\n\n  uint256 public feeRate;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  event FeePaid(address indexed sender, uint256 amount);\n\n  /**\n   * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n   * these values are immutable: they can only be set once during\n   * construction.\n   */\n  function _initialize(\n    string memory nameArg,\n    string memory symbolArg,\n    uint8 decimalsArg\n  ) internal {\n    _name = nameArg;\n    _symbol = symbolArg;\n    _decimals = decimalsArg;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei.\n   *\n   * > Note that this information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * `IERC20.balanceOf` and `IERC20.transfer`.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See `IERC20.totalSupply`.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See `IERC20.balanceOf`.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See `IERC20.transfer`.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount)\n    public\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See `IERC20.allowance`.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See `IERC20.approve`.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 value)\n    public\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev See `IERC20.transferFrom`.\n   *\n   * Emits an `Approval` event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of `ERC20`;\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `value`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in `IERC20.approve`.\n   *\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender] + addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in `IERC20.approve`.\n   *\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender] - subtractedValue\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to `transfer`, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    uint256 fee = amount.mulTruncate(feeRate);\n    uint256 remainder = amount - fee;\n\n    _burn(sender, fee);\n\n    _balances[sender] = _balances[sender] - remainder;\n    _balances[recipient] = _balances[recipient] + remainder;\n    emit Transfer(sender, recipient, remainder);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a `Transfer` event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _totalSupply = _totalSupply + amount;\n    _balances[account] = _balances[account] + amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destoys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a `Transfer` event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 value) internal {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _totalSupply = _totalSupply - value;\n    _balances[account] = _balances[account] - value;\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) internal {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  /**\n   * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n   * from the caller's allowance.\n   *\n   * See `_burn` and `_approve`.\n   */\n  function _burnFrom(address account, uint256 amount) internal {\n    _burn(account, amount);\n    _approve(account, msg.sender, _allowances[account][msg.sender] - amount);\n  }\n\n  /**\n   * @dev See `ERC20._mint`.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MinterRole`.\n   */\n  function mint(address account, uint256 amount) public returns (bool) {\n    _mint(account, amount);\n    return true;\n  }\n}\n\ncontract MockERC20WithFee is ERC20WithFee {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) {\n    ERC20WithFee._initialize(_name, _symbol, _decimals);\n    feeRate = 1e15;\n    _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/StableMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title   StableMath\n * @author  mStable\n * @notice  A library providing safe mathematical operations to multiply and\n *          divide with standardised precision.\n * @dev     Derives from OpenZeppelin's SafeMath lib and uses generic system\n *          wide variables for managing precision.\n */\nlibrary StableMath {\n  /**\n   * @dev Scaling unit for use in specific calculations,\n   * where 1 * 10**18, or 1e18 represents a unit '1'\n   */\n  uint256 private constant FULL_SCALE = 1e18;\n\n  /**\n   * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\n   * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\n   * bAsset ratio unit for use in exact calculations,\n   * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\n   */\n  uint256 private constant RATIO_SCALE = 1e8;\n\n  /**\n   * @dev Provides an interface to the scaling unit\n   * @return Scaling unit (1e18 or 1 * 10**18)\n   */\n  function getFullScale() internal pure returns (uint256) {\n    return FULL_SCALE;\n  }\n\n  /**\n   * @dev Provides an interface to the ratio unit\n   * @return Ratio scale unit (1e8 or 1 * 10**8)\n   */\n  function getRatioScale() internal pure returns (uint256) {\n    return RATIO_SCALE;\n  }\n\n  /**\n   * @dev Scales a given integer to the power of the full scale.\n   * @param x   Simple uint256 to scale\n   * @return    Scaled value a to an exact number\n   */\n  function scaleInteger(uint256 x) internal pure returns (uint256) {\n    return x * FULL_SCALE;\n  }\n\n  /***************************************\n              PRECISE ARITHMETIC\n    ****************************************/\n\n  /**\n   * @dev Multiplies two precise units, and then truncates by the full scale\n   * @param x     Left hand input to multiplication\n   * @param y     Right hand input to multiplication\n   * @return      Result after multiplying the two inputs and then dividing by the shared\n   *              scale unit\n   */\n  function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n    return mulTruncateScale(x, y, FULL_SCALE);\n  }\n\n  /**\n   * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n   * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n   * @param x     Left hand input to multiplication\n   * @param y     Right hand input to multiplication\n   * @param scale Scale unit\n   * @return      Result after multiplying the two inputs and then dividing by the shared\n   *              scale unit\n   */\n  function mulTruncateScale(\n    uint256 x,\n    uint256 y,\n    uint256 scale\n  ) internal pure returns (uint256) {\n    // e.g. assume scale = fullScale\n    // z = 10e18 * 9e17 = 9e36\n    // return 9e36 / 1e18 = 9e18\n    return (x * y) / scale;\n  }\n\n  /**\n   * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n   * @param x     Left hand input to multiplication\n   * @param y     Right hand input to multiplication\n   * @return      Result after multiplying the two inputs and then dividing by the shared\n   *              scale unit, rounded up to the closest base unit.\n   */\n  function mulTruncateCeil(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    // e.g. 8e17 * 17268172638 = 138145381104e17\n    uint256 scaled = x * y;\n    // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n    uint256 ceil = scaled + FULL_SCALE - 1;\n    // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n    return ceil / FULL_SCALE;\n  }\n\n  /**\n   * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n   *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n   * @param x     Left hand input to division\n   * @param y     Right hand input to division\n   * @return      Result after multiplying the left operand by the scale, and\n   *              executing the division on the right hand input.\n   */\n  function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\n    // e.g. 8e18 * 1e18 = 8e36\n    // e.g. 8e36 / 10e18 = 8e17\n    return (x * FULL_SCALE) / y;\n  }\n\n  /***************************************\n                  RATIO FUNCS\n    ****************************************/\n\n  /**\n   * @dev Multiplies and truncates a token ratio, essentially flooring the result\n   *      i.e. How much mAsset is this bAsset worth?\n   * @param x     Left hand operand to multiplication (i.e Exact quantity)\n   * @param ratio bAsset ratio\n   * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\n   */\n  function mulRatioTruncate(uint256 x, uint256 ratio)\n    internal\n    pure\n    returns (uint256 c)\n  {\n    return mulTruncateScale(x, ratio, RATIO_SCALE);\n  }\n\n  /**\n   * @dev Multiplies and truncates a token ratio, rounding up the result\n   *      i.e. How much mAsset is this bAsset worth?\n   * @param x     Left hand input to multiplication (i.e Exact quantity)\n   * @param ratio bAsset ratio\n   * @return      Result after multiplying the two inputs and then dividing by the shared\n   *              ratio scale, rounded up to the closest base unit.\n   */\n  function mulRatioTruncateCeil(uint256 x, uint256 ratio)\n    internal\n    pure\n    returns (uint256)\n  {\n    // e.g. How much mAsset should I burn for this bAsset (x)?\n    // 1e18 * 1e8 = 1e26\n    uint256 scaled = x * ratio;\n    // 1e26 + 9.99e7 = 100..00.999e8\n    uint256 ceil = scaled + RATIO_SCALE - 1;\n    // return 100..00.999e8 / 1e8 = 1e18\n    return ceil / RATIO_SCALE;\n  }\n\n  /**\n   * @dev Precisely divides two ratioed units, by first scaling the left hand operand\n   *      i.e. How much bAsset is this mAsset worth?\n   * @param x     Left hand operand in division\n   * @param ratio bAsset ratio\n   * @return c    Result after multiplying the left operand by the scale, and\n   *              executing the division on the right hand input.\n   */\n  function divRatioPrecisely(uint256 x, uint256 ratio)\n    internal\n    pure\n    returns (uint256 c)\n  {\n    // e.g. 1e14 * 1e8 = 1e22\n    // return 1e22 / 1e12 = 1e10\n    return (x * RATIO_SCALE) / ratio;\n  }\n\n  /***************************************\n                    HELPERS\n    ****************************************/\n\n  /**\n   * @dev Calculates minimum of two numbers\n   * @param x     Left hand input\n   * @param y     Right hand input\n   * @return      Minimum of the two inputs\n   */\n  function min(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x > y ? y : x;\n  }\n\n  /**\n   * @dev Calculated maximum of two numbers\n   * @param x     Left hand input\n   * @param y     Right hand input\n   * @return      Maximum of the two inputs\n   */\n  function max(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x > y ? x : y;\n  }\n\n  /**\n   * @dev Clamps a value to an upper bound\n   * @param x           Left hand input\n   * @param upperBound  Maximum possible value to return\n   * @return            Input x clamped to a maximum value, upperBound\n   */\n  function clamp(uint256 x, uint256 upperBound)\n    internal\n    pure\n    returns (uint256)\n  {\n    return x > upperBound ? upperBound : x;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockInitializableTokenWithFee.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ERC20WithFee} from \"./MockERC20WithFee.sol\";\n\n/**\n * @title  InitializableToken\n * @author mStable\n * @dev    Basic ERC20Detailed Token functionality for Masset\n */\ncontract MockInitializableTokenWithFee is ERC20WithFee {\n  /**\n   * @dev Initialization function for implementing contract\n   * @notice To avoid variable shadowing appended `Arg` after arguments name.\n   */\n  function initialize(\n    string calldata _nameArg,\n    string calldata _symbolArg,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) external {\n    ERC20WithFee._initialize(_nameArg, _symbolArg, _decimals);\n    feeRate = 1e15;\n    _mint(_initialRecipient, _initialMint * 10**uint256(_decimals));\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/PublicStableMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {StableMath} from \"../../shared/StableMath.sol\";\n\ncontract PublicStableMath {\n  using StableMath for uint256;\n\n  function getFullScale() external pure returns (uint256) {\n    return StableMath.getFullScale();\n  }\n\n  function getRatioScale() external pure returns (uint256) {\n    return StableMath.getRatioScale();\n  }\n\n  function scaleInteger(uint256 x) external pure returns (uint256) {\n    return x.scaleInteger();\n  }\n\n  function mulTruncateScale(\n    uint256 x,\n    uint256 y,\n    uint256 scale\n  ) external pure returns (uint256) {\n    return x.mulTruncateScale(y, scale);\n  }\n\n  function mulTruncate(uint256 x, uint256 y) external pure returns (uint256) {\n    return x.mulTruncate(y);\n  }\n\n  function mulTruncateCeil(uint256 x, uint256 y)\n    external\n    pure\n    returns (uint256)\n  {\n    return x.mulTruncateCeil(y);\n  }\n\n  function divPrecisely(uint256 x, uint256 y) external pure returns (uint256) {\n    return x.divPrecisely(y);\n  }\n\n  function mulRatioTruncate(uint256 x, uint256 ratio)\n    external\n    pure\n    returns (uint256)\n  {\n    return x.mulRatioTruncate(ratio);\n  }\n\n  function mulRatioTruncateCeil(uint256 x, uint256 ratio)\n    external\n    pure\n    returns (uint256)\n  {\n    return x.mulRatioTruncateCeil(ratio);\n  }\n\n  function divRatioPrecisely(uint256 x, uint256 ratio)\n    external\n    pure\n    returns (uint256)\n  {\n    return x.divRatioPrecisely(ratio);\n  }\n\n  function min(uint256 x, uint256 y) external pure returns (uint256) {\n    return x.min(y);\n  }\n\n  function max(uint256 x, uint256 y) external pure returns (uint256) {\n    return x.max(y);\n  }\n\n  function clamp(uint256 x, uint256 upperBound)\n    external\n    pure\n    returns (uint256)\n  {\n    return x.clamp(upperBound);\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/savings/MockSavingsContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {StableMath} from \"../../shared/StableMath.sol\";\n\n/**\n * @title   MockSavingsContract\n * @author  mStable\n * @notice  Mock of contracts/savings/SavingsContract.sol  // ISavingsContractV3\n *          DATE:    2022-01-12\n */\ncontract MockSavingsContract is ERC20 {\n  using StableMath for uint256;\n\n  uint8 dec;\n  uint256 private constant startingRate = 1e17;\n  uint256 public exchangeRate;\n\n  // Underlying asset is underlying\n  IERC20 public immutable underlying;\n\n  event CreditsRedeemed(\n    address indexed redeemer,\n    uint256 creditsRedeemed,\n    uint256 savingsCredited\n  );\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint,\n    address _underlying\n  ) ERC20(_name, _symbol) {\n    dec = _decimals;\n    _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));\n    underlying = IERC20(_underlying);\n    exchangeRate = startingRate;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return dec;\n  }\n\n  /**\n   * @dev Internally burn the credits and optionally send the underlying to msg.sender\n   */\n  function _redeem(\n    uint256 _amt,\n    bool _isCreditAmt,\n    bool _transferUnderlying\n  ) internal returns (uint256 creditsBurned, uint256 massetReturned) {\n    // Centralise credit <> underlying calcs and minimise SLOAD count\n    uint256 credits_;\n    uint256 underlying_;\n    uint256 exchangeRate_;\n    // If the input is a credit amt, then calculate underlying payout and cache the exchangeRate\n    if (_isCreditAmt) {\n      credits_ = _amt;\n      (underlying_, exchangeRate_) = _creditsToUnderlying(_amt);\n    }\n    // If the input is in underlying, then calculate credits needed to burn\n    else {\n      underlying_ = _amt;\n      (credits_, exchangeRate_) = _underlyingToCredits(_amt);\n    }\n\n    // Burn required credits from the sender FIRST\n    _burn(msg.sender, credits_);\n\n    // Optionally, transfer tokens from here to sender\n    if (_transferUnderlying) {\n      require(\n        underlying.transfer(msg.sender, underlying_),\n        \"Must send tokens\"\n      );\n    }\n    // Cache and poke removed\n\n    emit CreditsRedeemed(msg.sender, credits_, underlying_);\n\n    return (credits_, underlying_);\n  }\n\n  function redeemAndUnwrap(\n    uint256 _amount,\n    bool _isCreditAmt,\n    uint256 _minAmountOut,\n    address _output,\n    address _beneficiary,\n    address _router,\n    bool\n  )\n    external\n    returns (\n      uint256 creditsBurned,\n      uint256 massetRedeemed,\n      uint256 outputQuantity\n    )\n  {\n    require(_amount > 0, \"Must withdraw something\");\n    require(_minAmountOut >= 0, \"Must withdraw something\");\n    require(_output != address(0), \"Output address is zero\");\n    require(_beneficiary != address(0), \"Beneficiary address is zero\");\n    require(_router != address(0), \"Router address is zero\");\n\n    // Collect recent interest generated by basket and update exchange rate - removed for simplicity\n\n    // Ensure that the payout was sufficient\n    (creditsBurned, massetRedeemed) = _redeem(_amount, _isCreditAmt, false);\n    require(\n      _isCreditAmt ? creditsBurned == _amount : massetRedeemed == _amount,\n      \"Invalid output\"\n    );\n\n    // Approve wrapper to spend contract's underlying; just for this tx\n    // underlying.approve(unwrapper, massetRedeemed);\n    // Unwrap the underlying into `output` and transfer to `beneficiary`\n    // IUnwrapper(unwrapper).unwrapAndSend()\n  }\n\n  /**\n   * @dev Converts masset amount into credits based on exchange rate\n   *               c = (masset / exchangeRate) + 1\n   */\n  function _underlyingToCredits(uint256 _underlying)\n    internal\n    view\n    returns (uint256 credits, uint256 exchangeRate_)\n  {\n    // e.g. (1e20 * 1e18) / 1e18 = 1e20\n    // e.g. (1e20 * 1e18) / 14e17 = 7.1429e19\n    // e.g. 1 * 1e18 / 1e17 + 1 = 11 => 11 * 1e17 / 1e18 = 1.1e18 / 1e18 = 1\n    exchangeRate_ = exchangeRate;\n    credits = _underlying.divPrecisely(exchangeRate_) + 1;\n  }\n\n  /**\n   * @dev Converts credit amount into masset based on exchange rate\n   *               m = credits * exchangeRate\n   */\n  function _creditsToUnderlying(uint256 _credits)\n    internal\n    view\n    returns (uint256 underlyingAmount, uint256 exchangeRate_)\n  {\n    // e.g. (1e20 * 1e18) / 1e18 = 1e20\n    // e.g. (1e20 * 14e17) / 1e18 = 1.4e20\n    exchangeRate_ = exchangeRate;\n    underlyingAmount = _credits.mulTruncate(exchangeRate_);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/pregenesis/PregenesisPoints.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IPregenesisPoints.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract PregenesisPoints is\n  IPregenesisPoints,\n  SafeOwnable,\n  ReentrancyGuard,\n  ERC20\n{\n  address private _shop;\n  bytes32 private _root;\n  mapping(address => bool) private _userToClaim;\n\n  constructor(string memory _name, string memory _symbol)\n    ERC20(_name, _symbol)\n  {}\n\n  function setShop(address _newShop) external override onlyOwner {\n    _shop = _newShop;\n  }\n\n  function setMerkleTreeRoot(bytes32 _newRoot) external override onlyOwner {\n    _root = _newRoot;\n  }\n\n  function mint(address _to, uint256 _amount) external override onlyOwner {\n    _mint(_to, _amount);\n  }\n\n  function burn(address _account, uint256 _amount)\n    external\n    override\n    onlyOwner\n  {\n    _burn(_account, _amount);\n  }\n\n  function claim(uint256 _amount, bytes32[] memory _proof)\n    external\n    override\n    nonReentrant\n  {\n    require(!_userToClaim[_msgSender()], \"Already claimed\");\n    bytes32 _leaf = keccak256(abi.encodePacked(_msgSender(), _amount));\n    bool _verified = MerkleProof.verify(_proof, _root, _leaf);\n    require(_verified, \"Invalid claim\");\n    _userToClaim[_msgSender()] = true;\n    _mint(_msgSender(), _amount);\n  }\n\n  function getShop() external view override returns (address) {\n    return _shop;\n  }\n\n  function getMerkleTreeRoot() external view override returns (bytes32) {\n    return _root;\n  }\n\n  function hasClaimed(address _account) external view override returns (bool) {\n    return _userToClaim[_account];\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal override {\n    if (_from == address(0) && _msgSender() != owner()) {\n      require(_userToClaim[_msgSender()], \"Unauthorized mint\");\n    } else {\n      require(\n        _msgSender() == owner() || _msgSender() == _shop,\n        \"Unauthorized transfer\"\n      );\n    }\n    super._beforeTokenTransfer(_from, _to, _amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/pregenesis/interfaces/IPregenesisPoints.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n//TODO: add all natspecs at the end\ninterface IPregenesisPoints {\n  function setShop(address newShop) external;\n\n  function setMerkleTreeRoot(bytes32 newRoot) external;\n\n  function mint(address to, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n\n  function claim(uint256 amount, bytes32[] memory proof) external;\n\n  function getShop() external view returns (address);\n\n  function getMerkleTreeRoot() external view returns (bytes32);\n\n  function hasClaimed(address account) external view returns (bool);\n}\n"
    },
    "contracts/ppo-staking/rewards/staking/StakingRewardsDistribution.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../interfaces/IStakingRewardsDistribution.sol\";\nimport \"../../governance/staking/interfaces/IPPOStaking.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract StakingRewardsDistribution is\n  IStakingRewardsDistribution,\n  SafeOwnable,\n  ReentrancyGuard\n{\n  IPPOStaking private _ppoStaking;\n  bytes32 private _root;\n  mapping(uint256 => bool) private _userPeriodHashToClaimed;\n  uint256 _periodNumber;\n\n  function setPPOStaking(address _newPPOStaking) external override onlyOwner {\n    _ppoStaking = IPPOStaking(_newPPOStaking);\n  }\n\n  function setMerkleTreeRoot(bytes32 _newRoot) external override onlyOwner {\n    _root = _newRoot;\n    emit RootUpdate(_newRoot, ++_periodNumber);\n  }\n\n  function claim(\n    address _account,\n    uint256 _amount,\n    bytes32[] memory _proof\n  ) external override nonReentrant {\n    require(\n      !_userPeriodHashToClaimed[_getUserPeriodHash(_account)],\n      \"Already claimed\"\n    );\n    bytes32 _leaf = keccak256(abi.encodePacked(_account, _amount));\n    bool _verified = MerkleProof.verify(_proof, _root, _leaf);\n    require(_verified, \"Invalid claim\");\n    _userPeriodHashToClaimed[_getUserPeriodHash(_account)] = true;\n    _ppoStaking.stake(_account, _amount);\n    emit RewardClaim(_account, _amount, _periodNumber);\n  }\n\n  function getPPOStaking() external view override returns (address) {\n    return address(_ppoStaking);\n  }\n\n  function getMerkleTreeRoot() external view override returns (bytes32) {\n    return _root;\n  }\n\n  function getPeriodNumber() external view override returns (uint256) {\n    return _periodNumber;\n  }\n\n  function hasClaimed(address _user) external view override returns (bool) {\n    return _userPeriodHashToClaimed[_getUserPeriodHash(_user)];\n  }\n\n  function _getUserPeriodHash(address _user) private view returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(_user, _periodNumber)));\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IStakingRewardsDistribution.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IStakingRewardsDistribution {\n  event RewardClaim(\n    address indexed user,\n    uint256 amount,\n    uint256 periodNumber\n  );\n  event RootUpdate(bytes32 indexed newRoot, uint256 newPeriodNumber);\n\n  function setPPOStaking(address newPPOStaking) external;\n\n  function setMerkleTreeRoot(bytes32 newRoot) external;\n\n  function claim(\n    address account,\n    uint256 amount,\n    bytes32[] memory proof\n  ) external;\n\n  function getPPOStaking() external view returns (address);\n\n  function getMerkleTreeRoot() external view returns (bytes32);\n\n  function getPeriodNumber() external view returns (uint256);\n\n  function hasClaimed(address user) external view returns (bool);\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/IPPOStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\ninterface IPPOStaking {\n  function stake(address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/ppo-staking/z_mocks/savings/connectors/MockConnector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IConnector} from \"../../../savings/peripheral/IConnector.sol\";\n\ncontract MockConnector is IConnector {\n  address save;\n  address mUSD;\n  uint256 deposited;\n\n  constructor(address _save, address _mUSD) {\n    save = _save;\n    mUSD = _mUSD;\n  }\n\n  modifier onlySave() {\n    require(save == msg.sender, \"Only SAVE can call this\");\n    _;\n  }\n\n  function deposit(uint256 _amount) external override onlySave {\n    IERC20(mUSD).transferFrom(save, address(this), _amount);\n    deposited += _amount;\n  }\n\n  function withdraw(uint256 _amount) external override onlySave {\n    IERC20(mUSD).transfer(save, _amount);\n    deposited -= _amount;\n  }\n\n  function withdrawAll() external override onlySave {\n    IERC20(mUSD).transfer(save, deposited);\n    deposited = 0;\n  }\n\n  function checkBalance() external view override returns (uint256) {\n    return deposited;\n  }\n}\n"
    },
    "contracts/ppo-staking/savings/peripheral/IConnector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IConnector {\n  /**\n   * @notice Deposits the mAsset into the connector\n   * @param _amount Units of mAsset to receive and deposit\n   */\n  function deposit(uint256 _amount) external;\n\n  /**\n   * @notice Withdraws a specific amount of mAsset from the connector\n   * @param _amount Units of mAsset to withdraw\n   */\n  function withdraw(uint256 _amount) external;\n\n  /**\n   * @notice Withdraws all mAsset from the connector\n   */\n  function withdrawAll() external;\n\n  /**\n   * @notice Returns the available balance in the connector. In connections\n   * where there is likely to be an initial dip in value due to conservative\n   * exchange rates (e.g. with Curves `get_virtual_price`), it should return\n   * max(deposited, balance) to avoid temporary negative yield. Any negative yield\n   * should be corrected during a withdrawal or over time.\n   * @return Balance of mAsset in the connector\n   */\n  function checkBalance() external view returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/savings/SavingsContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n// External\nimport {ISavingsManager} from \"../interfaces/ISavingsManager.sol\";\n\n// Internal\nimport {ISavingsContractV3} from \"../interfaces/ISavingsContract.sol\";\nimport {IUnwrapper} from \"../interfaces/IUnwrapper.sol\";\nimport {InitializableToken} from \"../shared/InitializableToken.sol\";\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {IConnector} from \"./peripheral/IConnector.sol\";\nimport {Initializable} from \"../shared/@openzeppelin-2.5/Initializable.sol\";\n\n// Libs\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {StableMath} from \"../shared/StableMath.sol\";\nimport {YieldValidator} from \"../shared/YieldValidator.sol\";\n\n/**\n * @title   SavingsContract\n * @author  mStable\n * @notice  Savings contract uses the ever increasing \"exchangeRate\" to increase\n *          the value of the Savers \"credits\" (ERC20) relative to the amount of additional\n *          underlying collateral that has been deposited into this contract (\"interest\")\n * @dev     VERSION: 2.1\n *          DATE:    2021-11-25\n */\ncontract SavingsContract is\n  ISavingsContractV3,\n  Initializable,\n  InitializableToken,\n  ImmutableModule\n{\n  using StableMath for uint256;\n\n  // Core events for depositing and withdrawing\n  event ExchangeRateUpdated(\n    uint256 newExchangeRate,\n    uint256 interestCollected\n  );\n  event SavingsDeposited(\n    address indexed saver,\n    uint256 savingsDeposited,\n    uint256 creditsIssued\n  );\n  event CreditsRedeemed(\n    address indexed redeemer,\n    uint256 creditsRedeemed,\n    uint256 savingsCredited\n  );\n\n  event AutomaticInterestCollectionSwitched(bool automationEnabled);\n\n  // Connector poking\n  event PokerUpdated(address poker);\n\n  event FractionUpdated(uint256 fraction);\n  event ConnectorUpdated(address connector);\n  event EmergencyUpdate();\n\n  event Poked(\n    uint256 oldBalance,\n    uint256 newBalance,\n    uint256 interestDetected\n  );\n  event PokedRaw();\n\n  // Tracking events\n  event Referral(\n    address indexed referrer,\n    address beneficiary,\n    uint256 amount\n  );\n\n  // Rate between 'savings credits' and underlying\n  // e.g. 1 credit (1e17) mulTruncate(exchangeRate) = underlying, starts at 10:1\n  // exchangeRate increases over time\n  uint256 private constant startingRate = 1e17;\n  uint256 public override exchangeRate;\n\n  // Underlying asset is underlying\n  IERC20 public immutable override underlying;\n  bool private automateInterestCollection;\n\n  // Yield\n  // Poker is responsible for depositing/withdrawing from connector\n  address public poker;\n  // Last time a poke was made\n  uint256 public lastPoke;\n  // Last known balance of the connector\n  uint256 public lastBalance;\n  // Fraction of capital assigned to the connector (100% = 1e18)\n  uint256 public fraction;\n  // Address of the current connector (all IConnectors are mStable validated)\n  IConnector public connector;\n  // How often do we allow pokes\n  uint256 private constant POKE_CADENCE = 4 hours;\n  // Max APY generated on the capital in the connector\n  uint256 private constant MAX_APY = 4e18;\n  uint256 private constant SECONDS_IN_YEAR = 365 days;\n  // Proxy contract for easy redemption\n  address public immutable unwrapper;\n\n  constructor(\n    address _nexus,\n    address _underlying,\n    address _unwrapper\n  ) ImmutableModule(_nexus) {\n    require(_underlying != address(0), \"mAsset address is zero\");\n    require(_unwrapper != address(0), \"Unwrapper address is zero\");\n    underlying = IERC20(_underlying);\n    unwrapper = _unwrapper;\n  }\n\n  // Add these constants to bytecode at deploytime\n  function initialize(\n    address _poker,\n    string calldata _nameArg,\n    string calldata _symbolArg\n  ) external initializer {\n    InitializableToken._initialize(_nameArg, _symbolArg);\n\n    require(_poker != address(0), \"Invalid poker address\");\n    poker = _poker;\n\n    fraction = 2e17;\n    automateInterestCollection = true;\n    exchangeRate = startingRate;\n  }\n\n  /** @dev Only the savings managaer (pulled from Nexus) can execute this */\n  modifier onlySavingsManager() {\n    require(\n      msg.sender == _savingsManager(),\n      \"Only savings manager can execute\"\n    );\n    _;\n  }\n\n  /***************************************\n                    VIEW - E\n    ****************************************/\n\n  /**\n   * @notice Returns the underlying balance of a given user\n   * @param _user     Address of the user to check\n   * @return balance  Units of underlying owned by the user. eg mUSD or mBTC\n   */\n  function balanceOfUnderlying(address _user)\n    external\n    view\n    override\n    returns (uint256 balance)\n  {\n    (balance, ) = _creditsToUnderlying(balanceOf(_user));\n  }\n\n  /**\n   * @notice Converts a given underlying amount into credits. eg mUSD to imUSD.\n   * @param _underlying  Units of underlying. eg mUSD or mBTC.\n   * @return credits     Units of crefit. eg imUSD or imBTC\n   */\n  function underlyingToCredits(uint256 _underlying)\n    external\n    view\n    override\n    returns (uint256 credits)\n  {\n    (credits, ) = _underlyingToCredits(_underlying);\n  }\n\n  /**\n   * @notice Converts a given credit amount into underlying. eg imUSD to mUSD\n   * @param _credits  Units of credits. eg imUSD or imBTC\n   * @return amount   Units of underlying. eg mUSD or mBTC.\n   */\n  function creditsToUnderlying(uint256 _credits)\n    external\n    view\n    override\n    returns (uint256 amount)\n  {\n    (amount, ) = _creditsToUnderlying(_credits);\n  }\n\n  // Deprecated in favour of `balanceOf(address)`\n  // Maintained for backwards compatibility\n  // Returns the credit balance of a given user\n  function creditBalances(address _user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return balanceOf(_user);\n  }\n\n  /***************************************\n                    INTEREST\n    ****************************************/\n\n  /**\n   * @notice Deposit interest (add to savings) and update exchange rate of contract.\n   *      Exchange rate is calculated as the ratio between new savings q and credits:\n   *                    exchange rate = savings / credits\n   *\n   * @param _amount   Units of underlying to add to the savings vault\n   */\n  function depositInterest(uint256 _amount)\n    external\n    override\n    onlySavingsManager\n  {\n    require(_amount > 0, \"Must deposit something\");\n\n    // Transfer the interest from sender to here\n    require(\n      underlying.transferFrom(msg.sender, address(this), _amount),\n      \"Must receive tokens\"\n    );\n\n    // Calc new exchange rate, protect against initialisation case\n    uint256 totalCredits = totalSupply();\n    if (totalCredits > 0) {\n      // new exchange rate is relationship between _totalCredits & totalSavings\n      // _totalCredits * exchangeRate = totalSavings\n      // exchangeRate = totalSavings/_totalCredits\n      (uint256 totalCollat, ) = _creditsToUnderlying(totalCredits);\n      uint256 newExchangeRate = _calcExchangeRate(\n        totalCollat + _amount,\n        totalCredits\n      );\n      exchangeRate = newExchangeRate;\n\n      emit ExchangeRateUpdated(newExchangeRate, _amount);\n    }\n  }\n\n  /** @notice Enable or disable the automation of fee collection during deposit process */\n  function automateInterestCollectionFlag(bool _enabled)\n    external\n    onlyGovernor\n  {\n    automateInterestCollection = _enabled;\n    emit AutomaticInterestCollectionSwitched(_enabled);\n  }\n\n  /***************************************\n                    DEPOSIT\n    ****************************************/\n\n  /**\n   * @notice During a migration period, allow savers to deposit underlying here before the interest has been redirected\n   * @param _underlying      Units of underlying to deposit into savings vault\n   * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\n   * @return creditsIssued   Units of credits (imUSD) issued\n   */\n  function preDeposit(uint256 _underlying, address _beneficiary)\n    external\n    returns (uint256 creditsIssued)\n  {\n    require(\n      exchangeRate == startingRate,\n      \"Can only use this method before streaming begins\"\n    );\n    return _deposit(_underlying, _beneficiary, false);\n  }\n\n  /**\n   * @notice Deposit the senders savings to the vault, and credit them internally with \"credits\".\n   *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\n   *                    credits = underlying / exchangeRate\n   *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\n   * @param _underlying      Units of underlying to deposit into savings vault. eg mUSD or mBTC\n   * @return creditsIssued   Units of credits issued. eg imUSD or imBTC\n   */\n  function depositSavings(uint256 _underlying)\n    external\n    override\n    returns (uint256 creditsIssued)\n  {\n    return _deposit(_underlying, msg.sender, true);\n  }\n\n  /**\n   * @notice Deposit the senders savings to the vault, and credit them internally with \"credits\".\n   *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\n   *                    credits = underlying / exchangeRate\n   *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\n   * @param _underlying      Units of underlying to deposit into savings vault. eg mUSD or mBTC\n   * @param _beneficiary     Address to the new credits will be issued to.\n   * @return creditsIssued   Units of credits issued. eg imUSD or imBTC\n   */\n  function depositSavings(uint256 _underlying, address _beneficiary)\n    external\n    override\n    returns (uint256 creditsIssued)\n  {\n    return _deposit(_underlying, _beneficiary, true);\n  }\n\n  /**\n   * @notice Overloaded `depositSavings` method with an optional referrer address.\n   * @param _underlying      Units of underlying to deposit into savings vault. eg mUSD or mBTC\n   * @param _beneficiary     Address to the new credits will be issued to.\n   * @param _referrer        Referrer address for this deposit.\n   * @return creditsIssued   Units of credits issued. eg imUSD or imBTC\n   */\n  function depositSavings(\n    uint256 _underlying,\n    address _beneficiary,\n    address _referrer\n  ) external override returns (uint256 creditsIssued) {\n    emit Referral(_referrer, _beneficiary, _underlying);\n    return _deposit(_underlying, _beneficiary, true);\n  }\n\n  /**\n   * @dev Internally deposit the _underlying from the sender and credit the beneficiary with new imUSD\n   */\n  function _deposit(\n    uint256 _underlying,\n    address _beneficiary,\n    bool _collectInterest\n  ) internal returns (uint256 creditsIssued) {\n    require(_underlying > 0, \"Must deposit something\");\n    require(_beneficiary != address(0), \"Invalid beneficiary address\");\n\n    // Collect recent interest generated by basket and update exchange rate\n    IERC20 mAsset = underlying;\n    if (_collectInterest) {\n      ISavingsManager(_savingsManager()).collectAndDistributeInterest(\n        address(mAsset)\n      );\n    }\n\n    // Transfer tokens from sender to here\n    require(\n      mAsset.transferFrom(msg.sender, address(this), _underlying),\n      \"Must receive tokens\"\n    );\n\n    // Calc how many credits they receive based on currentRatio\n    (creditsIssued, ) = _underlyingToCredits(_underlying);\n\n    // add credits to ERC20 balances\n    _mint(_beneficiary, creditsIssued);\n\n    emit SavingsDeposited(_beneficiary, _underlying, creditsIssued);\n  }\n\n  /***************************************\n                    REDEEM\n    ****************************************/\n\n  /** @dev Deprecated in favour of redeemCredits.\n   * Maintaining backwards compatibility, this fn minimics the old redeem fn, in which\n   * credits are redeemed but the interest from the underlying is not collected.\n   */\n  function redeem(uint256 _credits)\n    external\n    override\n    returns (uint256 massetReturned)\n  {\n    require(_credits > 0, \"Must withdraw something\");\n\n    (, uint256 payout) = _redeem(_credits, true, true);\n\n    // Collect recent interest generated by basket and update exchange rate\n    if (automateInterestCollection) {\n      ISavingsManager(_savingsManager()).collectAndDistributeInterest(\n        address(underlying)\n      );\n    }\n\n    return payout;\n  }\n\n  /**\n   * @notice Redeem specific number of the senders \"credits\" in exchange for underlying.\n   *      Payout amount is calculated as a ratio of credits and exchange rate:\n   *                    payout = credits * exchangeRate\n   * @param _credits         Amount of credits to redeem\n   * @return massetReturned  Units of underlying mAsset paid out\n   */\n  function redeemCredits(uint256 _credits)\n    external\n    override\n    returns (uint256 massetReturned)\n  {\n    require(_credits > 0, \"Must withdraw something\");\n\n    // Collect recent interest generated by basket and update exchange rate\n    if (automateInterestCollection) {\n      ISavingsManager(_savingsManager()).collectAndDistributeInterest(\n        address(underlying)\n      );\n    }\n\n    (, uint256 payout) = _redeem(_credits, true, true);\n\n    return payout;\n  }\n\n  /**\n   * @notice Redeem credits into a specific amount of underlying.\n   *      Credits needed to burn is calculated using:\n   *                    credits = underlying / exchangeRate\n   * @param _underlying     Amount of underlying to redeem\n   * @return creditsBurned  Units of credits burned from sender\n   */\n  function redeemUnderlying(uint256 _underlying)\n    external\n    override\n    returns (uint256 creditsBurned)\n  {\n    require(_underlying > 0, \"Must withdraw something\");\n\n    // Collect recent interest generated by basket and update exchange rate\n    if (automateInterestCollection) {\n      ISavingsManager(_savingsManager()).collectAndDistributeInterest(\n        address(underlying)\n      );\n    }\n\n    // Ensure that the payout was sufficient\n    (uint256 credits, uint256 massetReturned) = _redeem(\n      _underlying,\n      false,\n      true\n    );\n    require(massetReturned == _underlying, \"Invalid output\");\n\n    return credits;\n  }\n\n  /**\n     * @notice Redeem credits into a specific amount of underlying, unwrap\n     *      into a selected output asset, and send to a beneficiary\n     *      Credits needed to burn is calculated using:\n     *                    credits = underlying / exchangeRate\n     * @param _amount         Units to redeem (either underlying or credit amount).\n     * @param _isCreditAmt    `true` if `amount` is in credits. eg imUSD. `false` if `amount` is in underlying. eg mUSD.\n     * @param _minAmountOut   Minimum amount of `output` tokens to unwrap for. This is to the same decimal places as the `output` token.\n     * @param _output         Asset to receive in exchange for the redeemed mAssets. This can be a bAsset or a fAsset. For example:\n        - bAssets (USDC, DAI, sUSD or USDT) or fAssets (GUSD, BUSD, alUSD, FEI or RAI) for mainnet imUSD Vault.\n        - bAssets (USDC, DAI or USDT) or fAsset FRAX for Polygon imUSD Vault.\n        - bAssets (WBTC, sBTC or renBTC) or fAssets (HBTC or TBTCV2) for mainnet imBTC Vault.\n     * @param _beneficiary    Address to send `output` tokens to.\n     * @param _router         mAsset address if the output is a bAsset. Feeder Pool address if the output is a fAsset.\n     * @param _isBassetOut    `true` if `output` is a bAsset. `false` if `output` is a fAsset.\n     * @return creditsBurned  Units of credits burned from sender. eg imUSD or imBTC.\n     * @return massetReturned Units of the underlying mAssets that were redeemed or swapped for the output tokens. eg mUSD or mBTC.\n     * @return outputQuantity Units of `output` tokens sent to the beneficiary.\n     */\n  function redeemAndUnwrap(\n    uint256 _amount,\n    bool _isCreditAmt,\n    uint256 _minAmountOut,\n    address _output,\n    address _beneficiary,\n    address _router,\n    bool _isBassetOut\n  )\n    external\n    override\n    returns (\n      uint256 creditsBurned,\n      uint256 massetReturned,\n      uint256 outputQuantity\n    )\n  {\n    require(_amount > 0, \"Must withdraw something\");\n    require(_output != address(0), \"Output address is zero\");\n    require(_beneficiary != address(0), \"Beneficiary address is zero\");\n    require(_router != address(0), \"Router address is zero\");\n\n    // Collect recent interest generated by basket and update exchange rate\n    if (automateInterestCollection) {\n      ISavingsManager(_savingsManager()).collectAndDistributeInterest(\n        address(underlying)\n      );\n    }\n\n    // Ensure that the payout was sufficient\n    (creditsBurned, massetReturned) = _redeem(_amount, _isCreditAmt, false);\n    require(\n      _isCreditAmt ? creditsBurned == _amount : massetReturned == _amount,\n      \"Invalid output\"\n    );\n\n    // Approve wrapper to spend contract's underlying; just for this tx\n    underlying.approve(unwrapper, massetReturned);\n\n    // Unwrap the underlying into `output` and transfer to `beneficiary`\n    outputQuantity = IUnwrapper(unwrapper).unwrapAndSend(\n      _isBassetOut,\n      _router,\n      address(underlying),\n      _output,\n      massetReturned,\n      _minAmountOut,\n      _beneficiary\n    );\n  }\n\n  /**\n   * @dev Internally burn the credits and optionally send the underlying to msg.sender\n   */\n  function _redeem(\n    uint256 _amt,\n    bool _isCreditAmt,\n    bool _transferUnderlying\n  ) internal returns (uint256 creditsBurned, uint256 massetReturned) {\n    // Centralise credit <> underlying calcs and minimise SLOAD count\n    uint256 credits_;\n    uint256 underlying_;\n    uint256 exchangeRate_;\n    // If the input is a credit amt, then calculate underlying payout and cache the exchangeRate\n    if (_isCreditAmt) {\n      credits_ = _amt;\n      (underlying_, exchangeRate_) = _creditsToUnderlying(_amt);\n    }\n    // If the input is in underlying, then calculate credits needed to burn\n    else {\n      underlying_ = _amt;\n      (credits_, exchangeRate_) = _underlyingToCredits(_amt);\n    }\n\n    // Burn required credits from the sender FIRST\n    _burn(msg.sender, credits_);\n\n    // Optionally, transfer tokens from here to sender\n    if (_transferUnderlying) {\n      require(\n        underlying.transfer(msg.sender, underlying_),\n        \"Must send tokens\"\n      );\n    }\n\n    // If this withdrawal pushes the portion of stored collateral in the `connector` over a certain\n    // threshold (fraction + 20%), then this should trigger a _poke on the connector. This is to avoid\n    // a situation in which there is a rush on withdrawals for some reason, causing the connector\n    // balance to go up and thus having too large an exposure.\n    CachedData memory cachedData = _cacheData();\n    ConnectorStatus memory status = _getConnectorStatus(\n      cachedData,\n      exchangeRate_\n    );\n    if (status.inConnector > status.limit) {\n      _poke(cachedData, false);\n    }\n\n    emit CreditsRedeemed(msg.sender, credits_, underlying_);\n\n    return (credits_, underlying_);\n  }\n\n  struct ConnectorStatus {\n    // Limit is the max amount of units allowed in the connector\n    uint256 limit;\n    // Derived balance of the connector\n    uint256 inConnector;\n  }\n\n  /**\n   * @dev Derives the units of collateral held in the connector\n   * @param _data         Struct containing data on balances\n   * @param _exchangeRate Current system exchange rate\n   * @return status       Contains max amount of assets allowed in connector\n   */\n  function _getConnectorStatus(CachedData memory _data, uint256 _exchangeRate)\n    internal\n    pure\n    returns (ConnectorStatus memory)\n  {\n    // Total units of underlying collateralised\n    uint256 totalCollat = _data.totalCredits.mulTruncate(_exchangeRate);\n    // Max amount of underlying that can be held in the connector\n    uint256 limit = totalCollat.mulTruncate(_data.fraction + 2e17);\n    // Derives amount of underlying present in the connector\n    uint256 inConnector = _data.rawBalance >= totalCollat\n      ? 0\n      : totalCollat - _data.rawBalance;\n\n    return ConnectorStatus(limit, inConnector);\n  }\n\n  /***************************************\n                    YIELD - E\n    ****************************************/\n\n  /** @dev Modifier allowing only the designated poker to execute the fn */\n  modifier onlyPoker() {\n    require(msg.sender == poker, \"Only poker can execute\");\n    _;\n  }\n\n  /**\n   * @notice External poke function allows for the redistribution of collateral between here and the\n   * current connector, setting the ratio back to the defined optimal.\n   */\n  function poke() external onlyPoker {\n    CachedData memory cachedData = _cacheData();\n    _poke(cachedData, false);\n  }\n\n  /**\n   * @notice Governance action to set the address of a new poker\n   * @param _newPoker     Address of the new poker\n   */\n  function setPoker(address _newPoker) external onlyGovernor {\n    require(_newPoker != address(0) && _newPoker != poker, \"Invalid poker\");\n\n    poker = _newPoker;\n\n    emit PokerUpdated(_newPoker);\n  }\n\n  /**\n   * @notice Governance action to set the percentage of assets that should be held\n   * in the connector.\n   * @param _fraction     Percentage of assets that should be held there (where 20% == 2e17)\n   */\n  function setFraction(uint256 _fraction) external onlyGovernor {\n    require(_fraction <= 5e17, \"Fraction must be <= 50%\");\n\n    fraction = _fraction;\n\n    CachedData memory cachedData = _cacheData();\n    _poke(cachedData, true);\n\n    emit FractionUpdated(_fraction);\n  }\n\n  /**\n   * @notice Governance action to set the address of a new connector, and move funds (if any) across.\n   * @param _newConnector     Address of the new connector\n   */\n  function setConnector(address _newConnector) external onlyGovernor {\n    // Withdraw all from previous by setting target = 0\n    CachedData memory cachedData = _cacheData();\n    cachedData.fraction = 0;\n    _poke(cachedData, true);\n\n    // Set new connector\n    CachedData memory cachedDataNew = _cacheData();\n    connector = IConnector(_newConnector);\n    _poke(cachedDataNew, true);\n\n    emit ConnectorUpdated(_newConnector);\n  }\n\n  /**\n   * @notice Governance action to perform an emergency withdraw of the assets in the connector,\n   * should it be the case that some or all of the liquidity is trapped in. This causes the total\n   * collateral in the system to go down, causing a hard refresh.\n   */\n  function emergencyWithdraw(uint256 _withdrawAmount) external onlyGovernor {\n    // withdraw _withdrawAmount from connection\n    connector.withdraw(_withdrawAmount);\n\n    // reset the connector\n    connector = IConnector(address(0));\n    emit ConnectorUpdated(address(0));\n\n    // set fraction to 0\n    fraction = 0;\n    emit FractionUpdated(0);\n\n    // check total collateralisation of credits\n    CachedData memory data = _cacheData();\n    // use rawBalance as the remaining liquidity in the connector is now written off\n    _refreshExchangeRate(data.rawBalance, data.totalCredits, true);\n\n    emit EmergencyUpdate();\n  }\n\n  /***************************************\n                    YIELD - I\n    ****************************************/\n\n  /** @dev Internal poke function to keep the balance between connector and raw balance healthy */\n  function _poke(CachedData memory _data, bool _ignoreCadence) internal {\n    require(_data.totalCredits > 0, \"Must have something to poke\");\n\n    // 1. Verify that poke cadence is valid, unless this is a manual action by governance\n    uint256 currentTime = uint256(block.timestamp);\n    uint256 timeSinceLastPoke = currentTime - lastPoke;\n    require(\n      _ignoreCadence || timeSinceLastPoke > POKE_CADENCE,\n      \"Not enough time elapsed\"\n    );\n    lastPoke = currentTime;\n\n    // If there is a connector, check the balance and settle to the specified fraction %\n    IConnector connector_ = connector;\n    if (address(connector_) != address(0)) {\n      // 2. Check and verify new connector balance\n      uint256 lastBalance_ = lastBalance;\n      uint256 connectorBalance = connector_.checkBalance();\n      //      Always expect the collateral in the connector to increase in value\n      require(connectorBalance >= lastBalance_, \"Invalid yield\");\n      if (connectorBalance > 0) {\n        //  Validate the collection by ensuring that the APY is not ridiculous\n        YieldValidator.validateCollection(\n          connectorBalance,\n          connectorBalance - lastBalance_,\n          timeSinceLastPoke,\n          MAX_APY,\n          1e15\n        );\n      }\n\n      // 3. Level the assets to Fraction (connector) & 100-fraction (raw)\n      uint256 sum = _data.rawBalance + connectorBalance;\n      uint256 ideal = sum.mulTruncate(_data.fraction);\n      //     If there is not enough mAsset in the connector, then deposit\n      if (ideal > connectorBalance) {\n        uint256 deposit = ideal - connectorBalance;\n        underlying.approve(address(connector_), deposit);\n        connector_.deposit(deposit);\n      }\n      //     Else withdraw, if there is too much mAsset in the connector\n      else if (connectorBalance > ideal) {\n        // If fraction == 0, then withdraw everything\n        if (ideal == 0) {\n          connector_.withdrawAll();\n          sum = IERC20(underlying).balanceOf(address(this));\n        } else {\n          connector_.withdraw(connectorBalance - ideal);\n        }\n      }\n      //     Else ideal == connectorBalance (e.g. 0), do nothing\n      require(connector_.checkBalance() >= ideal, \"Enforce system invariant\");\n\n      // 4i. Refresh exchange rate and emit event\n      lastBalance = ideal;\n      _refreshExchangeRate(sum, _data.totalCredits, false);\n      emit Poked(lastBalance_, ideal, connectorBalance - lastBalance_);\n    } else {\n      // 4ii. Refresh exchange rate and emit event\n      lastBalance = 0;\n      _refreshExchangeRate(_data.rawBalance, _data.totalCredits, false);\n      emit PokedRaw();\n    }\n  }\n\n  /**\n   * @dev Internal fn to refresh the exchange rate, based on the sum of collateral and the number of credits\n   * @param _realSum          Sum of collateral held by the contract\n   * @param _totalCredits     Total number of credits in the system\n   * @param _ignoreValidation This is for use in the emergency situation, and ignores a decreasing exchangeRate\n   */\n  function _refreshExchangeRate(\n    uint256 _realSum,\n    uint256 _totalCredits,\n    bool _ignoreValidation\n  ) internal {\n    // Based on the current exchange rate, how much underlying is collateralised?\n    (uint256 totalCredited, ) = _creditsToUnderlying(_totalCredits);\n\n    // Require the amount of capital held to be greater than the previously credited units\n    require(\n      _ignoreValidation || _realSum >= totalCredited,\n      \"ExchangeRate must increase\"\n    );\n    // Work out the new exchange rate based on the current capital\n    uint256 newExchangeRate = _calcExchangeRate(_realSum, _totalCredits);\n    exchangeRate = newExchangeRate;\n\n    emit ExchangeRateUpdated(\n      newExchangeRate,\n      _realSum > totalCredited ? _realSum - totalCredited : 0\n    );\n  }\n\n  /***************************************\n                    VIEW - I\n    ****************************************/\n\n  struct CachedData {\n    // SLOAD from 'fraction'\n    uint256 fraction;\n    // ERC20 balance of underlying, held by this contract\n    // underlying.balanceOf(address(this))\n    uint256 rawBalance;\n    // totalSupply()\n    uint256 totalCredits;\n  }\n\n  /**\n   * @dev Retrieves generic data to avoid duplicate SLOADs\n   */\n  function _cacheData() internal view returns (CachedData memory) {\n    uint256 balance = underlying.balanceOf(address(this));\n    return CachedData(fraction, balance, totalSupply());\n  }\n\n  /**\n   * @dev Converts masset amount into credits based on exchange rate\n   *               c = (masset / exchangeRate) + 1\n   */\n  function _underlyingToCredits(uint256 _underlying)\n    internal\n    view\n    returns (uint256 credits, uint256 exchangeRate_)\n  {\n    // e.g. (1e20 * 1e18) / 1e18 = 1e20\n    // e.g. (1e20 * 1e18) / 14e17 = 7.1429e19\n    // e.g. 1 * 1e18 / 1e17 + 1 = 11 => 11 * 1e17 / 1e18 = 1.1e18 / 1e18 = 1\n    exchangeRate_ = exchangeRate;\n    credits = _underlying.divPrecisely(exchangeRate_) + 1;\n  }\n\n  /**\n   * @dev Works out a new exchange rate, given an amount of collateral and total credits\n   *               e = underlying / (credits-1)\n   */\n  function _calcExchangeRate(uint256 _totalCollateral, uint256 _totalCredits)\n    internal\n    pure\n    returns (uint256 _exchangeRate)\n  {\n    _exchangeRate = _totalCollateral.divPrecisely(_totalCredits - 1);\n  }\n\n  /**\n   * @dev Converts credit amount into masset based on exchange rate\n   *               m = credits * exchangeRate\n   */\n  function _creditsToUnderlying(uint256 _credits)\n    internal\n    view\n    returns (uint256 underlyingAmount, uint256 exchangeRate_)\n  {\n    // e.g. (1e20 * 1e18) / 1e18 = 1e20\n    // e.g. (1e20 * 14e17) / 1e18 = 1.4e20\n    exchangeRate_ = exchangeRate;\n    underlyingAmount = _credits.mulTruncate(exchangeRate_);\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/ISavingsManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title ISavingsManager\n */\ninterface ISavingsManager {\n  /** @dev Admin privs */\n  function distributeUnallocatedInterest(address _mAsset) external;\n\n  /** @dev Liquidator */\n  function depositLiquidation(address _mAsset, uint256 _liquidation) external;\n\n  /** @dev Liquidator */\n  function collectAndStreamInterest(address _mAsset) external;\n\n  /** @dev Public privs */\n  function collectAndDistributeInterest(address _mAsset) external;\n\n  /** @dev getter for public lastBatchCollected mapping */\n  function lastBatchCollected(address _mAsset) external view returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/interfaces/ISavingsContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISavingsContractV1 {\n  function depositInterest(uint256 _amount) external;\n\n  function depositSavings(uint256 _amount)\n    external\n    returns (uint256 creditsIssued);\n\n  function redeem(uint256 _amount) external returns (uint256 massetReturned);\n\n  function exchangeRate() external view returns (uint256);\n\n  function creditBalances(address) external view returns (uint256);\n}\n\ninterface ISavingsContractV2 {\n  // DEPRECATED but still backwards compatible\n  function redeem(uint256 _amount) external returns (uint256 massetReturned);\n\n  function creditBalances(address) external view returns (uint256); // V1 & V2 (use balanceOf)\n\n  // --------------------------------------------\n\n  function depositInterest(uint256 _amount) external; // V1 & V2\n\n  function depositSavings(uint256 _amount)\n    external\n    returns (uint256 creditsIssued); // V1 & V2\n\n  function depositSavings(uint256 _amount, address _beneficiary)\n    external\n    returns (uint256 creditsIssued); // V2\n\n  function redeemCredits(uint256 _amount)\n    external\n    returns (uint256 underlyingReturned); // V2\n\n  function redeemUnderlying(uint256 _amount)\n    external\n    returns (uint256 creditsBurned); // V2\n\n  function exchangeRate() external view returns (uint256); // V1 & V2\n\n  function balanceOfUnderlying(address _user)\n    external\n    view\n    returns (uint256 underlying); // V2\n\n  function underlyingToCredits(uint256 _underlying)\n    external\n    view\n    returns (uint256 credits); // V2\n\n  function creditsToUnderlying(uint256 _credits)\n    external\n    view\n    returns (uint256 underlying); // V2\n\n  function underlying() external view returns (IERC20 underlyingMasset); // V2\n}\n\ninterface ISavingsContractV3 {\n  // DEPRECATED but still backwards compatible\n  function redeem(uint256 _amount) external returns (uint256 massetReturned);\n\n  function creditBalances(address) external view returns (uint256); // V1 & V2 (use balanceOf)\n\n  // --------------------------------------------\n\n  function depositInterest(uint256 _amount) external; // V1 & V2\n\n  function depositSavings(uint256 _amount)\n    external\n    returns (uint256 creditsIssued); // V1 & V2\n\n  function depositSavings(uint256 _amount, address _beneficiary)\n    external\n    returns (uint256 creditsIssued); // V2\n\n  function redeemCredits(uint256 _amount)\n    external\n    returns (uint256 underlyingReturned); // V2\n\n  function redeemUnderlying(uint256 _amount)\n    external\n    returns (uint256 creditsBurned); // V2\n\n  function exchangeRate() external view returns (uint256); // V1 & V2\n\n  function balanceOfUnderlying(address _user)\n    external\n    view\n    returns (uint256 underlying); // V2\n\n  function underlyingToCredits(uint256 _underlying)\n    external\n    view\n    returns (uint256 credits); // V2\n\n  function creditsToUnderlying(uint256 _credits)\n    external\n    view\n    returns (uint256 underlying); // V2\n\n  function underlying() external view returns (IERC20 underlyingMasset); // V2\n\n  // --------------------------------------------\n\n  function redeemAndUnwrap(\n    uint256 _amount,\n    bool _isCreditAmt,\n    uint256 _minAmountOut,\n    address _output,\n    address _beneficiary,\n    address _router,\n    bool _isBassetOut\n  )\n    external\n    returns (\n      uint256 creditsBurned,\n      uint256 massetRedeemed,\n      uint256 outputQuantity\n    );\n\n  function depositSavings(\n    uint256 _underlying,\n    address _beneficiary,\n    address _referrer\n  ) external returns (uint256 creditsIssued);\n}\n"
    },
    "contracts/ppo-staking/interfaces/IUnwrapper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title IUnwrapper\n */\ninterface IUnwrapper {\n  // @dev Get bAssetOut status\n  function getIsBassetOut(\n    address _masset,\n    bool _inputIsCredit,\n    address _output\n  ) external view returns (bool isBassetOut);\n\n  /// @dev Estimate output\n  function getUnwrapOutput(\n    bool _isBassetOut,\n    address _router,\n    address _input,\n    bool _inputIsCredit,\n    address _output,\n    uint256 _amount\n  ) external view returns (uint256 output);\n\n  /// @dev Unwrap and send\n  function unwrapAndSend(\n    bool _isBassetOut,\n    address _router,\n    address _input,\n    address _output,\n    uint256 _amount,\n    uint256 _minAmountOut,\n    address _beneficiary\n  ) external returns (uint256 outputQuantity);\n}\n"
    },
    "contracts/ppo-staking/shared/InitializableToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ERC205, IERC20} from \"./@openzeppelin-2.5/ERC205.sol\";\nimport {InitializableERC20Detailed} from \"./InitializableERC20Detailed.sol\";\n\n/**\n * @title  InitializableToken\n * @author mStable\n * @dev    Basic ERC20Detailed Token functionality for Masset\n */\nabstract contract InitializableToken is ERC205, InitializableERC20Detailed {\n  /**\n   * @dev Initialization function for implementing contract\n   * @notice To avoid variable shadowing appended `Arg` after arguments name.\n   */\n  function _initialize(string memory _nameArg, string memory _symbolArg)\n    internal\n    virtual\n  {\n    InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/@openzeppelin-2.5/Initializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ncontract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(\n      initializing || isConstructor() || !initialized,\n      \"Contract instance has already been initialized\"\n    );\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly {\n      cs := extcodesize(self)\n    }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ppo-staking/shared/YieldValidator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nlibrary YieldValidator {\n  uint256 private constant SECONDS_IN_YEAR = 365 days;\n  uint256 private constant THIRTY_MINUTES = 30 minutes;\n\n  uint256 private constant MAX_APY = 15e18;\n  uint256 private constant TEN_BPS = 1e15;\n\n  /**\n   * @dev Validates that an interest collection does not exceed a maximum APY. If last collection\n   * was under 30 mins ago, simply check it does not exceed 10bps\n   * @param _newSupply               New total supply of the mAsset\n   * @param _interest                Increase in total supply since last collection\n   * @param _timeSinceLastCollection Seconds since last collection\n   */\n  function validateCollection(\n    uint256 _newSupply,\n    uint256 _interest,\n    uint256 _timeSinceLastCollection\n  ) internal pure returns (uint256 extrapolatedAPY) {\n    return\n      validateCollection(\n        _newSupply,\n        _interest,\n        _timeSinceLastCollection,\n        MAX_APY,\n        TEN_BPS\n      );\n  }\n\n  /**\n   * @dev Validates that an interest collection does not exceed a maximum APY. If last collection\n   * was under 30 mins ago, simply check it does not exceed 10bps\n   * @param _newSupply               New total supply of the mAsset\n   * @param _interest                Increase in total supply since last collection\n   * @param _timeSinceLastCollection Seconds since last collection\n   * @param _maxApy                  Max APY where 100% == 1e18\n   * @param _baseApy                 If less than 30 mins, do not exceed this % increase\n   */\n  function validateCollection(\n    uint256 _newSupply,\n    uint256 _interest,\n    uint256 _timeSinceLastCollection,\n    uint256 _maxApy,\n    uint256 _baseApy\n  ) internal pure returns (uint256 extrapolatedAPY) {\n    uint256 protectedTime = _timeSinceLastCollection == 0\n      ? 1\n      : _timeSinceLastCollection;\n\n    // Percentage increase in total supply\n    // e.g. (1e20 * 1e18) / 1e24 = 1e14 (or a 0.01% increase)\n    // e.g. (5e18 * 1e18) / 1.2e24 = 4.1667e12\n    // e.g. (1e19 * 1e18) / 1e21 = 1e16\n    uint256 oldSupply = _newSupply - _interest;\n    uint256 percentageIncrease = (_interest * 1e18) / oldSupply;\n\n    //      If over 30 mins, extrapolate APY\n    // e.g. day: (86400 * 1e18) / 3.154e7 = 2.74..e15\n    // e.g. 30 mins: (1800 * 1e18) / 3.154e7 = 5.7..e13\n    // e.g. epoch: (1593596907 * 1e18) / 3.154e7 = 50.4..e18\n    uint256 yearsSinceLastCollection = (protectedTime * 1e18) /\n      SECONDS_IN_YEAR;\n\n    // e.g. 0.01% (1e14 * 1e18) / 2.74..e15 = 3.65e16 or 3.65% apr\n    // e.g. (4.1667e12 * 1e18) / 5.7..e13 = 7.1e16 or 7.1% apr\n    // e.g. (1e16 * 1e18) / 50e18 = 2e14\n    extrapolatedAPY = (percentageIncrease * 1e18) / yearsSinceLastCollection;\n\n    if (protectedTime > THIRTY_MINUTES) {\n      require(\n        extrapolatedAPY < _maxApy,\n        \"Interest protected from inflating past maxAPY\"\n      );\n    } else {\n      require(\n        percentageIncrease < _baseApy,\n        \"Interest protected from inflating past 10 Bps\"\n      );\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/@openzeppelin-2.5/ERC205.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"./Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC205 is Context, IERC20 {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\n    require(\n      currentAllowance >= amount,\n      \"ERC20: transfer amount exceeds allowance\"\n    );\n    _approve(sender, _msgSender(), currentAllowance - amount);\n\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender] + addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[sender] = senderBalance - amount;\n    _balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    _balances[account] = accountBalance - amount;\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/ppo-staking/shared/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n */\nabstract contract InitializableERC20Detailed is IERC20 {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n   * these values are immutable: they can only be set once during\n   * construction.\n   * @notice To avoid variable shadowing appended `Arg` after arguments name.\n   */\n  function _initialize(\n    string memory nameArg,\n    string memory symbolArg,\n    uint8 decimalsArg\n  ) internal {\n    _name = nameArg;\n    _symbol = symbolArg;\n    _decimals = decimalsArg;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/@openzeppelin-2.5/Context.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  // Empty internal constructor, to prevent people from mistakenly deploying\n  // an instance of this contract, which should be used via inheritance.\n  // constructor () internal { }\n  // solhint-disable-previous-line no-empty-blocks\n\n  function _msgSender() internal view returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "contracts/ppo-staking/savings/SavingsManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n// External\nimport {IMasset} from \"../interfaces/IMasset.sol\";\nimport {ISavingsContractV2} from \"../interfaces/ISavingsContract.sol\";\n\n// Internal\nimport {IRevenueRecipient} from \"../interfaces/IRevenueRecipient.sol\";\nimport {ISavingsManager} from \"../interfaces/ISavingsManager.sol\";\nimport {PausableModule} from \"../shared/PausableModule.sol\";\n\n// Libs\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {StableMath} from \"../shared/StableMath.sol\";\nimport {YieldValidator} from \"../shared/YieldValidator.sol\";\n\n/**\n * @title   SavingsManager\n * @author  mStable\n * @notice  Savings Manager collects interest from mAssets and sends them to the\n *          corresponding Savings Contract, performing some validation in the process.\n * @dev     VERSION: 1.4\n *          DATE:    2021-10-15\n */\ncontract SavingsManager is ISavingsManager, PausableModule {\n  using StableMath for uint256;\n  using SafeERC20 for IERC20;\n\n  // Core admin events\n  event RevenueRecipientSet(address indexed mAsset, address recipient);\n  event SavingsContractAdded(address indexed mAsset, address savingsContract);\n  event SavingsContractUpdated(\n    address indexed mAsset,\n    address savingsContract\n  );\n  event SavingsRateChanged(uint256 newSavingsRate);\n  event StreamsFrozen();\n  // Interest collection\n  event LiquidatorDeposited(address indexed mAsset, uint256 amount);\n  event InterestCollected(\n    address indexed mAsset,\n    uint256 interest,\n    uint256 newTotalSupply,\n    uint256 apy\n  );\n  event InterestDistributed(address indexed mAsset, uint256 amountSent);\n  event RevenueRedistributed(\n    address indexed mAsset,\n    address recipient,\n    uint256 amount\n  );\n\n  // Locations of each mAsset savings contract\n  mapping(address => ISavingsContractV2) public savingsContracts;\n  mapping(address => IRevenueRecipient) public revenueRecipients;\n  // Time at which last collection was made\n  mapping(address => uint256) public lastPeriodStart;\n  mapping(address => uint256) public lastCollection;\n  mapping(address => uint256) public periodYield;\n\n  // Amount of collected interest that will be sent to Savings Contract (1e18 = 100%)\n  uint256 private savingsRate;\n  // Streaming liquidated tokens\n  uint256 private immutable DURATION; // measure in days. eg 1 days or 7 days\n  uint256 private constant ONE_DAY = 1 days;\n  uint256 private constant THIRTY_MINUTES = 30 minutes;\n  // Streams\n  bool private streamsFrozen = false;\n  // Liquidator\n  mapping(address => Stream) public liqStream;\n  // Platform\n  mapping(address => Stream) public yieldStream;\n  // Batches are for the platformInterest collection\n  mapping(address => uint256) public override lastBatchCollected;\n\n  enum StreamType {\n    liquidator,\n    yield\n  }\n\n  struct Stream {\n    uint256 end;\n    uint256 rate;\n  }\n\n  constructor(\n    address _nexus,\n    address[] memory _mAssets,\n    address[] memory _savingsContracts,\n    address[] memory _revenueRecipients,\n    uint256 _savingsRate,\n    uint256 _duration\n  ) PausableModule(_nexus) {\n    uint256 len = _mAssets.length;\n    require(\n      _savingsContracts.length == len && _revenueRecipients.length == len,\n      \"Invalid inputs\"\n    );\n    for (uint256 i = 0; i < len; i++) {\n      _updateSavingsContract(_mAssets[i], _savingsContracts[i]);\n      emit SavingsContractAdded(_mAssets[i], _savingsContracts[i]);\n\n      revenueRecipients[_mAssets[i]] = IRevenueRecipient(\n        _revenueRecipients[i]\n      );\n      emit RevenueRecipientSet(_mAssets[i], _revenueRecipients[i]);\n    }\n    savingsRate = _savingsRate;\n    DURATION = _duration;\n  }\n\n  modifier onlyLiquidator() {\n    require(msg.sender == _liquidator(), \"Only liquidator can execute\");\n    _;\n  }\n\n  modifier whenStreamsNotFrozen() {\n    require(!streamsFrozen, \"Streaming is currently frozen\");\n    _;\n  }\n\n  /***************************************\n                    STATE\n    ****************************************/\n\n  /**\n   * @dev Adds a new savings contract\n   * @param _mAsset           Address of underlying mAsset\n   * @param _savingsContract  Address of the savings contract\n   */\n  function addSavingsContract(address _mAsset, address _savingsContract)\n    external\n    onlyGovernor\n  {\n    require(\n      address(savingsContracts[_mAsset]) == address(0),\n      \"Savings contract already exists\"\n    );\n    _updateSavingsContract(_mAsset, _savingsContract);\n    emit SavingsContractAdded(_mAsset, _savingsContract);\n  }\n\n  /**\n   * @dev Updates an existing savings contract\n   * @param _mAsset           Address of underlying mAsset\n   * @param _savingsContract  Address of the savings contract\n   */\n  function updateSavingsContract(address _mAsset, address _savingsContract)\n    external\n    onlyGovernor\n  {\n    require(\n      address(savingsContracts[_mAsset]) != address(0),\n      \"Savings contract does not exist\"\n    );\n    _updateSavingsContract(_mAsset, _savingsContract);\n    emit SavingsContractUpdated(_mAsset, _savingsContract);\n  }\n\n  function _updateSavingsContract(address _mAsset, address _savingsContract)\n    internal\n  {\n    require(\n      _mAsset != address(0) && _savingsContract != address(0),\n      \"Must be valid address\"\n    );\n    savingsContracts[_mAsset] = ISavingsContractV2(_savingsContract);\n\n    IERC20(_mAsset).safeApprove(address(_savingsContract), 0);\n    IERC20(_mAsset).safeApprove(address(_savingsContract), type(uint256).max);\n  }\n\n  /**\n   * @dev Freezes streaming of mAssets\n   */\n  function freezeStreams() external onlyGovernor whenStreamsNotFrozen {\n    streamsFrozen = true;\n\n    emit StreamsFrozen();\n  }\n\n  /**\n   * @dev Sets the revenue recipient address\n   * @param _mAsset           Address of underlying mAsset\n   * @param _recipient        Address of the recipient\n   */\n  function setRevenueRecipient(address _mAsset, address _recipient)\n    external\n    onlyGovernor\n  {\n    revenueRecipients[_mAsset] = IRevenueRecipient(_recipient);\n\n    emit RevenueRecipientSet(_mAsset, _recipient);\n  }\n\n  /**\n   * @dev Sets a new savings rate for interest distribution\n   * @param _savingsRate   Rate of savings sent to SavingsContract (100% = 1e18)\n   */\n  function setSavingsRate(uint256 _savingsRate) external onlyGovernor {\n    // Greater than 25% up to 100%\n    require(\n      _savingsRate >= 25e16 && _savingsRate <= 1e18,\n      \"Must be a valid rate\"\n    );\n    savingsRate = _savingsRate;\n    emit SavingsRateChanged(_savingsRate);\n  }\n\n  /**\n   * @dev Allows the liquidator to deposit proceeds from liquidated gov tokens.\n   * Transfers proceeds on a second by second basis to the Savings Contract over 1 week.\n   * @param _mAsset The mAsset to transfer and distribute\n   * @param _liquidated Units of mAsset to distribute\n   */\n  function depositLiquidation(address _mAsset, uint256 _liquidated)\n    external\n    override\n    whenNotPaused\n    onlyLiquidator\n    whenStreamsNotFrozen\n  {\n    // Collect existing interest to ensure everything is up to date\n    _collectAndDistributeInterest(_mAsset);\n\n    // transfer liquidated mUSD to here\n    IERC20(_mAsset).safeTransferFrom(\n      _liquidator(),\n      address(this),\n      _liquidated\n    );\n\n    uint256 leftover = _unstreamedRewards(_mAsset, StreamType.liquidator);\n    _initialiseStream(\n      _mAsset,\n      StreamType.liquidator,\n      _liquidated + leftover,\n      DURATION\n    );\n\n    emit LiquidatorDeposited(_mAsset, _liquidated);\n  }\n\n  /**\n   * @dev Collects the platform interest from a given mAsset and then adds capital to the\n   * stream. If there is > 24h left in current stream, just top it up, otherwise reset.\n   * @param _mAsset The mAsset to fetch interest\n   */\n  function collectAndStreamInterest(address _mAsset)\n    external\n    override\n    whenNotPaused\n    whenStreamsNotFrozen\n  {\n    // Collect existing interest to ensure everything is up to date\n    _collectAndDistributeInterest(_mAsset);\n\n    uint256 currentTime = block.timestamp;\n    uint256 previousBatch = lastBatchCollected[_mAsset];\n    uint256 timeSincePreviousBatch = currentTime - previousBatch;\n    require(\n      timeSincePreviousBatch > 6 hours,\n      \"Cannot deposit twice in 6 hours\"\n    );\n    lastBatchCollected[_mAsset] = currentTime;\n\n    // Batch collect\n    (uint256 interestCollected, uint256 totalSupply) = IMasset(_mAsset)\n      .collectPlatformInterest();\n\n    if (interestCollected > 0) {\n      // Validate APY\n      uint256 apy = YieldValidator.validateCollection(\n        totalSupply,\n        interestCollected,\n        timeSincePreviousBatch\n      );\n\n      // Get remaining rewards\n      uint256 leftover = _unstreamedRewards(_mAsset, StreamType.yield);\n      _initialiseStream(\n        _mAsset,\n        StreamType.yield,\n        interestCollected + leftover,\n        ONE_DAY\n      );\n\n      emit InterestCollected(_mAsset, interestCollected, totalSupply, apy);\n    } else {\n      emit InterestCollected(_mAsset, interestCollected, totalSupply, 0);\n    }\n  }\n\n  /**\n   * @dev Calculates how many rewards from the stream are still to be distributed, from the\n   * last collection time to the end of the stream.\n   * @param _mAsset The mAsset in question\n   * @return leftover The total amount of mAsset that is yet to be collected from a stream\n   */\n  function _unstreamedRewards(address _mAsset, StreamType _stream)\n    internal\n    view\n    returns (uint256 leftover)\n  {\n    uint256 lastUpdate = lastCollection[_mAsset];\n\n    Stream memory stream = _stream == StreamType.liquidator\n      ? liqStream[_mAsset]\n      : yieldStream[_mAsset];\n    uint256 unclaimedSeconds = 0;\n    if (lastUpdate < stream.end) {\n      unclaimedSeconds = stream.end - lastUpdate;\n    }\n    return unclaimedSeconds * stream.rate;\n  }\n\n  /**\n   * @dev Simply sets up the stream\n   * @param _mAsset The mAsset in question\n   * @param _amount Amount of units to stream\n   * @param _duration Duration of the stream, from now\n   */\n  function _initialiseStream(\n    address _mAsset,\n    StreamType _stream,\n    uint256 _amount,\n    uint256 _duration\n  ) internal {\n    uint256 currentTime = block.timestamp;\n    // Distribute reward per second over X seconds\n    uint256 rate = _amount / _duration;\n    uint256 end = currentTime + _duration;\n    if (_stream == StreamType.liquidator) {\n      liqStream[_mAsset] = Stream(end, rate);\n    } else {\n      yieldStream[_mAsset] = Stream(end, rate);\n    }\n\n    // Reset pool data to enable lastCollection usage twice\n    require(\n      lastCollection[_mAsset] == currentTime,\n      \"Stream data must be up to date\"\n    );\n  }\n\n  /***************************************\n                COLLECTION\n    ****************************************/\n\n  /**\n   * @dev Collects interest from a target mAsset and distributes to the SavingsContract.\n   *      Applies constraints such that the max APY since the last fee collection cannot\n   *      exceed the \"MAX_APY\" variable.\n   * @param _mAsset       mAsset for which the interest should be collected\n   */\n  function collectAndDistributeInterest(address _mAsset)\n    external\n    override\n    whenNotPaused\n  {\n    _collectAndDistributeInterest(_mAsset);\n  }\n\n  function _collectAndDistributeInterest(address _mAsset) internal {\n    ISavingsContractV2 savingsContract = savingsContracts[_mAsset];\n    require(\n      address(savingsContract) != address(0),\n      \"Must have a valid savings contract\"\n    );\n\n    // Get collection details\n    uint256 recentPeriodStart = lastPeriodStart[_mAsset];\n    uint256 previousCollection = lastCollection[_mAsset];\n    lastCollection[_mAsset] = block.timestamp;\n\n    // 1. Collect the new interest from the mAsset\n    IMasset mAsset = IMasset(_mAsset);\n    (uint256 interestCollected, uint256 totalSupply) = mAsset\n      .collectInterest();\n\n    // 2. Update all the time stamps\n    //    Avoid division by 0 by adding a minimum elapsed time of 1 second\n    uint256 timeSincePeriodStart = StableMath.max(\n      1,\n      block.timestamp - recentPeriodStart\n    );\n    uint256 timeSinceLastCollection = StableMath.max(\n      1,\n      block.timestamp - previousCollection\n    );\n\n    uint256 inflationOperand = interestCollected;\n    //    If it has been 30 mins since last collection, reset period data\n    if (timeSinceLastCollection > THIRTY_MINUTES) {\n      lastPeriodStart[_mAsset] = block.timestamp;\n      periodYield[_mAsset] = 0;\n    }\n    //    Else if period has elapsed, start a new period from the lastCollection time\n    else if (timeSincePeriodStart > THIRTY_MINUTES) {\n      lastPeriodStart[_mAsset] = previousCollection;\n      periodYield[_mAsset] = interestCollected;\n    }\n    //    Else add yield to period yield\n    else {\n      inflationOperand = periodYield[_mAsset] + interestCollected;\n      periodYield[_mAsset] = inflationOperand;\n    }\n\n    //    Add on liquidated\n    uint256 newReward = _unclaimedRewards(_mAsset, previousCollection);\n    // 3. Validate that interest is collected correctly and does not exceed max APY\n    if (interestCollected > 0 || newReward > 0) {\n      require(\n        IERC20(_mAsset).balanceOf(address(this)) >=\n          interestCollected + newReward,\n        \"Must receive mUSD\"\n      );\n\n      uint256 extrapolatedAPY = YieldValidator.validateCollection(\n        totalSupply,\n        inflationOperand,\n        timeSinceLastCollection\n      );\n\n      emit InterestCollected(\n        _mAsset,\n        interestCollected,\n        totalSupply,\n        extrapolatedAPY\n      );\n\n      // 4. Distribute the interest\n      //    Calculate the share for savers (95e16 or 95%)\n      uint256 saversShare = (interestCollected + newReward).mulTruncate(\n        savingsRate\n      );\n\n      //    Call depositInterest on contract\n      savingsContract.depositInterest(saversShare);\n\n      emit InterestDistributed(_mAsset, saversShare);\n    } else {\n      emit InterestCollected(_mAsset, 0, totalSupply, 0);\n    }\n  }\n\n  /**\n   * @dev Calculates unclaimed rewards from the liquidation stream\n   * @param _mAsset mAsset key\n   * @param _previousCollection Time of previous collection\n   * @return Units of mAsset that have been unlocked for distribution\n   */\n  function _unclaimedRewards(address _mAsset, uint256 _previousCollection)\n    internal\n    view\n    returns (uint256)\n  {\n    Stream memory liq = liqStream[_mAsset];\n    uint256 unclaimedSeconds_liq = _unclaimedSeconds(\n      _previousCollection,\n      liq.end\n    );\n    uint256 subtotal_liq = unclaimedSeconds_liq * liq.rate;\n\n    Stream memory yield = yieldStream[_mAsset];\n    uint256 unclaimedSeconds_yield = _unclaimedSeconds(\n      _previousCollection,\n      yield.end\n    );\n    uint256 subtotal_yield = unclaimedSeconds_yield * yield.rate;\n\n    return subtotal_liq + subtotal_yield;\n  }\n\n  /**\n   * @dev Calculates the seconds of unclaimed rewards, based on period length\n   * @param _lastUpdate Time of last update\n   * @param _end End time of period\n   * @return Seconds of stream that should be compensated\n   */\n  function _unclaimedSeconds(uint256 _lastUpdate, uint256 _end)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 currentTime = block.timestamp;\n    uint256 unclaimedSeconds = 0;\n\n    if (currentTime <= _end) {\n      unclaimedSeconds = currentTime - _lastUpdate;\n    } else if (_lastUpdate < _end) {\n      unclaimedSeconds = _end - _lastUpdate;\n    }\n    return unclaimedSeconds;\n  }\n\n  /***************************************\n            Revenue Redistribution\n    ****************************************/\n\n  /**\n   * @dev Redistributes the unallocated interest to the saved recipient, allowing\n   * the siphoned assets to be used elsewhere in the system\n   * @param _mAsset  mAsset to collect\n   */\n  function distributeUnallocatedInterest(address _mAsset) external override {\n    IRevenueRecipient recipient = revenueRecipients[_mAsset];\n    require(address(recipient) != address(0), \"Must have valid recipient\");\n\n    IERC20 mAsset = IERC20(_mAsset);\n    uint256 balance = mAsset.balanceOf(address(this));\n    uint256 leftover_liq = _unstreamedRewards(_mAsset, StreamType.liquidator);\n    uint256 leftover_yield = _unstreamedRewards(_mAsset, StreamType.yield);\n\n    uint256 unallocated = balance - leftover_liq - leftover_yield;\n\n    mAsset.approve(address(recipient), unallocated);\n    recipient.notifyRedistributionAmount(_mAsset, unallocated);\n\n    emit RevenueRedistributed(_mAsset, address(recipient), unallocated);\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport {BassetData, BassetPersonal} from \"../masset/MassetStructs.sol\";\n\nabstract contract IMasset {\n  // Mint\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mintOutput);\n\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mintOutput);\n\n  function getMintOutput(address _input, uint256 _inputQuantity)\n    external\n    view\n    virtual\n    returns (uint256 mintOutput);\n\n  function getMintMultiOutput(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities\n  ) external view virtual returns (uint256 mintOutput);\n\n  // Swaps\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 swapOutput);\n\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view virtual returns (uint256 swapOutput);\n\n  // Redemption\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 outputQuantity);\n\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  ) external virtual returns (uint256[] memory outputQuantities);\n\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mAssetRedeemed);\n\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n    external\n    view\n    virtual\n    returns (uint256 bAssetOutput);\n\n  function getRedeemExactBassetsOutput(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities\n  ) external view virtual returns (uint256 mAssetAmount);\n\n  // Views\n  function getBasket() external view virtual returns (bool, bool);\n\n  function getBasset(address _token)\n    external\n    view\n    virtual\n    returns (BassetPersonal memory personal, BassetData memory data);\n\n  function getBassets()\n    external\n    view\n    virtual\n    returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n  function bAssetIndexes(address) external view virtual returns (uint8);\n\n  function getPrice() external view virtual returns (uint256 price, uint256 k);\n\n  // SavingsManager\n  function collectInterest()\n    external\n    virtual\n    returns (uint256 swapFeesGained, uint256 newSupply);\n\n  function collectPlatformInterest()\n    external\n    virtual\n    returns (uint256 mintAmount, uint256 newSupply);\n\n  // Admin\n  function setCacheSize(uint256 _cacheSize) external virtual;\n\n  function setFees(uint256 _swapFee, uint256 _redemptionFee) external virtual;\n\n  function setTransferFeesFlag(address _bAsset, bool _flag) external virtual;\n\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration)\n    external\n    virtual;\n}\n"
    },
    "contracts/ppo-staking/interfaces/IRevenueRecipient.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IRevenueRecipient {\n  /** @dev Recipient */\n  function notifyRedistributionAmount(address _mAsset, uint256 _amount)\n    external;\n\n  function depositToPool(\n    address[] calldata _mAssets,\n    uint256[] calldata _percentages\n  ) external;\n}\n"
    },
    "contracts/ppo-staking/shared/PausableModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ImmutableModule} from \"./ImmutableModule.sol\";\n\n/**\n * @title   PausableModule\n * @author  mStable\n * @dev     Forked from @openzeppelin/contracts/lifecycle/pausable\n *          Changes: `onlyGovernor` can pause\n */\nabstract contract PausableModule is ImmutableModule {\n  /**\n   * @dev Emitted when the pause is triggered by Governor\n   */\n  event Paused(address account);\n\n  /**\n   * @dev Emitted when the pause is lifted by Governor\n   */\n  event Unpaused(address account);\n\n  bool internal _paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!_paused, \"Pausable: paused\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(_paused, \"Pausable: not paused\");\n    _;\n  }\n\n  /**\n   * @dev Initializes the contract in unpaused state.\n   * Hooks into the Module to give the Governor ability to pause\n   * @param _nexus Nexus contract address\n   */\n  constructor(address _nexus) ImmutableModule(_nexus) {\n    _paused = false;\n  }\n\n  /**\n   * @dev Returns true if the contract is paused, and false otherwise.\n   * @return Returns `true` when paused, otherwise `false`\n   */\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Called by the Governor to pause, triggers stopped state.\n   */\n  function pause() external onlyGovernor whenNotPaused {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /**\n   * @dev Called by Governor to unpause, returns to normal state.\n   */\n  function unpause() external onlyGovernor whenPaused {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nstruct BassetPersonal {\n  // Address of the bAsset\n  address addr;\n  // Address of the bAsset\n  address integrator;\n  // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n  bool hasTxFee; // takes a byte in storage\n  // Status of the bAsset\n  BassetStatus status;\n}\n\nstruct BassetData {\n  // 1 Basset * ratio / ratioScale == x Masset (relative value)\n  // If ratio == 10e8 then 1 bAsset = 10 mAssets\n  // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n  uint128 ratio;\n  // Amount of the Basset that is held in Collateral\n  uint128 vaultBalance;\n}\n\n// Status of the Basset - has it broken its peg?\nenum BassetStatus {\n  Default,\n  Normal,\n  BrokenBelowPeg,\n  BrokenAbovePeg,\n  Blacklisted,\n  Liquidating,\n  Liquidated,\n  Failed\n}\n\nstruct BasketState {\n  bool undergoingRecol;\n  bool failed;\n}\n\nstruct FeederConfig {\n  uint256 supply;\n  uint256 a;\n  WeightLimits limits;\n}\n\nstruct InvariantConfig {\n  uint256 supply;\n  uint256 a;\n  WeightLimits limits;\n  uint256 recolFee;\n}\n\nstruct BasicConfig {\n  uint256 a;\n  WeightLimits limits;\n}\n\nstruct WeightLimits {\n  uint128 min;\n  uint128 max;\n}\n\nstruct AmpData {\n  uint64 initialA;\n  uint64 targetA;\n  uint64 rampStartTime;\n  uint64 rampEndTime;\n}\n\nstruct FeederData {\n  uint256 swapFee;\n  uint256 redemptionFee;\n  uint256 govFee;\n  uint256 pendingFees;\n  uint256 cacheSize;\n  BassetPersonal[] bAssetPersonal;\n  BassetData[] bAssetData;\n  AmpData ampData;\n  WeightLimits weightLimits;\n}\n\nstruct MassetData {\n  uint256 swapFee;\n  uint256 redemptionFee;\n  uint256 cacheSize;\n  uint256 surplus;\n  BassetPersonal[] bAssetPersonal;\n  BassetData[] bAssetData;\n  BasketState basket;\n  AmpData ampData;\n  WeightLimits weightLimits;\n}\n\nstruct AssetData {\n  uint8 idx;\n  uint256 amt;\n  BassetPersonal personal;\n}\n\nstruct Asset {\n  uint8 idx;\n  address addr;\n  bool exists;\n}\n"
    },
    "contracts/ppo-staking/upgradability/DelayedProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/**\n * @title   DelayedProxyAdmin\n * @author  mStable\n * @notice  Proxy admin contract to upgrade the upgradable contracts. The upgradable contracts\n *          are transparent proxy contracts from OpenZeppelin-SDK.\n * @dev     The contract has a delyed upgradability. The Governor can propose a new implementation\n *          for a proxy contract. After 1 week of opt-out delay, upgrade request can be accepted\n *          and upgrade of contract is performed.\n *          Part of the code taken from OpenZeppelin-SDK's ProxyAdmin.sol\n */\ncontract DelayedProxyAdmin is ImmutableModule {\n  event UpgradeProposed(\n    address indexed proxy,\n    address implementation,\n    bytes data\n  );\n  event UpgradeCancelled(address indexed proxy);\n  event Upgraded(\n    address indexed proxy,\n    address oldImpl,\n    address newImpl,\n    bytes data\n  );\n\n  // Request struct to store proposed upgrade requests\n  struct Request {\n    address implementation; // New contract implementation address\n    bytes data; // Data to call a function on new contract implementation\n    uint256 timestamp; // Timestamp when upgrade request is proposed\n  }\n\n  // Opt-out upgrade delay\n  uint256 public constant UPGRADE_DELAY = 1 weeks;\n\n  // ProxyAddress => Request\n  mapping(address => Request) public requests;\n\n  /**\n   * @dev Constructor\n   * @param _nexus Nexus contract address\n   */\n  constructor(address _nexus) ImmutableModule(_nexus) {}\n\n  /**\n   * @dev The Governor can propose a new contract implementation for a given proxy.\n   * @param _proxy Proxy address which is to be upgraded\n   * @param _implementation Contract address of new implementation\n   * @param _data calldata to execute initialization function upon upgrade\n   */\n  function proposeUpgrade(\n    address _proxy,\n    address _implementation,\n    bytes calldata _data\n  ) external onlyGovernor {\n    require(_proxy != address(0), \"Proxy address is zero\");\n    require(_implementation != address(0), \"Implementation address is zero\");\n    require(\n      requests[_proxy].implementation == address(0),\n      \"Upgrade already proposed\"\n    );\n    validateProxy(_proxy, _implementation);\n\n    Request storage request = requests[_proxy];\n    request.implementation = _implementation;\n    request.data = _data;\n    request.timestamp = block.timestamp;\n\n    emit UpgradeProposed(_proxy, _implementation, _data);\n  }\n\n  /**\n   * @dev The Governor can cancel any existing upgrade request.\n   * @param _proxy The proxy address of the existing request\n   */\n  function cancelUpgrade(address _proxy) external onlyGovernor {\n    require(_proxy != address(0), \"Proxy address is zero\");\n    require(requests[_proxy].implementation != address(0), \"No request found\");\n    delete requests[_proxy];\n    emit UpgradeCancelled(_proxy);\n  }\n\n  /**\n   * @dev The Governor can accept upgrade request after opt-out delay over. The function is\n   *      `payable`, to forward ETH to initialize function call upon upgrade.\n   * @param _proxy The address of the proxy\n   */\n  function acceptUpgradeRequest(address payable _proxy)\n    external\n    payable\n    onlyGovernor\n  {\n    // _proxy is payable, because AdminUpgradeabilityProxy has fallback function\n    require(_proxy != address(0), \"Proxy address is zero\");\n    Request memory request = requests[_proxy];\n    require(_isDelayOver(request.timestamp), \"Delay not over\");\n\n    address newImpl = request.implementation;\n    bytes memory data = request.data;\n\n    address oldImpl = getProxyImplementation(_proxy);\n\n    // Deleting before to avoid re-entrancy\n    delete requests[_proxy];\n\n    if (data.length == 0) {\n      require(msg.value == 0, \"msg.value should be zero\");\n      TransparentUpgradeableProxy(_proxy).upgradeTo(newImpl);\n    } else {\n      TransparentUpgradeableProxy(_proxy).upgradeToAndCall{value: msg.value}(\n        newImpl,\n        data\n      );\n    }\n\n    emit Upgraded(_proxy, oldImpl, newImpl, data);\n  }\n\n  /**\n   * @dev Checks that the opt-out delay is over\n   * @param _timestamp Timestamp when upgrade requested\n   * @return Returns `true` when upgrade delay is over, otherwise `false`\n   */\n  function _isDelayOver(uint256 _timestamp) private view returns (bool) {\n    if (_timestamp > 0 && block.timestamp >= _timestamp + UPGRADE_DELAY)\n      return true;\n    return false;\n  }\n\n  /**\n   * @dev Checks the given proxy address is a valid proxy for this contract\n   * @param _proxy The address of the proxy\n   * @param _newImpl New implementation contract address\n   */\n  function validateProxy(address _proxy, address _newImpl) internal view {\n    // Proxy has an implementation\n    address currentImpl = getProxyImplementation(_proxy);\n\n    // Existing implementation must not be same as new one\n    require(_newImpl != currentImpl, \"Implementation must be different\");\n\n    // This contract is the Proxy admin of the given _proxy address\n    address admin = getProxyAdmin(_proxy);\n    require(admin == address(this), \"Proxy admin not matched\");\n  }\n\n  /**\n   * @dev Returns the admin of a proxy. Only the admin can query it.\n   * @param _proxy Contract address of Proxy\n   * @return The address of the current admin of the proxy.\n   */\n  function getProxyAdmin(address _proxy) public view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    (bool success, bytes memory returndata) = _proxy.staticcall(hex\"f851a440\");\n    require(success, \"Call failed\");\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Returns the current implementation of a proxy.\n   * This is needed because only the proxy admin can query it.\n   * @param _proxy Contract address of Proxy\n   * @return The address of the current implementation of the proxy.\n   */\n  function getProxyImplementation(address _proxy)\n    public\n    view\n    returns (address)\n  {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    (bool success, bytes memory returndata) = _proxy.staticcall(hex\"5c60da1b\");\n    require(success, \"Call failed\");\n    return abi.decode(returndata, (address));\n  }\n\n  // NOTICE: This can be removed. However, kept it for us to remind that we are not calling this fn.\n  // We are not allowing this function call from Governor or Governance.\n  /**\n   * @dev Changes the admin of a proxy.\n   * @param proxy Proxy to change admin.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  // function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyGovernor {\n  //     proxy.changeAdmin(newAdmin);\n  // }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/ppo-staking/upgradability/Proxies.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n// import { InitializableAdminUpgradeabilityProxy } from \"../shared/@openzeppelin-2.5/upgrades/InitializableAdminUpgradeabilityProxy.sol\";\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/**\n * @notice AssetProxy delegates calls to a Masset implementation\n * @dev    Extending on OpenZeppelin's InitializableAdminUpgradabilityProxy\n * means that the proxy is upgradable through a ProxyAdmin. AssetProxy upgrades\n * are implemented by a DelayedProxyAdmin, which enforces a 1 week opt-out period.\n * All upgrades are governed through the current mStable governance.\n */\ncontract AssetProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n\n/**\n * @notice BasketManagerProxy delegates calls to a BasketManager implementation\n * @dev    Extending on OpenZeppelin's InitializableAdminUpgradabilityProxy\n * means that the proxy is upgradable through a ProxyAdmin. BasketManagerProxy upgrades\n * are implemented by a DelayedProxyAdmin, which enforces a 1 week opt-out period.\n * All upgrades are governed through the current mStable governance.\n */\ncontract BasketManagerProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n * @dev    Extending on OpenZeppelin's InitializableAdminUpgradabilityProxy\n * means that the proxy is upgradable through a ProxyAdmin. VaultProxy upgrades\n * are implemented by a DelayedProxyAdmin, which enforces a 1 week opt-out period.\n * All upgrades are governed through the current mStable governance.\n */\ncontract VaultProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n\n/**\n * @notice LiquidatorProxy delegates calls to a Liquidator implementation\n * @dev    Extending on OpenZeppelin's InitializableAdminUpgradabilityProxy\n * means that the proxy is upgradable through a ProxyAdmin. LiquidatorProxy upgrades\n * are implemented by a DelayedProxyAdmin, which enforces a 1 week opt-out period.\n * All upgrades are governed through the current mStable governance.\n */\ncontract LiquidatorProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/pregenesis/PregenPass.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract PregenPass is SafeOwnable, ERC721Enumerable {\n  uint256 private _id;\n  string private _uri;\n\n  constructor(string memory _newURI) ERC721(\"Pregen Pass\", \"PREGENPASS\") {\n    _uri = _newURI;\n  }\n\n  function setURI(string memory _newURI) external onlyOwner {\n    _uri = _newURI;\n  }\n\n  function mint(address _to) external {\n    _safeMint(_to, _id++);\n  }\n\n  function mintBatch(address[] memory _accounts) external {\n    uint256 _tempId = _id;\n    uint256 _arrayLength = _accounts.length;\n    for (uint256 i = 0; i < _arrayLength; ++i) {\n      _safeMint(_accounts[i], _tempId++);\n    }\n    _id = _tempId;\n  }\n\n  function burn(uint256 _tokenId) external {\n    _burn(_tokenId);\n  }\n\n  function burnBatch(uint256[] memory _tokenIds) external {\n    uint256 _arrayLength = _tokenIds.length;\n    for (uint256 i = 0; i < _arrayLength; ++i) {\n      _burn(_tokenIds[i]);\n    }\n  }\n\n  // solhint-disable-next-line no-unused-vars\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    override\n    returns (string memory)\n  {\n    return _uri;\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal override(ERC721Enumerable) onlyOwner {\n    super._beforeTokenTransfer(_from, _to, _tokenId);\n  }\n}\n"
    },
    "contracts/pregenesis/mocks/MockPregenPass.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"../PregenPass.sol\";\n\ncontract MockPregenPass is PregenPass {\n  constructor(string memory _newURI) PregenPass(_newURI) {}\n\n  function beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external {\n    _beforeTokenTransfer(_from, _to, _tokenId);\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/ERC721Mintable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract ERC721Mintable is ERC721, SafeOwnable {\n  constructor(string memory _newName, string memory _newSymbol)\n    ERC721(_newName, _newSymbol)\n  {}\n\n  function mint(address _recipient, uint256 _tokenId) external onlyOwner {\n    _mint(_recipient, _tokenId);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/ppo-staking/shared/MetaToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {GovernedMinterRole} from \"./GovernedMinterRole.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @title  MintableToken\n * @author mStable\n */\ncontract MintableToken is ERC20, GovernedMinterRole, ERC20Burnable {\n  constructor(address _nexus, address _initialRecipient)\n    ERC20(\"Meta\", \"MTA\")\n    GovernedMinterRole(_nexus)\n  {\n    // 100m initial supply\n    _mint(_initialRecipient, 100000000 * (10**18));\n  }\n\n  /**\n   * @dev See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the {MinterRole}.\n   */\n  function mint(address account, uint256 amount)\n    public\n    onlyMinter\n    returns (bool)\n  {\n    _mint(account, amount);\n    return true;\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/GovernedMinterRole.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {INexus} from \"../interfaces/INexus.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title  GovernedMinterRole\n * @author OpenZeppelin (forked from @openzeppelin/contracts/access/roles/MinterRole.sol)\n *         Update 2021/08/19 MinterRole.sol has been removed, AccessControl.sol is used instead.\n * @dev    Forked from OpenZeppelin 'MinterRole' with changes:\n *          - `addMinter` modified from `onlyMinter` to `onlyGovernor`\n *          - `removeMinter` function added, callable by `onlyGovernor`\n */\nabstract contract GovernedMinterRole is ImmutableModule, AccessControl {\n  event MinterAdded(address indexed account);\n  event MinterRemoved(address indexed account);\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor(address _nexus) ImmutableModule(_nexus) {\n    _setupRole(DEFAULT_ADMIN_ROLE, INexus(_nexus).governor());\n  }\n\n  modifier onlyMinter() {\n    require(\n      isMinter(msg.sender),\n      \"MinterRole: caller does not have the Minter role\"\n    );\n    _;\n  }\n\n  function isMinter(address account) public view returns (bool) {\n    return hasRole(MINTER_ROLE, account);\n  }\n\n  function addMinter(address account) public onlyGovernor {\n    _addMinter(account);\n  }\n\n  function removeMinter(address account) public onlyGovernor {\n    _removeMinter(account);\n  }\n\n  function renounceMinter() public onlyMinter {\n    _renounceMinter(msg.sender);\n  }\n\n  function _addMinter(address account) internal {\n    grantRole(MINTER_ROLE, account);\n    emit MinterAdded(account);\n  }\n\n  function _removeMinter(address account) internal {\n    revokeRole(MINTER_ROLE, account);\n    emit MinterRemoved(account);\n  }\n\n  function _renounceMinter(address account) internal {\n    renounceRole(MINTER_ROLE, account);\n    emit MinterRemoved(account);\n  }\n}\n"
    },
    "contracts/ppo-staking/nexus/Nexus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {INexus} from \"../interfaces/INexus.sol\";\nimport {Governable} from \"../governance/Governable.sol\";\nimport {DelayedClaimableGovernor} from \"../governance/DelayedClaimableGovernor.sol\";\n\n/**\n * @title   Nexus\n * @author  mStable\n * @notice  Address provider and system kernel, also facilitates governance changes\n * @dev     The Nexus is mStable's Kernel, and allows the publishing and propagating\n *          of new system Modules. Other Modules will read from the Nexus\n *          VERSION: 3.0\n *          DATE:    2021-04-15\n */\ncontract Nexus is INexus, DelayedClaimableGovernor {\n  event ModuleProposed(bytes32 indexed key, address addr, uint256 timestamp);\n  event ModuleAdded(bytes32 indexed key, address addr, bool isLocked);\n  event ModuleCancelled(bytes32 indexed key);\n  event ModuleLockRequested(bytes32 indexed key, uint256 timestamp);\n  event ModuleLockEnabled(bytes32 indexed key);\n  event ModuleLockCancelled(bytes32 indexed key);\n\n  /** @dev Struct to store information about current modules */\n  struct Module {\n    address addr; // Module address\n    bool isLocked; // Module lock status\n  }\n\n  /** @dev Struct to store information about proposed modules */\n  struct Proposal {\n    address newAddress; // Proposed Module address\n    uint256 timestamp; // Timestamp when module upgrade was proposed\n  }\n\n  // 1 week delayed upgrade period\n  uint256 public constant UPGRADE_DELAY = 1 weeks;\n\n  // Module-key => Module\n  mapping(bytes32 => Module) public modules;\n  // Module-address => Module-key\n  mapping(address => bytes32) private addressToModule;\n  // Module-key => Proposal\n  mapping(bytes32 => Proposal) public proposedModules;\n  // Module-key => Timestamp when lock was proposed\n  mapping(bytes32 => uint256) public proposedLockModules;\n\n  // Init flag to allow add modules at the time of deplyment without delay\n  bool public initialized = false;\n\n  /**\n   * @dev Modifier allows functions calls only when contract is not initialized.\n   */\n  modifier whenNotInitialized() {\n    require(!initialized, \"Nexus is already initialized\");\n    _;\n  }\n\n  /**\n   * @dev Initialises the Nexus and adds the core data to the Kernel (itself and governor)\n   * @param _governorAddr Governor address\n   */\n  constructor(address _governorAddr)\n    DelayedClaimableGovernor(_governorAddr, UPGRADE_DELAY)\n  {}\n\n  // FIXME can this function be avoided as it just calls the super function\n  function governor()\n    public\n    view\n    override(Governable, INexus)\n    returns (address)\n  {\n    return super.governor();\n  }\n\n  /**\n   * @dev Adds multiple new modules to the system to initialize the\n   *      Nexus contract with default modules. This should be called first\n   *      after deploying Nexus contract.\n   * @param _keys         Keys of the new modules in bytes32 form\n   * @param _addresses    Contract addresses of the new modules\n   * @param _isLocked     IsLocked flag for the new modules\n   * @param _governorAddr New Governor address\n   * @return bool         Success of publishing new Modules\n   */\n  function initialize(\n    bytes32[] calldata _keys,\n    address[] calldata _addresses,\n    bool[] calldata _isLocked,\n    address _governorAddr\n  ) external onlyGovernor whenNotInitialized returns (bool) {\n    uint256 len = _keys.length;\n    require(len > 0, \"No keys provided\");\n    require(len == _addresses.length, \"Insufficient address data\");\n    require(len == _isLocked.length, \"Insufficient locked statuses\");\n\n    for (uint256 i = 0; i < len; i++) {\n      _publishModule(_keys[i], _addresses[i], _isLocked[i]);\n    }\n\n    if (_governorAddr != governor()) _changeGovernor(_governorAddr);\n\n    initialized = true;\n    return true;\n  }\n\n  /***************************************\n                MODULE ADDING\n    ****************************************/\n\n  /**\n   * @dev Propose a new or update existing module\n   * @param _key  Key of the module\n   * @param _addr Address of the module\n   */\n  function proposeModule(bytes32 _key, address _addr)\n    external\n    override\n    onlyGovernor\n  {\n    require(_key != bytes32(0x0), \"Key must not be zero\");\n    require(_addr != address(0), \"Module address must not be 0\");\n    require(!modules[_key].isLocked, \"Module must be unlocked\");\n    require(modules[_key].addr != _addr, \"Module already has same address\");\n    Proposal storage p = proposedModules[_key];\n    require(p.timestamp == 0, \"Module already proposed\");\n\n    p.newAddress = _addr;\n    p.timestamp = block.timestamp;\n    emit ModuleProposed(_key, _addr, block.timestamp);\n  }\n\n  /**\n   * @dev Cancel a proposed module request\n   * @param _key Key of the module\n   */\n  function cancelProposedModule(bytes32 _key) external override onlyGovernor {\n    uint256 timestamp = proposedModules[_key].timestamp;\n    require(timestamp > 0, \"Proposed module not found\");\n\n    delete proposedModules[_key];\n    emit ModuleCancelled(_key);\n  }\n\n  /**\n   * @dev Accept and publish an already proposed module\n   * @param _key Key of the module\n   */\n  function acceptProposedModule(bytes32 _key) external override onlyGovernor {\n    _acceptProposedModule(_key);\n  }\n\n  /**\n   * @dev Accept and publish already proposed modules\n   * @param _keys Keys array of the modules\n   */\n  function acceptProposedModules(bytes32[] calldata _keys)\n    external\n    override\n    onlyGovernor\n  {\n    uint256 len = _keys.length;\n    require(len > 0, \"Keys array empty\");\n\n    for (uint256 i = 0; i < len; i++) {\n      _acceptProposedModule(_keys[i]);\n    }\n  }\n\n  /**\n   * @dev Accept a proposed module\n   * @param _key Key of the module\n   */\n  function _acceptProposedModule(bytes32 _key) internal {\n    Proposal memory p = proposedModules[_key];\n    require(_isDelayOver(p.timestamp), \"Module upgrade delay not over\");\n\n    delete proposedModules[_key];\n    _publishModule(_key, p.newAddress, false);\n  }\n\n  /**\n   * @dev Internal func to publish a module to kernel\n   * @param _key      Key of the new module in bytes32 form\n   * @param _addr     Contract address of the new module\n   * @param _isLocked Flag to lock a module\n   */\n  function _publishModule(\n    bytes32 _key,\n    address _addr,\n    bool _isLocked\n  ) internal {\n    require(\n      addressToModule[_addr] == bytes32(0x0),\n      \"Modules must have unique addr\"\n    );\n    require(!modules[_key].isLocked, \"Module must be unlocked\");\n    // Old no longer points to a moduleAddress\n    address oldModuleAddr = modules[_key].addr;\n    if (oldModuleAddr != address(0x0)) {\n      addressToModule[oldModuleAddr] = bytes32(0x0);\n    }\n    modules[_key].addr = _addr;\n    modules[_key].isLocked = _isLocked;\n    addressToModule[_addr] = _key;\n    emit ModuleAdded(_key, _addr, _isLocked);\n  }\n\n  /***************************************\n                MODULE LOCKING\n    ****************************************/\n\n  /**\n   * @dev Request to lock an existing module\n   * @param _key Key of the module\n   */\n  function requestLockModule(bytes32 _key) external override onlyGovernor {\n    require(moduleExists(_key), \"Module must exist\");\n    require(!modules[_key].isLocked, \"Module must be unlocked\");\n    require(proposedLockModules[_key] == 0, \"Lock already proposed\");\n\n    proposedLockModules[_key] = block.timestamp;\n    emit ModuleLockRequested(_key, block.timestamp);\n  }\n\n  /**\n   * @dev Cancel a lock module request\n   * @param _key Key of the module\n   */\n  function cancelLockModule(bytes32 _key) external override onlyGovernor {\n    require(proposedLockModules[_key] > 0, \"Module lock request not found\");\n\n    delete proposedLockModules[_key];\n    emit ModuleLockCancelled(_key);\n  }\n\n  /**\n   * @dev Permanently lock a module to its current settings\n   * @param _key Bytes32 key of the module\n   */\n  function lockModule(bytes32 _key) external override onlyGovernor {\n    require(_isDelayOver(proposedLockModules[_key]), \"Delay not over\");\n\n    modules[_key].isLocked = true;\n    delete proposedLockModules[_key];\n    emit ModuleLockEnabled(_key);\n  }\n\n  /***************************************\n                HELPERS & GETTERS\n    ****************************************/\n\n  /**\n   * @dev Checks if a module exists\n   * @param _key  Key of the module\n   * @return      Returns 'true' when a module exists, otherwise 'false'\n   */\n  function moduleExists(bytes32 _key) public view returns (bool) {\n    if (_key != 0 && modules[_key].addr != address(0)) return true;\n    return false;\n  }\n\n  /**\n   * @dev Get the module address\n   * @param _key  Key of the module\n   * @return addr Return the address of the module\n   */\n  function getModule(bytes32 _key)\n    external\n    view\n    override\n    returns (address addr)\n  {\n    addr = modules[_key].addr;\n  }\n\n  /**\n   * @dev Checks if upgrade delay over\n   * @param _timestamp    Timestamp to check\n   * @return              Return 'true' when delay is over, otherwise 'false'\n   */\n  function _isDelayOver(uint256 _timestamp) private view returns (bool) {\n    if (_timestamp > 0 && block.timestamp >= _timestamp + UPGRADE_DELAY)\n      return true;\n    return false;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @title   Governable\n * @author  mStable\n * @notice  Simple contract implementing an Ownable pattern.\n * @dev     Derives from V2.3.0 @openzeppelin/contracts/ownership/Ownable.sol\n *          Modified to have custom name and features\n *              - Removed `renounceOwnership`\n *              - Changes `_owner` to `_governor`\n *          VERSION: 1.1\n *          DATE:    2021-04-15\n */\ncontract Governable {\n  event GovernorChanged(\n    address indexed previousGovernor,\n    address indexed newGovernor\n  );\n\n  address private _governor;\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial Governor.\n   */\n  constructor() {\n    _governor = msg.sender;\n    emit GovernorChanged(address(0), _governor);\n  }\n\n  /**\n   * @dev Returns the address of the current Governor.\n   */\n  function governor() public view virtual returns (address) {\n    return _governor;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the Governor.\n   */\n  modifier onlyGovernor() {\n    require(isGovernor(), \"GOV: caller is not the Governor\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current Governor.\n   */\n  function isGovernor() public view returns (bool) {\n    return msg.sender == _governor;\n  }\n\n  /**\n   * @dev Transfers Governance of the contract to a new account (`newGovernor`).\n   * Can only be called by the current Governor.\n   * @param _newGovernor Address of the new Governor\n   */\n  function changeGovernor(address _newGovernor) external virtual onlyGovernor {\n    _changeGovernor(_newGovernor);\n  }\n\n  /**\n   * @dev Change Governance of the contract to a new account (`newGovernor`).\n   * @param _newGovernor Address of the new Governor\n   */\n  function _changeGovernor(address _newGovernor) internal {\n    require(_newGovernor != address(0), \"GOV: new Governor is address(0)\");\n    emit GovernorChanged(_governor, _newGovernor);\n    _governor = _newGovernor;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/DelayedClaimableGovernor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ClaimableGovernor} from \"./ClaimableGovernor.sol\";\n\n/**\n * @title   DelayedClaimableGovernor\n * @author  mStable\n * @notice  Current Governor can initiate governance change request.\n *          After a defined delay, proposed Governor can claim governance\n *          ownership.\n *          VERSION: 1.1\n *          DATE:    2021-04-15\n */\ncontract DelayedClaimableGovernor is ClaimableGovernor {\n  uint256 public delay = 0;\n  uint256 public requestTime = 0;\n\n  /**\n   * @dev Initializes the contract with given delay\n   * @param _governorAddr Initial governor\n   * @param _delay    Delay in seconds for 2 way handshake\n   */\n  constructor(address _governorAddr, uint256 _delay)\n    ClaimableGovernor(_governorAddr)\n  {\n    require(_delay > 0, \"Delay must be greater than zero\");\n    delay = _delay;\n  }\n\n  /**\n   * @dev Requests change of governor and logs request time\n   * @param _proposedGovernor Address of the new governor\n   */\n  function requestGovernorChange(address _proposedGovernor)\n    public\n    override\n    onlyGovernor\n  {\n    requestTime = block.timestamp;\n    super.requestGovernorChange(_proposedGovernor);\n  }\n\n  /**\n   * @dev Cancels an outstanding governor change request by resetting request time\n   */\n  function cancelGovernorChange() public override onlyGovernor {\n    requestTime = 0;\n    super.cancelGovernorChange();\n  }\n\n  /**\n   * @dev Proposed governor claims new position, callable after time elapsed\n   */\n  function claimGovernorChange() public override onlyProposedGovernor {\n    require(block.timestamp >= (requestTime + delay), \"Delay not over\");\n    super.claimGovernorChange();\n    requestTime = 0;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/ClaimableGovernor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Governable} from \"./Governable.sol\";\n\n/**\n * @title   ClaimableGovernor\n * @author  mStable\n * @notice  2 way handshake for Governance transfer\n * @dev     Overrides the public functions in Governable to provide\n * a second step of validation.\n *          VERSION: 1.1\n *          DATE:    2021-04-15\n */\ncontract ClaimableGovernor is Governable {\n  event GovernorChangeClaimed(address indexed proposedGovernor);\n  event GovernorChangeCancelled(\n    address indexed governor,\n    address indexed proposed\n  );\n  event GovernorChangeRequested(\n    address indexed governor,\n    address indexed proposed\n  );\n\n  address public proposedGovernor = address(0);\n\n  /**\n   * @dev Throws if called by any account other than the Proposed Governor.\n   */\n  modifier onlyProposedGovernor() {\n    require(msg.sender == proposedGovernor, \"Sender is not proposed governor\");\n    _;\n  }\n\n  constructor(address _governorAddr) {\n    _changeGovernor(_governorAddr);\n  }\n\n  // @override\n  function changeGovernor(address) external view override onlyGovernor {\n    revert(\"Direct change not allowed\");\n  }\n\n  /**\n   * @dev Current Governor request to proposes a new Governor\n   * @param _proposedGovernor Address of the proposed Governor\n   */\n  function requestGovernorChange(address _proposedGovernor)\n    public\n    virtual\n    onlyGovernor\n  {\n    require(\n      _proposedGovernor != address(0),\n      \"Proposed governor is address(0)\"\n    );\n    require(proposedGovernor == address(0), \"Proposed governor already set\");\n\n    proposedGovernor = _proposedGovernor;\n    emit GovernorChangeRequested(governor(), _proposedGovernor);\n  }\n\n  /**\n   * @dev Current Governor cancel Governor change request\n   */\n  function cancelGovernorChange() public virtual onlyGovernor {\n    require(proposedGovernor != address(0), \"Proposed Governor not set\");\n\n    emit GovernorChangeCancelled(governor(), proposedGovernor);\n    proposedGovernor = address(0);\n  }\n\n  /**\n   * @dev Proposed Governor can claim governance ownership\n   */\n  function claimGovernorChange() public virtual onlyProposedGovernor {\n    _changeGovernor(proposedGovernor);\n    emit GovernorChangeClaimed(proposedGovernor);\n    proposedGovernor = address(0);\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockGovernable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Governable} from \"../../governance/Governable.sol\";\n\ncontract MockGovernable is Governable {}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/ppo-staking/shared/@openzeppelin/InstantProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract InstantProxyAdmin is ProxyAdmin {}\n"
    },
    "contracts/ppo-staking/governance/staking/WithdrawalRights.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract WithdrawalRights is SafeOwnable, ERC721 {\n  uint256 private _id;\n  string private _uri;\n  address private _ppoStaking;\n\n  modifier onlyPPOStaking() {\n    require(msg.sender == _ppoStaking, \"msg.sender != PPOStaking\");\n    _;\n  }\n\n  constructor() ERC721(\"Staked PPO Withdrawal Rights\", \"stkPPO-WR\") {}\n\n  function setURI(string memory _newURI) external onlyOwner {\n    _uri = _newURI;\n  }\n\n  function setPPOStaking(address _newPPOStaking) external onlyOwner {\n    _ppoStaking = _newPPOStaking;\n  }\n\n  function mint(address _to) external onlyPPOStaking {\n    _safeMint(_to, _id++);\n  }\n\n  // solhint-disable-next-line no-unused-vars\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    override\n    returns (string memory)\n  {\n    return _uri;\n  }\n\n  function getPPOStaking() external view returns (address) {\n    return _ppoStaking;\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/ERC1155Mintable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract ERC1155Mintable is ERC1155, SafeOwnable {\n  constructor(string memory _newUri) ERC1155(_newUri) {}\n\n  function mint(\n    address _recipient,\n    uint256 _id,\n    uint256 _amount\n  ) external onlyOwner {\n    _mint(_recipient, _id, _amount, \"\");\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/ppo-staking/emissions/EmissionsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IGovernanceHook} from \"../governance/staking/interfaces/IGovernanceHook.sol\";\nimport {IRewardsDistributionRecipient} from \"../interfaces/IRewardsDistributionRecipient.sol\";\nimport {IVotes} from \"../interfaces/IVotes.sol\";\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nstruct HistoricVotes {\n  // Number of votes directed to this dial\n  uint128 votes;\n  // The start of the distribution period in seconds divided by 604,800 seconds in a week\n  uint32 epoch;\n}\n\nstruct DialData {\n  // If true, no rewards are distributed to the dial recipient and any votes on this dial are ignored\n  bool disabled;\n  // If true, `notifyRewardAmount` on the recipient contract is called\n  bool notify;\n  // Cap on distribution % where 1% = 1\n  uint8 cap;\n  // Dial rewards that are waiting to be distributed to recipient\n  uint96 balance;\n  // Account rewards are distributed to\n  address recipient;\n  // List of weighted votes in each distribution period\n  HistoricVotes[] voteHistory;\n}\n\nstruct Preference {\n  // ID of the dial (array position)\n  uint256 dialId;\n  // % weight applied to this dial, where 200 = 100% and 1 = 0.5%\n  uint256 weight;\n}\n\nstruct VoterPreferences {\n  // A array of 16 Preferences, which contain a dialId and weight of 8 bits each.\n  // That's 16 bits per item, which is 16 * 16 = 256 bits = 1 slot.\n  // The first item, index 0, is right ended.\n  // Each item is a dialId and weight.\n  // The array is stored as a uint256\n  uint256 dialWeights;\n  // Total voting power cast by this voter across the staking contracts.\n  uint128 votesCast;\n  // Last time balance was looked up across all staking contracts\n  uint32 lastSourcePoke;\n}\n\nstruct TopLevelConfig {\n  int256 A;\n  int256 B;\n  int256 C;\n  int256 D;\n  uint128 EPOCHS;\n}\n\nstruct EpochHistory {\n  // First weekly epoch of this contract.\n  uint32 startEpoch;\n  // The last weekly epoch to have rewards distributed.\n  uint32 lastEpoch;\n}\n\n/**\n * @title  EmissionsController\n * @author mStable\n * @notice Allows governors to vote on the weekly distribution of $MTA. Rewards are distributed between\n *         `n` \"Dials\" proportionately to the % of votes the dial receives. Vote weight derives from multiple\n *         whitelisted \"Staking contracts\". Voters can distribute their vote across (0 <= n <= 16 dials), at 0.5%\n *         increments in voting weight. Once their preferences are cast, each time their voting weight changes\n *         it is reflected here through a hook.\n * @dev    VERSION: 1.0\n *         DATE:    2021-10-28\n */\ncontract EmissionsController is\n  IGovernanceHook,\n  Initializable,\n  ImmutableModule\n{\n  using SafeERC20 for IERC20;\n\n  /// @notice Minimum time between distributions.\n  uint32 constant DISTRIBUTION_PERIOD = 1 weeks;\n  /// @notice Scale of dial weights. 200 = 100%, 2 = 1%, 1 = 0.5%\n  uint256 constant SCALE = 200;\n  /// @notice Polynomial top level emission function parameters\n  int256 immutable A;\n  int256 immutable B;\n  int256 immutable C;\n  int256 immutable D;\n  uint128 immutable EPOCHS;\n\n  /// @notice Address of rewards token. ie MTA token\n  IERC20 public immutable REWARD_TOKEN;\n\n  /// @notice Epoch history in storage\n  ///         An epoch is the number of weeks since 1 Jan 1970. The week starts on Thursday 00:00 UTC.\n  ///         epoch = start of the distribution period in seconds divided by 604,800 seconds in a week\n  EpochHistory public epochs;\n\n  /// @notice Flags the timestamp that a given staking contract was added\n  mapping(address => uint32) public stakingContractAddTime;\n  /// @notice List of staking contract addresses.\n  IVotes[] public stakingContracts;\n\n  /// @notice List of dial data including votes, rewards balance, recipient contract and disabled flag.\n  DialData[] public dials;\n\n  /// @notice Mapping of staker addresses to an list of voter dial weights.\n  /// @dev    The sum of the weights for each staker must not be greater than SCALE = 200.\n  ///         A user can issue a subset of their voting power. eg only 20% of their voting power.\n  ///         A user can not issue more than 100% of their voting power across dials.\n  mapping(address => VoterPreferences) public voterPreferences;\n\n  event AddedDial(uint256 indexed dialId, address indexed recipient);\n  event UpdatedDial(uint256 indexed dialId, bool disabled, bool _notify);\n  event AddStakingContract(address indexed stakingContract);\n\n  event PeriodRewards(uint256[] amounts);\n  event DonatedRewards(uint256 indexed dialId, uint256 amount);\n  event DistributedReward(uint256 indexed dialId, uint256 amount);\n\n  event PreferencesChanged(address indexed voter, Preference[] preferences);\n  event VotesCast(\n    address stakingContract,\n    address indexed from,\n    address indexed to,\n    uint256 amount\n  );\n  event SourcesPoked(address indexed voter, uint256 newVotesCast);\n\n  /***************************************\n                    INIT\n    ****************************************/\n\n  /**\n   * @notice Recipient is a module, governed by mStable governance.\n   * @param _nexus        System Nexus that resolves module addresses.\n   * @param _rewardToken  Token that rewards are distributed in. eg MTA.\n   * @param _config       Arguments for polynomial top level emission function (raw, not scaled).\n   */\n  constructor(\n    address _nexus,\n    address _rewardToken,\n    TopLevelConfig memory _config\n  ) ImmutableModule(_nexus) {\n    require(_rewardToken != address(0), \"Reward token address is zero\");\n    REWARD_TOKEN = IERC20(_rewardToken);\n    A = _config.A * 1e3;\n    B = _config.B * 1e3;\n    C = _config.C * 1e3;\n    D = _config.D * 1e3;\n    EPOCHS = _config.EPOCHS;\n  }\n\n  /**\n   * @dev Initialisation function to configure the first dials. All recipient contracts with _notifies = true need to\n   *      implement the `IRewardsDistributionRecipient` interface.\n   * @param _recipients        List of dial contract addresses that can receive rewards.\n   * @param _caps              Limit on the percentage of the weekly top line emission the corresponding dial can receive (where 10% = 10 and uncapped = 0).\n   * @param _notifies          If true, `notifyRewardAmount` is called in the `distributeRewards` function.\n   * @param _stakingContracts  Initial staking contracts used for voting power lookup.\n   */\n  function initialize(\n    address[] memory _recipients,\n    uint8[] memory _caps,\n    bool[] memory _notifies,\n    address[] memory _stakingContracts\n  ) external initializer {\n    uint256 len = _recipients.length;\n    require(\n      _notifies.length == len && _caps.length == len,\n      \"Initialize args mismatch\"\n    );\n\n    // 1.0 - Set the last epoch storage variable to the immutable start epoch\n    //       Set the weekly epoch this contract starts distributions which will be 1 - 2 week after deployment.\n    uint32 startEpoch = _epoch(block.timestamp) + 1;\n    epochs = EpochHistory({startEpoch: startEpoch, lastEpoch: startEpoch});\n\n    // 2.0 - Add each of the dials\n    for (uint256 i = 0; i < len; i++) {\n      _addDial(_recipients[i], _caps[i], _notifies[i]);\n    }\n\n    // 3.0 - Initialize the staking contracts\n    for (uint256 i = 0; i < _stakingContracts.length; i++) {\n      _addStakingContract(_stakingContracts[i]);\n    }\n  }\n\n  /***************************************\n                    VIEW\n    ****************************************/\n\n  /**\n   * @notice Gets the users aggregate voting power across all voting contracts.\n   * @dev    Voting power can be from staking or it could be delegated to the account.\n   * @param account       For which to fetch voting power.\n   * @return votingPower  Units of voting power owned by account.\n   */\n  function getVotes(address account)\n    public\n    view\n    returns (uint256 votingPower)\n  {\n    // For each configured staking contract\n    for (uint256 i = 0; i < stakingContracts.length; i++) {\n      votingPower += stakingContracts[i].getVotes(account);\n    }\n  }\n\n  /**\n   * @notice Calculates top line distribution amount for the current epoch as per the polynomial.\n   *          (f(x)=A*(x/div)^3+B*(x/div)^2+C*(x/div)+D)\n   * @dev    Values are effectively scaled to 1e12 to avoid integer overflow on pow.\n   * @param epoch              The number of weeks since 1 Jan 1970.\n   * @return emissionForEpoch  Units of MTA to be distributed at this epoch.\n   */\n  function topLineEmission(uint32 epoch)\n    public\n    view\n    returns (uint256 emissionForEpoch)\n  {\n    require(\n      epochs.startEpoch < epoch && epoch <= epochs.startEpoch + 312,\n      \"Wrong epoch number\"\n    );\n    // e.g. week 1, A = -166000e12, B = 168479942061125e3, C = -168479942061125e3, D = 166000e12\n    // e.g. epochDelta = 1\n    uint128 epochDelta = (epoch - epochs.startEpoch);\n    // e.g. x = 1e12 / 312 = 3205128205\n    int256 x = SafeCast.toInt256((epochDelta * 1e12) / EPOCHS);\n    emissionForEpoch =\n      SafeCast.toUint256(\n        ((A * (x**3)) / 1e36) + // e.g. -166000e12         * (3205128205 ^ 3) / 1e36 = -5465681315\n          ((B * (x**2)) / 1e24) + // e.g.  168479942061125e3 * (3205128205 ^ 2) / 1e24 =  1730768635433\n          ((C * (x)) / 1e12) + // e.g. -168479942061125e3 *  3205128205      / 1e12 = -539999814276877\n          D // e.g.  166000e12\n      ) *\n      1e6; // e.g. SUM = 165461725488677241 * 1e6 = 165461e18\n  }\n\n  /**\n   * @notice Gets a dial's recipient address.\n   * @param dialId      Dial identifier starting from 0.\n   * @return recipient  Address of the recipient account associated with.\n   */\n  function getDialRecipient(uint256 dialId)\n    public\n    view\n    returns (address recipient)\n  {\n    recipient = dials[dialId].recipient;\n  }\n\n  /**\n   * @notice Gets a dial's weighted votes for each distribution period.\n   * @param dialId        Dial identifier starting from 0.\n   * @return voteHistory  List of weighted votes with the first distribution at index 0.\n   */\n  function getDialVoteHistory(uint256 dialId)\n    public\n    view\n    returns (HistoricVotes[] memory voteHistory)\n  {\n    voteHistory = dials[dialId].voteHistory;\n  }\n\n  /**\n   * @notice Gets the latest weighted votes for each dial.\n   *         This will include disabled dials and their current weighted votes.\n   * @return dialVotes A list of dial weighted votes. The index of the array is the dialId.\n   */\n  function getDialVotes() public view returns (uint256[] memory dialVotes) {\n    uint256 dialLen = dials.length;\n    dialVotes = new uint256[](dialLen);\n\n    for (uint256 i = 0; i < dialLen; i++) {\n      DialData memory dialData = dials[i];\n\n      uint256 voteHistoryLen = dialData.voteHistory.length;\n\n      // If no distributions for this dial yet\n      if (voteHistoryLen == 0) {\n        continue;\n      }\n\n      dialVotes[i] = dialData.voteHistory[voteHistoryLen - 1].votes;\n    }\n  }\n\n  /**\n   * @notice Gets a voter's weights for each dial.\n   * @dev    A dial identifier of 255 marks the end  of the array. It should be ignored.\n   * @param voter         Address of the voter that has set weights.\n   * @return preferences  List of dial identifiers and weights where a weight of 100% = 200.\n   */\n  function getVoterPreferences(address voter)\n    public\n    view\n    returns (Preference[16] memory preferences)\n  {\n    for (uint256 i = 0; i < 16; i++) {\n      preferences[i].weight = uint8(\n        voterPreferences[voter].dialWeights >> (i * 16)\n      );\n      preferences[i].dialId = uint8(\n        voterPreferences[voter].dialWeights >> ((i * 16) + 8)\n      );\n    }\n  }\n\n  /***************************************\n                    ADMIN\n    ****************************************/\n\n  /**\n   * @notice Adds a new dial that can be voted on to receive weekly rewards. Callable by system governor.\n   * @param _recipient  Address of the contract that will receive rewards.\n   * @param _cap        Cap where 0 = uncapped and 10 = 10%.\n   * @param _notify     If true, `notifyRewardAmount` is called in the `distributeRewards` function.\n   */\n  function addDial(\n    address _recipient,\n    uint8 _cap,\n    bool _notify\n  ) external onlyGovernor {\n    _addDial(_recipient, _cap, _notify);\n  }\n\n  /**\n   * @dev Internal dial addition fn, see parent fn for details.\n   */\n  function _addDial(\n    address _recipient,\n    uint8 _cap,\n    bool _notify\n  ) internal {\n    require(_recipient != address(0), \"Dial address is zero\");\n    require(_cap < 100, \"Invalid cap\");\n\n    uint256 len = dials.length;\n    require(len < 254, \"Max dial count reached\");\n    for (uint256 i = 0; i < len; i++) {\n      require(dials[i].recipient != _recipient, \"Dial already exists\");\n    }\n\n    dials.push();\n    DialData storage newDialData = dials[len];\n    newDialData.recipient = _recipient;\n    newDialData.notify = _notify;\n    newDialData.cap = _cap;\n    uint32 currentEpoch = _epoch(block.timestamp);\n    if (currentEpoch < epochs.startEpoch) {\n      currentEpoch = epochs.startEpoch;\n    }\n    newDialData.voteHistory.push(\n      HistoricVotes({votes: 0, epoch: currentEpoch})\n    );\n\n    emit AddedDial(len, _recipient);\n  }\n\n  /**\n   * @notice Updates a dials recipient contract and/or disabled flag.\n   * @param _dialId    Dial identifier which is the index of the dials array.\n   * @param _disabled  If true, no rewards will be distributed to this dial.\n   * @param _notify  If true, `notifyRewardAmount` is called on the dial recipient contract.\n   */\n  function updateDial(\n    uint256 _dialId,\n    bool _disabled,\n    bool _notify\n  ) external onlyGovernor {\n    require(_dialId < dials.length, \"Invalid dial id\");\n\n    dials[_dialId].disabled = _disabled;\n    dials[_dialId].notify = _notify;\n\n    emit UpdatedDial(_dialId, _disabled, _notify);\n  }\n\n  /**\n   * @notice Adds a new contract to the list of approved staking contracts.\n   * @param _stakingContract Address of the new staking contract\n   */\n  function addStakingContract(address _stakingContract) external onlyGovernor {\n    _addStakingContract(_stakingContract);\n  }\n\n  /**\n   * @dev Adds a staking contract by setting it's addition time to current timestamp.\n   */\n  function _addStakingContract(address _stakingContract) internal {\n    require(\n      _stakingContract != address(0),\n      \"Staking contract address is zero\"\n    );\n\n    uint256 len = stakingContracts.length;\n    for (uint256 i = 0; i < len; i++) {\n      require(\n        address(stakingContracts[i]) != _stakingContract,\n        \"StakingContract already exists\"\n      );\n    }\n\n    stakingContractAddTime[_stakingContract] = SafeCast.toUint32(\n      block.timestamp\n    );\n    stakingContracts.push(IVotes(_stakingContract));\n\n    emit AddStakingContract(_stakingContract);\n  }\n\n  /***************************************\n                REWARDS-EXTERNAL\n    ****************************************/\n\n  /**\n   * @notice Allows arbitrary reward donation to a dial on top of the weekly rewards.\n   * @param _dialIds  Dial identifiers that will receive donated rewards.\n   * @param _amounts  Units of rewards to be sent to each dial including decimals.\n   */\n  function donate(uint256[] memory _dialIds, uint256[] memory _amounts)\n    external\n  {\n    uint256 dialLen = _dialIds.length;\n    require(dialLen > 0 && _amounts.length == dialLen, \"Invalid inputs\");\n\n    uint256 totalAmount;\n\n    // For each specified dial\n    uint256 dialId;\n    for (uint256 i = 0; i < dialLen; i++) {\n      dialId = _dialIds[i];\n      require(dialId < dials.length, \"Invalid dial id\");\n\n      // Sum the rewards for each dial\n      totalAmount += _amounts[i];\n      // Add rewards to the dial's rewards balance\n      dials[dialId].balance += SafeCast.toUint96(_amounts[i]);\n\n      emit DonatedRewards(dialId, _amounts[i]);\n    }\n\n    // Transfer the total donated rewards to this Emissions Controller contract\n    REWARD_TOKEN.safeTransferFrom(msg.sender, address(this), totalAmount);\n  }\n\n  /**\n   * @notice Calculates the rewards to be distributed to each dial for the next weekly period.\n   * @dev    Callable once an epoch has fully passed. Top level emission for the epoch is distributed\n   *         proportionately to vote count with the following exceptions:\n   *          - Disabled dials are ignored and votes not counted.\n   *          - Dials with a cap are capped and their votes/emission removed (effectively redistributing rewards).\n   */\n  function calculateRewards() external {\n    // 1 - Calculate amount of rewards to distribute this week\n    uint32 epoch = _epoch(block.timestamp);\n    require(epoch > epochs.lastEpoch, \"Must wait for new period\");\n    //     Update storage with new last epoch\n    epochs.lastEpoch = epoch;\n    uint256 emissionForEpoch = topLineEmission(epoch);\n\n    // 2.0 - Calculate the total amount of dial votes ignoring any disabled dials\n    uint256 totalDialVotes;\n    uint256 dialLen = dials.length;\n    uint256[] memory dialVotes = new uint256[](dialLen);\n    for (uint256 i = 0; i < dialLen; i++) {\n      DialData memory dialData = dials[i];\n      if (dialData.disabled) continue;\n\n      // Get the relevant votes for the dial. Possibilities:\n      //   - No new votes cast in period, therefore relevant votes are at pos len - 1\n      //   - Votes already cast in period, therefore relevant is at pos len - 2\n      uint256 end = dialData.voteHistory.length - 1;\n      HistoricVotes memory latestVote = dialData.voteHistory[end];\n      if (latestVote.epoch < epoch) {\n        dialVotes[i] = latestVote.votes;\n        totalDialVotes += latestVote.votes;\n        // Create a new weighted votes for the current distribution period\n        dials[i].voteHistory.push(\n          HistoricVotes({\n            votes: latestVote.votes,\n            epoch: SafeCast.toUint32(epoch)\n          })\n        );\n      } else if (latestVote.epoch == epoch && end > 0) {\n        uint256 votes = dialData.voteHistory[end - 1].votes;\n        dialVotes[i] = votes;\n        totalDialVotes += votes;\n      }\n    }\n\n    // 3.0 - Deal with the capped dials\n    uint256[] memory distributionAmounts = new uint256[](dialLen);\n    uint256 postCappedVotes = totalDialVotes;\n    uint256 postCappedEmission = emissionForEpoch;\n    for (uint256 k = 0; k < dialLen; k++) {\n      DialData memory dialData = dials[k];\n      // 3.1 - If the dial has a cap and isn't disabled, check if it's over the threshold\n      if (dialData.cap > 0 && !dialData.disabled) {\n        uint256 maxVotes = (dialData.cap * totalDialVotes) / 100;\n        // If dial has more votes than its cap\n        if (dialVotes[k] > maxVotes) {\n          // Calculate amount of rewards for the dial\n          distributionAmounts[k] = (dialData.cap * emissionForEpoch) / 100;\n          // Add dial rewards to balance in storage.\n          // Is addition and not set as rewards could have been donated.\n          dials[k].balance += SafeCast.toUint96(distributionAmounts[k]);\n\n          // Remove dial votes from total votes\n          postCappedVotes -= dialVotes[k];\n          // Remove capped rewards from total reward\n          postCappedEmission -= distributionAmounts[k];\n          // Set to zero votes so it'll be skipped in the next loop\n          dialVotes[k] = 0;\n        }\n      }\n    }\n\n    // 4.0 - Calculate the distribution amounts for each dial\n    for (uint256 l = 0; l < dialLen; l++) {\n      // Skip dial if no votes, disabled or was over cap\n      if (dialVotes[l] == 0) {\n        continue;\n      }\n\n      // Calculate amount of rewards for the dial & set storage\n      distributionAmounts[l] =\n        (dialVotes[l] * postCappedEmission) /\n        postCappedVotes;\n      dials[l].balance += SafeCast.toUint96(distributionAmounts[l]);\n    }\n\n    emit PeriodRewards(distributionAmounts);\n  }\n\n  /**\n   * @notice Transfers all accrued rewards to dials and notifies them of the amount.\n   * @param _dialIds  Dial identifiers for which to distribute rewards.\n   */\n  function distributeRewards(uint256[] memory _dialIds) external {\n    // For each specified dial\n    uint256 len = _dialIds.length;\n    for (uint256 i = 0; i < len; i++) {\n      require(_dialIds[i] < dials.length, \"Invalid dial id\");\n      DialData memory dialData = dials[_dialIds[i]];\n\n      // 1.0 - Get the dial's reward balance\n      if (dialData.balance == 0) {\n        continue;\n      }\n      // 2.0 - Reset the balance in storage back to 0\n      dials[_dialIds[i]].balance = 0;\n\n      // 3.0 - Send the rewards the to the dial recipient\n      REWARD_TOKEN.safeTransfer(dialData.recipient, dialData.balance);\n\n      // 4.0 - Notify the dial of the new rewards if configured to\n      //       Only after successful transer tx\n      if (dialData.notify) {\n        IRewardsDistributionRecipient(dialData.recipient).notifyRewardAmount(\n          dialData.balance\n        );\n      }\n\n      emit DistributedReward(_dialIds[i], dialData.balance);\n    }\n  }\n\n  /***************************************\n                VOTING-EXTERNAL\n    ****************************************/\n\n  /**\n   * @notice Re-cast a voters votes by retrieving balance across all staking contracts\n   *         and updating `lastSourcePoke`.\n   * @dev    This would need to be called if a staking contract was added to the emissions controller\n   * when a voter already had voting power in the new staking contract and they had already set voting preferences.\n   * @param _voter    Address of the voter for which to re-cast.\n   */\n  function pokeSources(address _voter) public {\n    // Only poke if voter has previously set voting preferences\n    if (voterPreferences[_voter].lastSourcePoke > 0) {\n      uint256 votesCast = voterPreferences[_voter].votesCast;\n      uint256 newVotesCast = getVotes(_voter) - votesCast;\n      _moveVotingPower(_voter, newVotesCast, _add);\n      voterPreferences[_voter].lastSourcePoke = SafeCast.toUint32(\n        block.timestamp\n      );\n\n      emit SourcesPoked(_voter, newVotesCast);\n    }\n  }\n\n  /**\n   * @notice Allows a staker to cast their voting power across a number of dials.\n   * @dev    A staker can proportion their voting power even if they currently have zero voting power.\n   *         For example, they have delegated their votes. When they do have voting power (e.g. they undelegate),\n   *         their set weights will proportion their voting power.\n   * @param _preferences  Structs containing dialId & voting weights, with 0 <= n <= 16 entries.\n   */\n  function setVoterDialWeights(Preference[] memory _preferences) external {\n    require(_preferences.length <= 16, \"Max of 16 preferences\");\n\n    // 1.0 - Get staker's previous total votes cast\n    uint256 votesCast = voterPreferences[msg.sender].votesCast;\n    // 1.1 - Adjust dial votes from removed staker votes\n    _moveVotingPower(msg.sender, votesCast, _subtract);\n    //       Clear the old weights as they will be added back below\n    delete voterPreferences[msg.sender];\n\n    // 2.0 - Log new preferences\n    uint256 newTotalWeight;\n    uint256 newDialWeights;\n    for (uint256 i = 0; i < _preferences.length; i++) {\n      require(_preferences[i].dialId < dials.length, \"Invalid dial id\");\n      require(_preferences[i].weight > 0, \"Must give a dial some weight\");\n      newTotalWeight += _preferences[i].weight;\n\n      // Add staker's dial weight\n      newDialWeights |= uint256(_preferences[i].weight) << (i * 16);\n      // Add staker's dial id\n      newDialWeights |= uint256(_preferences[i].dialId) << ((i * 16) + 8);\n    }\n\n    // 2.1 - In the likely scenario less than 16 preferences are given, add a breaker with max uint\n    //       to signal that this is the end of array.\n    if (_preferences.length < 16) {\n      // Set dialId to 255\n      newDialWeights |= uint256(255) << ((_preferences.length * 16) + 8);\n    }\n    require(newTotalWeight <= SCALE, \"Imbalanced weights\");\n    // Update storage with the array of 16 Preferences stored as an uint256\n    voterPreferences[msg.sender].dialWeights = newDialWeights;\n\n    // Need to set before calling _moveVotingPower for the second time\n    voterPreferences[msg.sender].lastSourcePoke = SafeCast.toUint32(\n      block.timestamp\n    );\n\n    // 3.0 - Cast votes on these new preferences\n    _moveVotingPower(msg.sender, getVotes(msg.sender), _add);\n\n    emit PreferencesChanged(msg.sender, _preferences);\n  }\n\n  /**\n   * @notice  Called by the staking contracts when a staker has modified voting power.\n   * @dev     This can be called when staking, cooling down for withdraw or delegating.\n   * @param from    Account that votes moved from. If a mint the account will be a zero address.\n   * @param to      Account that votes moved to. If a burn the account will be a zero address.\n   * @param amount  The number of votes moved including the decimal places.\n   */\n  function moveVotingPowerHook(\n    address from,\n    address to,\n    uint256 amount\n  ) external override {\n    if (amount > 0) {\n      bool votesCast;\n      // Require that the caller of this function is a whitelisted staking contract\n      uint32 addTime = stakingContractAddTime[msg.sender];\n      require(addTime > 0, \"Caller must be staking contract\");\n\n      // If burning (withdraw) or transferring delegated votes from a staker\n      if (from != address(0)) {\n        uint32 lastSourcePoke = voterPreferences[from].lastSourcePoke;\n        if (lastSourcePoke > addTime) {\n          _moveVotingPower(from, amount, _subtract);\n          votesCast = true;\n        } else if (lastSourcePoke > 0) {\n          // If preferences were set before the calling staking contract\n          // was added to the EmissionsController\n          pokeSources(from);\n        }\n        // Don't need to do anything if staker has not set preferences before.\n      }\n      // If minting (staking) or transferring delegated votes to a staker\n      if (to != address(0)) {\n        uint32 lastSourcePoke = voterPreferences[to].lastSourcePoke;\n        if (lastSourcePoke > addTime) {\n          _moveVotingPower(to, amount, _add);\n          votesCast = true;\n        } else if (lastSourcePoke > 0) {\n          // If preferences were set before the calling staking contract\n          // was added to the EmissionsController\n          pokeSources(to);\n        }\n        // Don't need to do anything if staker has not set preferences before.\n      }\n\n      // Only emit if voting power was moved.\n      if (votesCast) {\n        emit VotesCast(msg.sender, from, to, amount);\n      }\n    }\n  }\n\n  /***************************************\n                VOTING-INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Internal voting power updater. Adds/subtracts votes across the array of user preferences.\n   * @param _voter    Address of the source of movement.\n   * @param _amount   Total amount of votes to be added/removed (proportionately across the user preferences).\n   * @param _op       Function (either addition or subtraction) that dictates how the `_amount` of votes affects balance.\n   */\n  function _moveVotingPower(\n    address _voter,\n    uint256 _amount,\n    function(uint256, uint256) pure returns (uint256) _op\n  ) internal {\n    // 0.0 - Get preferences and epoch data\n    VoterPreferences memory preferences = voterPreferences[_voter];\n\n    // 0.1 - If no preferences have been set then there is nothing to do\n    // This prevent doing 16 iterations below as dialId 255 will not be set\n    if (preferences.lastSourcePoke == 0) return;\n\n    // 0.2 - If in the first launch week\n    uint32 currentEpoch = _epoch(block.timestamp);\n\n    // 0.3 - Update the total amount of votes cast by the voter\n    voterPreferences[_voter].votesCast = SafeCast.toUint128(\n      _op(preferences.votesCast, _amount)\n    );\n\n    // 1.0 - Loop through voter preferences until dialId == 255 or until end\n    for (uint256 i = 0; i < 16; i++) {\n      uint256 dialId = uint8(preferences.dialWeights >> ((i * 16) + 8));\n      if (dialId == 255) break;\n\n      uint256 weight = uint8(preferences.dialWeights >> (i * 16));\n\n      // 1.1 - Scale the vote by dial weight\n      //       e.g. 5e17 * 1e18 / 1e18 * 100e18 / 1e18 = 50e18\n      uint256 amountToChange = (weight * _amount) / SCALE;\n\n      // 1.2 - Fetch voting history for this dial\n      HistoricVotes[] storage voteHistory = dials[dialId].voteHistory;\n      uint256 len = voteHistory.length;\n      HistoricVotes storage latestHistoricVotes = voteHistory[len - 1];\n\n      // 1.3 - Determine new votes cast for dial\n      uint128 newVotes = SafeCast.toUint128(\n        _op(latestHistoricVotes.votes, amountToChange)\n      );\n\n      // 1.4 - Update dial vote count. If first vote in new epoch, create new entry\n      if (latestHistoricVotes.epoch < currentEpoch) {\n        // Add a new weighted votes epoch for the dial\n        voteHistory.push(\n          HistoricVotes({votes: newVotes, epoch: currentEpoch})\n        );\n      } else {\n        // Epoch already exists for this dial so just update the dial's weighted votes\n        latestHistoricVotes.votes = newVotes;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the epoch index the timestamp is on.\n   *         This is the number of weeks since 1 Jan 1970. ie the timestamp / 604800 seconds in a week.\n   * @dev    Each week starts on Thursday 00:00 UTC.\n   * @param timestamp UNIX time in seconds.\n   * @return epoch    The number of weeks since 1 Jan 1970.\n   */\n  function _epoch(uint256 timestamp) internal pure returns (uint32 epoch) {\n    epoch = SafeCast.toUint32(timestamp) / DISTRIBUTION_PERIOD;\n  }\n\n  /**\n   * @dev Simple addition function, used in the `_moveVotingPower` fn.\n   */\n  function _add(uint256 a, uint256 b) private pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Simple subtraction function, used in the `_moveVotingPower` fn.\n   */\n  function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n    return a - b;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/IGovernanceHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IGovernanceHook {\n  function moveVotingPowerHook(\n    address from,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "contracts/ppo-staking/interfaces/IRewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewardsDistributionRecipient {\n  function notifyRewardAmount(uint256 reward) external;\n\n  function getRewardToken() external view returns (IERC20);\n}\n\ninterface IRewardsRecipientWithPlatformToken {\n  function notifyRewardAmount(uint256 reward) external;\n\n  function getRewardToken() external view returns (IERC20);\n\n  function getPlatformToken() external view returns (IERC20);\n}\n"
    },
    "contracts/ppo-staking/interfaces/IVotes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IVotes {\n  function getVotes(address account) external view returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/interfaces/IEmissionsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IVotes} from \"../interfaces/IVotes.sol\";\nimport {DialData} from \"../emissions/EmissionsController.sol\";\n\n/**\n * @title IEmissionsController\n * @dev Emissions Controller interface used for by RevenueBuyBack\n */\ninterface IEmissionsController {\n  function getDialRecipient(uint256 dialId)\n    external\n    returns (address recipient);\n\n  function donate(uint256[] memory _dialIds, uint256[] memory _amounts)\n    external;\n\n  function stakingContracts(uint256 dialId) external returns (address);\n}\n"
    },
    "contracts/ppo-staking/z_mocks/rewards/MockRewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IRewardsRecipientWithPlatformToken} from \"../../interfaces/IRewardsDistributionRecipient.sol\";\nimport {IRewardsDistributionRecipient} from \"../../interfaces/IRewardsDistributionRecipient.sol\";\n\ncontract MockRewardsDistributionRecipient is\n  IRewardsDistributionRecipient,\n  IRewardsRecipientWithPlatformToken\n{\n  IERC20 public rewardToken;\n  IERC20 public platformToken;\n\n  constructor(IERC20 _rewardToken, IERC20 _platformToken) {\n    rewardToken = _rewardToken;\n    platformToken = _platformToken;\n  }\n\n  function notifyRewardAmount(uint256 reward)\n    external\n    override(IRewardsDistributionRecipient, IRewardsRecipientWithPlatformToken)\n  {\n    // do nothing\n  }\n\n  function getRewardToken()\n    external\n    view\n    override(IRewardsDistributionRecipient, IRewardsRecipientWithPlatformToken)\n    returns (IERC20)\n  {\n    return rewardToken;\n  }\n\n  function getPlatformToken() external view override returns (IERC20) {\n    return platformToken;\n  }\n}\n"
    },
    "contracts/ppo-staking/rewards/InitializableRewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IRewardsDistributionRecipient} from \"../interfaces/IRewardsDistributionRecipient.sol\";\n\n/**\n * @title  RewardsDistributionRecipient\n * @author Originally: Synthetix (forked from /Synthetixio/synthetix/contracts/RewardsDistributionRecipient.sol)\n *         Changes by: mStable\n * @notice RewardsDistributionRecipient gets notified of additional rewards by the rewardsDistributor\n * @dev    Changes: Addition of Module and abstract `getRewardToken` func + cosmetic\n */\nabstract contract InitializableRewardsDistributionRecipient is\n  IRewardsDistributionRecipient,\n  ImmutableModule\n{\n  // This address has the ability to distribute the rewards\n  address public rewardsDistributor;\n\n  constructor(address _nexus) ImmutableModule(_nexus) {}\n\n  /** @dev Recipient is a module, governed by mStable governance */\n  function _initialize(address _rewardsDistributor) internal virtual {\n    rewardsDistributor = _rewardsDistributor;\n  }\n\n  /**\n   * @dev Only the rewards distributor can notify about rewards\n   */\n  modifier onlyRewardsDistributor() {\n    require(\n      msg.sender == rewardsDistributor,\n      \"Caller is not reward distributor\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Change the rewardsDistributor - only called by mStable governor\n   * @param _rewardsDistributor   Address of the new distributor\n   */\n  function setRewardsDistribution(address _rewardsDistributor)\n    external\n    onlyGovernor\n  {\n    rewardsDistributor = _rewardsDistributor;\n  }\n}\n"
    },
    "contracts/ppo-staking/rewards/staking/HeadlessStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n// Internal\nimport {InitializableRewardsDistributionRecipient} from \"../InitializableRewardsDistributionRecipient.sol\";\nimport {StableMath} from \"../../shared/StableMath.sol\";\nimport {PlatformTokenVendorFactory} from \"./PlatformTokenVendorFactory.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n// Libs\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title  HeadlessStakingRewards\n * @author mStable\n * @notice Rewards stakers of a given LP token with REWARDS_TOKEN, on a pro-rata basis\n * @dev Forked from `StakingRewards.sol`\n *      Changes:\n *          - `pendingAdditionalReward` added to support accumulation of any extra staking token\n *          - Removal of `StakingTokenWrapper`, instead, deposits and withdrawals are made in child contract,\n *            and balances are read from there through the abstract functions\n */\nabstract contract HeadlessStakingRewards is\n  ContextUpgradeable,\n  InitializableRewardsDistributionRecipient\n{\n  using SafeERC20 for IERC20;\n  using StableMath for uint256;\n\n  /// @notice token the rewards are distributed in. eg MTA\n  IERC20 public immutable REWARDS_TOKEN;\n\n  /// @notice length of each staking period in seconds. 7 days = 604,800; 3 months = 7,862,400\n  uint256 public constant DURATION = 1 weeks;\n\n  /// @notice contract that holds the platform tokens\n  address public rewardTokenVendor;\n\n  struct Data {\n    /// Timestamp for current period finish\n    uint32 periodFinish;\n    /// Last time any user took action\n    uint32 lastUpdateTime;\n    /// RewardRate for the rest of the period\n    uint96 rewardRate;\n    /// Ever increasing rewardPerToken rate, based on % of total supply\n    uint96 rewardPerTokenStored;\n  }\n\n  struct UserData {\n    uint128 rewardPerTokenPaid;\n    uint128 rewards;\n  }\n\n  Data public globalData;\n  mapping(address => UserData) public userData;\n  uint256 public pendingAdditionalReward;\n\n  event RewardAdded(uint256 reward);\n  event RewardPaid(address indexed user, address indexed to, uint256 reward);\n\n  /**\n   * @param _nexus mStable system Nexus address\n   * @param _rewardsToken first token that is being distributed as a reward. eg MTA\n   */\n  constructor(address _nexus, address _rewardsToken)\n    InitializableRewardsDistributionRecipient(_nexus)\n  {\n    REWARDS_TOKEN = IERC20(_rewardsToken);\n  }\n\n  /**\n   * @dev Initialization function for upgradable proxy contract.\n   *      This function should be called via Proxy just after contract deployment.\n   *      To avoid variable shadowing appended `Arg` after arguments name.\n   * @param _rewardsDistributorArg mStable Reward Distributor contract address\n   */\n  function _initialize(address _rewardsDistributorArg)\n    internal\n    virtual\n    override\n  {\n    InitializableRewardsDistributionRecipient._initialize(\n      _rewardsDistributorArg\n    );\n    rewardTokenVendor = PlatformTokenVendorFactory.create(REWARDS_TOKEN);\n  }\n\n  /** @dev Updates the reward for a given address, before executing function */\n  modifier updateReward(address _account) {\n    _updateReward(_account);\n    _;\n  }\n\n  function _updateReward(address _account) internal {\n    // Setting of global vars\n    (\n      uint256 newRewardPerToken,\n      uint256 lastApplicableTime\n    ) = _rewardPerToken();\n    // If statement protects against loss in initialisation case\n    if (newRewardPerToken > 0) {\n      globalData.rewardPerTokenStored = SafeCast.toUint96(newRewardPerToken);\n      globalData.lastUpdateTime = SafeCast.toUint32(lastApplicableTime);\n      // Setting of personal vars based on new globals\n      if (_account != address(0)) {\n        userData[_account] = UserData({\n          rewardPerTokenPaid: SafeCast.toUint128(newRewardPerToken),\n          rewards: SafeCast.toUint128(_earned(_account, newRewardPerToken))\n        });\n      }\n    }\n  }\n\n  /***************************************\n                    ACTIONS\n    ****************************************/\n\n  /**\n   * @dev Claims outstanding rewards for the sender.\n   * First updates outstanding reward allocation and then transfers.\n   */\n  function claimReward(address _to) public {\n    _claimReward(_to);\n  }\n\n  /**\n   * @dev Claims outstanding rewards for the sender.\n   * First updates outstanding reward allocation and then transfers.\n   */\n  function claimReward() public {\n    _claimReward(_msgSender());\n  }\n\n  function _claimReward(address _to) internal updateReward(_msgSender()) {\n    uint128 reward = userData[_msgSender()].rewards;\n    if (reward > 0) {\n      userData[_msgSender()].rewards = 0;\n      REWARDS_TOKEN.safeTransferFrom(rewardTokenVendor, _to, reward);\n      emit RewardPaid(_msgSender(), _to, reward);\n    }\n    _claimRewardHook(_msgSender());\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev Gets the RewardsToken\n   */\n  function getRewardToken() external view override returns (IERC20) {\n    return REWARDS_TOKEN;\n  }\n\n  /**\n   * @dev Gets the last applicable timestamp for this reward period\n   */\n  function lastTimeRewardApplicable() public view returns (uint256) {\n    return StableMath.min(block.timestamp, globalData.periodFinish);\n  }\n\n  /**\n   * @dev Calculates the amount of unclaimed rewards per token since last update,\n   * and sums with stored to give the new cumulative reward per token\n   * @return 'Reward' per staked token\n   */\n  function rewardPerToken() public view returns (uint256) {\n    (uint256 rewardPerToken_, ) = _rewardPerToken();\n    return rewardPerToken_;\n  }\n\n  function _rewardPerToken()\n    internal\n    view\n    returns (uint256 rewardPerToken_, uint256 lastTimeRewardApplicable_)\n  {\n    uint256 lastApplicableTime = lastTimeRewardApplicable(); // + 1 SLOAD\n    Data memory data = globalData;\n    uint256 timeDelta = lastApplicableTime - data.lastUpdateTime; // + 1 SLOAD\n    // If this has been called twice in the same block, shortcircuit to reduce gas\n    if (timeDelta == 0) {\n      return (data.rewardPerTokenStored, lastApplicableTime);\n    }\n    // new reward units to distribute = rewardRate * timeSinceLastUpdate\n    uint256 rewardUnitsToDistribute = data.rewardRate * timeDelta; // + 1 SLOAD\n    uint256 supply = totalSupply(); // + 1 SLOAD\n    // If there is no StakingToken liquidity, avoid div(0)\n    // If there is nothing to distribute, short circuit\n    if (supply == 0 || rewardUnitsToDistribute == 0) {\n      return (data.rewardPerTokenStored, lastApplicableTime);\n    }\n    // new reward units per token = (rewardUnitsToDistribute * 1e18) / totalTokens\n    uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(\n      supply\n    );\n    // return summed rate\n    return (\n      data.rewardPerTokenStored + unitsToDistributePerToken,\n      lastApplicableTime\n    ); // + 1 SLOAD\n  }\n\n  /**\n   * @dev Calculates the amount of unclaimed rewards a user has earned\n   * @param _account User address\n   * @return Total reward amount earned\n   */\n  function earned(address _account) public view returns (uint256) {\n    return _earned(_account, rewardPerToken());\n  }\n\n  function _earned(address _account, uint256 _currentRewardPerToken)\n    internal\n    view\n    returns (uint256)\n  {\n    // current rate per token - rate user previously received\n    uint256 userRewardDelta = _currentRewardPerToken -\n      userData[_account].rewardPerTokenPaid; // + 1 SLOAD\n    // Short circuit if there is nothing new to distribute\n    if (userRewardDelta == 0) {\n      return userData[_account].rewards;\n    }\n    // new reward = staked tokens * difference in rate\n    uint256 userNewReward = balanceOf(_account).mulTruncate(userRewardDelta); // + 1 SLOAD\n    // add to previous rewards\n    return userData[_account].rewards + userNewReward;\n  }\n\n  /***************************************\n                    ABSTRACT\n    ****************************************/\n\n  function balanceOf(address account) public view virtual returns (uint256);\n\n  function totalSupply() public view virtual returns (uint256);\n\n  function _claimRewardHook(address account) internal virtual;\n\n  /***************************************\n                    ADMIN\n    ****************************************/\n\n  /**\n   * @dev Notifies the contract that new rewards have been added.\n   * Calculates an updated rewardRate based on the rewards in period.\n   * @param _reward Units of RewardToken that have been added to the pool\n   */\n  function notifyRewardAmount(uint256 _reward)\n    external\n    override\n    onlyRewardsDistributor\n    updateReward(address(0))\n  {\n    require(_reward < 1e24, \"Notify more than a million units\");\n\n    uint256 currentTime = block.timestamp;\n\n    // Pay and reset the pendingAdditionalRewards\n    if (pendingAdditionalReward > 1) {\n      _reward += (pendingAdditionalReward - 1);\n      pendingAdditionalReward = 1;\n    }\n    if (_reward > 0) {\n      REWARDS_TOKEN.safeTransfer(rewardTokenVendor, _reward);\n    }\n\n    // If previous period over, reset rewardRate\n    if (currentTime >= globalData.periodFinish) {\n      globalData.rewardRate = SafeCast.toUint96(_reward / DURATION);\n    }\n    // If additional reward to existing period, calc sum\n    else {\n      uint256 remainingSeconds = globalData.periodFinish - currentTime;\n      uint256 leftover = remainingSeconds * globalData.rewardRate;\n      globalData.rewardRate = SafeCast.toUint96(\n        (_reward + leftover) / DURATION\n      );\n    }\n\n    globalData.lastUpdateTime = SafeCast.toUint32(currentTime);\n    globalData.periodFinish = SafeCast.toUint32(currentTime + DURATION);\n\n    emit RewardAdded(_reward);\n  }\n\n  /**\n   * @dev Called by the child contract to notify of any additional rewards that have accrued.\n   *      Trusts that this is called honestly.\n   * @param _additionalReward Units of additional RewardToken to add at the next notification\n   */\n  function _notifyAdditionalReward(uint256 _additionalReward)\n    internal\n    virtual\n  {\n    require(\n      _additionalReward < 1e24,\n      \"Cannot notify with more than a million units\"\n    );\n\n    pendingAdditionalReward += _additionalReward;\n  }\n}\n"
    },
    "contracts/ppo-staking/rewards/staking/PlatformTokenVendorFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {PlatformTokenVendor} from \"./PlatformTokenVendor.sol\";\n\n/**\n * @title  PlatformTokenVendorFactory\n * @author mStable\n * @notice Library that deploys a PlatformTokenVendor contract which holds rewards tokens\n * @dev    Used to reduce the byte size of the contracts that need to deploy a PlatformTokenVendor contract\n */\nlibrary PlatformTokenVendorFactory {\n  /// @dev for some reason Typechain will not generate the types if the library only has the create function\n  function dummy() public pure returns (bool) {\n    return true;\n  }\n\n  /**\n   * @notice Deploys a new PlatformTokenVendor contract\n   * @param _rewardsToken reward or platform rewards token. eg MTA or WMATIC\n   * @return address of the deployed PlatformTokenVendor contract\n   */\n  function create(IERC20 _rewardsToken) public returns (address) {\n    PlatformTokenVendor newPlatformTokenVendor = new PlatformTokenVendor(\n      _rewardsToken\n    );\n    return address(newPlatformTokenVendor);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/ppo-staking/rewards/staking/PlatformTokenVendor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {MassetHelpers} from \"../../shared/MassetHelpers.sol\";\n\n/**\n * @title  PlatformTokenVendor\n * @author mStable\n * @notice Stores platform tokens for distributing to StakingReward participants\n * @dev    Only deploy this during the constructor of a given StakingReward contract\n */\ncontract PlatformTokenVendor {\n  IERC20 public immutable platformToken;\n  address public immutable parentStakingContract;\n\n  /** @dev Simple constructor that stores the parent address */\n  constructor(IERC20 _platformToken) {\n    parentStakingContract = msg.sender;\n    platformToken = _platformToken;\n    MassetHelpers.safeInfiniteApprove(address(_platformToken), msg.sender);\n  }\n\n  /**\n   * @dev Re-approves the StakingReward contract to spend the platform token.\n   * Just incase for some reason approval has been reset.\n   */\n  function reApproveOwner() external {\n    MassetHelpers.safeInfiniteApprove(\n      address(platformToken),\n      parentStakingContract\n    );\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/PPOGamifiedToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {SafeCastExtended} from \"../../shared/SafeCastExtended.sol\";\nimport {ILockedERC20} from \"./interfaces/ILockedERC20.sol\";\nimport {HeadlessStakingRewards} from \"../../rewards/staking/HeadlessStakingRewards.sol\";\nimport {IAchievementsManager} from \"./interfaces/IAchievementsManager.sol\";\nimport {ITimeMultiplierCalculator} from \"./interfaces/ITimeMultiplierCalculator.sol\";\nimport \"./deps/PPOGamifiedTokenStructs.sol\";\n\n/**\n * @title PPOGamifiedToken\n * @notice PPOGamifiedToken is a non-transferrable ERC20 token that has both a raw balance and a scaled balance.\n * Scaled balance is determined by quests a user completes, and the length of time they keep the raw balance wrapped.\n * QuestMasters can add new quests for stakers to complete, for which they are rewarded with permanent or seasonal multipliers.\n * @author mStable\n * @dev Originally forked from openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\n * Changes:\n *   - Removed the transfer, transferFrom, approve fns to make non-transferrable\n *   - Removed `_allowances` storage\n *   - Removed `_beforeTokenTransfer` hook\n *   - Replaced standard uint256 balance with a single struct containing all data from which the scaledBalance can be derived\n *   - Quest system implemented that tracks a users quest status and applies multipliers for them\n **/\nabstract contract PPOGamifiedToken is\n  ILockedERC20,\n  Initializable,\n  ContextUpgradeable,\n  HeadlessStakingRewards\n{\n  event TimeMultiplierCalculatorChange(address newCalculator);\n  event MaxMultiplierChange(uint256 newMultiplier);\n\n  /// @notice name of this token (ERC20)\n  string private _name;\n  /// @notice symbol of this token (ERC20)\n  string private _symbol;\n  /// @notice number of decimals of this token (ERC20)\n  uint8 public constant override decimals = 18;\n\n  ITimeMultiplierCalculator private _timeMultiplierCalculator;\n  uint256 private _maxMultiplier;\n  uint256 public constant MULTIPLIER_DENOMINATOR = 1e12;\n\n  /// @notice User balance structs containing all data needed to scale balance\n  mapping(address => Balance) internal _balances;\n  IAchievementsManager public achievementsManager;\n\n  /***************************************\n                    INIT\n    ****************************************/\n\n  /**\n   * @param _nexus System nexus\n   * @param _rewardsToken Token that is being distributed as a reward. eg MTA\n   * @param _achievementsManager Centralised manager of quests\n   */\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _achievementsManager\n  ) HeadlessStakingRewards(_nexus, _rewardsToken) {\n    achievementsManager = IAchievementsManager(_achievementsManager);\n  }\n\n  /**\n   * @param _nameArg Token name\n   * @param _symbolArg Token symbol\n   * @param _rewardsDistributorArg mStable Rewards Distributor\n   */\n  function __PPOGamifiedToken_init(\n    string memory _nameArg,\n    string memory _symbolArg,\n    address _rewardsDistributorArg\n  ) internal {\n    __Context_init_unchained();\n    _name = _nameArg;\n    _symbol = _symbolArg;\n    HeadlessStakingRewards._initialize(_rewardsDistributorArg);\n  }\n\n  /**\n   * @dev Checks that _msgSender is the quest Manager\n   */\n  modifier onlyAchievementsManager() {\n    require(\n      _msgSender() == address(achievementsManager),\n      \"Not achievement manager\"\n    );\n    _;\n  }\n\n  function setTimeMultiplierCalculator(address _newCalculator)\n    external\n    onlyGovernor\n  {\n    _timeMultiplierCalculator = ITimeMultiplierCalculator(_newCalculator);\n    emit TimeMultiplierCalculatorChange(_newCalculator);\n  }\n\n  function setMaxMultiplier(uint256 _newMaxMultiplier) external onlyGovernor {\n    _maxMultiplier = _newMaxMultiplier;\n    emit MaxMultiplierChange(_newMaxMultiplier);\n  }\n\n  /***************************************\n                    VIEWS\n    ****************************************/\n\n  function name() public view override returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Total sum of all scaled balances\n   * In this instance, leave to the child token.\n   */\n  function totalSupply()\n    public\n    view\n    virtual\n    override(HeadlessStakingRewards, ILockedERC20)\n    returns (uint256);\n\n  /**\n   * @dev Simply gets scaled balance\n   * @return scaled balance for user\n   */\n  function balanceOf(address _account)\n    public\n    view\n    virtual\n    override(HeadlessStakingRewards, ILockedERC20)\n    returns (uint256)\n  {\n    return _scaleBalance(_balances[_account]);\n  }\n\n  /**\n   * @dev Simply gets raw balance\n   * @return raw balance for user\n   */\n  function rawBalanceOf(address _account)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    return (_balances[_account].raw, _balances[_account].cooldownUnits);\n  }\n\n  /**\n   * @dev Scales the balance of a given user by applying multipliers\n   */\n  function _scaleBalance(Balance memory _balance)\n    internal\n    view\n    returns (uint256 balance)\n  {\n    uint256 _combinedMultiplier;\n    if (_balance.achievementsMultiplier < 0) {\n      uint256 _absAchievementsMultiplier = uint256(\n        -int256(_balance.achievementsMultiplier)\n      );\n      _combinedMultiplier = _absAchievementsMultiplier >=\n        _balance.timeMultiplier\n        ? 0\n        : _balance.timeMultiplier - _absAchievementsMultiplier;\n    } else {\n      /**\n       * int => uint conversion is safe here because\n       * achievementsMultiplier is guaranteed to be >= 0\n       */\n      _combinedMultiplier =\n        _balance.timeMultiplier +\n        uint256(uint64(_balance.achievementsMultiplier));\n    }\n    if (_combinedMultiplier > _maxMultiplier) {\n      _combinedMultiplier = _maxMultiplier;\n    }\n    balance = (_balance.raw * _combinedMultiplier) / MULTIPLIER_DENOMINATOR;\n  }\n\n  function getTimeMultiplierCalculator()\n    external\n    view\n    returns (ITimeMultiplierCalculator)\n  {\n    return _timeMultiplierCalculator;\n  }\n\n  function getMaxMultiplier() external view returns (uint256) {\n    return _maxMultiplier;\n  }\n\n  /**\n   * @notice Raw staked balance without any multipliers\n   */\n  function balanceData(address _account)\n    external\n    view\n    returns (Balance memory)\n  {\n    return _balances[_account];\n  }\n\n  /***************************************\n                    QUESTS\n    ****************************************/\n\n  /**\n   * @dev Called by anyone to poke the timestamp of a given account. This allows users to\n   * effectively 'claim' any new timeMultiplier, but will revert if there is no change there.\n   */\n  function reviewTimestamp(address _account) external {\n    _reviewWeightedTimestamp(_account);\n  }\n\n  /**\n   * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\n   * to check time multipliers etc.\n   * @param _account Address of user that should be updated\n   * @param _newMultiplier New Quest Multiplier\n   */\n  function applyAchievementsMultiplier(address _account, int64 _newMultiplier)\n    external\n    onlyAchievementsManager\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance & update achievementsMultiplier, only if user has a balance\n    Balance memory oldBalance = _balances[_account];\n    uint256 oldScaledBalance = _scaleBalance(oldBalance);\n    if (oldScaledBalance > 0) {\n      _applyAchievementsMultiplier(\n        _account,\n        oldBalance,\n        oldScaledBalance,\n        _newMultiplier\n      );\n    }\n  }\n\n  /***************************************\n                BALANCE CHANGES\n    ****************************************/\n\n  /**\n   * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\n   * to check time multiplier.\n   * @param _account Address of user that should be updated\n   * @param _newMultiplier New Quest Multiplier\n   */\n  function _applyAchievementsMultiplier(\n    address _account,\n    Balance memory _oldBalance,\n    uint256 _oldScaledBalance,\n    int64 _newMultiplier\n  ) private updateReward(_account) {\n    // 1. Set the achievementsMultiplier\n    _balances[_account].achievementsMultiplier = _newMultiplier;\n\n    // 2. Take the opportunity to set weighted timestamp, if it changes\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _timeMultiplierCalculator.calculate(_oldBalance.weightedTimestamp)\n    );\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, _oldScaledBalance);\n  }\n\n  /**\n   * @dev Entering a cooldown period means a user wishes to withdraw. With this in mind, their balance\n   * should be reduced until they have shown more commitment to the system\n   * @param _account Address of user that should be cooled\n   * @param _units Units to cooldown for\n   */\n  function _enterCooldownPeriod(address _account, uint256 _units)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint256 _totalUnits = oldBalance.raw + oldBalance.cooldownUnits;\n    require(\n      _units > 0 && _units <= _totalUnits,\n      \"Must choose between 0 and 100%\"\n    );\n\n    // 2. Set weighted timestamp and enter cooldown\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _timeMultiplierCalculator.calculate(oldBalance.weightedTimestamp)\n    );\n    // e.g. 1e18 / 1e16 = 100, 2e16 / 1e16 = 2, 1e15/1e16 = 0\n    _balances[_account].raw = SafeCastExtended.toUint128(_totalUnits - _units);\n\n    // 3. Set cooldown data\n    _balances[_account].cooldownTimestamp = SafeCastExtended.toUint64(\n      block.timestamp\n    );\n    _balances[_account].cooldownUnits = SafeCastExtended.toUint128(_units);\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Exiting the cooldown period explicitly resets the users cooldown window and their balance\n   * @param _account Address of user that should be exited\n   */\n  function _exitCooldownPeriod(address _account)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n\n    // 2. Set weighted timestamp and exit cooldown\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _timeMultiplierCalculator.calculate(oldBalance.weightedTimestamp)\n    );\n    _balances[_account].raw += oldBalance.cooldownUnits;\n\n    // 3. Set cooldown data\n    _balances[_account].cooldownTimestamp = 0;\n    _balances[_account].cooldownUnits = 0;\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Pokes the weightedTimestamp of a given user and checks if it entitles them\n   * to a better timeMultiplier. If not, it simply reverts as there is nothing to update.\n   * @param _account Address of user that should be updated\n   */\n  function _reviewWeightedTimestamp(address _account)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n\n    // 2. Set weighted timestamp, if it changes\n    uint256 _newTimeMultiplier = _timeMultiplierCalculator.calculate(\n      oldBalance.weightedTimestamp\n    );\n    require(\n      _newTimeMultiplier != oldBalance.timeMultiplier,\n      \"Nothing worth poking here\"\n    );\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _newTimeMultiplier\n    );\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Called to mint from raw tokens. Adds raw to a users balance, and then propagates the scaledBalance.\n   * Importantly, when a user stakes more, their weightedTimestamp is reduced proportionate to their stake.\n   * @param _account Address of user to credit\n   * @param _rawAmount Raw amount of tokens staked\n   * @param _exitCooldown Should we end any cooldown?\n   */\n  function _mintRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown\n  ) internal updateReward(_account) {\n    require(_account != address(0), \"ERC20: mint to the zero address\");\n\n    // 1. Get and update current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint256 _totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\n    _balances[_account].raw = SafeCastExtended.toUint128(\n      oldBalance.raw + _rawAmount\n    );\n\n    // 2. Exit cooldown if necessary\n    if (_exitCooldown) {\n      _balances[_account].raw += oldBalance.cooldownUnits;\n      _balances[_account].cooldownTimestamp = 0;\n      _balances[_account].cooldownUnits = 0;\n    }\n\n    // 3. Set weighted timestamp\n    //  i) For new _account, set up weighted timestamp\n    if (oldBalance.weightedTimestamp == 0) {\n      _balances[_account].weightedTimestamp = SafeCastExtended.toUint64(\n        block.timestamp\n      );\n      // Required so that balances are initially scaled at 1X\n      _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n        _timeMultiplierCalculator.calculate(block.timestamp)\n      );\n      _mintScaled(_account, _scaleBalance(_balances[_account]));\n      return;\n    }\n    //  ii) For previous minters, recalculate time held\n    //      Calc new weighted timestamp\n    uint256 _oldWeightedSecondsHeld = (block.timestamp -\n      oldBalance.weightedTimestamp) * _totalRaw;\n    uint256 _newSecondsHeld = _oldWeightedSecondsHeld /\n      (_totalRaw + (_rawAmount / 2));\n    uint256 _newWeightedTs = block.timestamp - _newSecondsHeld;\n    _balances[_account].weightedTimestamp = SafeCastExtended.toUint64(\n      _newWeightedTs\n    );\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _timeMultiplierCalculator.calculate(_newWeightedTs)\n    );\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Called to burn a given amount of raw tokens.\n   * @param _account Address of user\n   * @param _rawAmount Raw amount of tokens to remove\n   * @param _exitCooldown Exit the cooldown?\n   * @param _finalise Has recollateralisation happened? If so, everything is cooled down\n   */\n  function _burnRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown,\n    bool _finalise\n  ) internal updateReward(_account) {\n    require(_account != address(0), \"ERC20: burn from zero address\");\n\n    // 1. Get and update current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint256 _totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\n    // 1.1. If _finalise, move everything to cooldown\n    if (_finalise) {\n      _balances[_account].raw = 0;\n      _balances[_account].cooldownUnits = SafeCastExtended.toUint128(\n        _totalRaw\n      );\n      oldBalance.cooldownUnits = SafeCastExtended.toUint128(_totalRaw);\n    }\n    // 1.2. Update\n    require(\n      oldBalance.cooldownUnits >= _rawAmount,\n      \"ERC20: burn amount > balance\"\n    );\n    unchecked {\n      _balances[_account].cooldownUnits -= SafeCastExtended.toUint128(\n        _rawAmount\n      );\n    }\n\n    // 2. If we are exiting cooldown, reset the balance\n    if (_exitCooldown) {\n      _balances[_account].raw += _balances[_account].cooldownUnits;\n      _balances[_account].cooldownTimestamp = 0;\n      _balances[_account].cooldownUnits = 0;\n    }\n\n    // 3. Set back scaled time\n    // e.g. stake 10 for 100 seconds, withdraw 5.\n    //      secondsHeld = (100 - 0) * (10 - 0.625) = 937.5\n    uint256 _secondsHeld = (block.timestamp - oldBalance.weightedTimestamp) *\n      (_totalRaw - (_rawAmount / 8));\n    //      newWeightedTs = 937.5 / 100 = 93.75\n    uint256 _newSecondsHeld = _secondsHeld / _totalRaw;\n    uint256 _newWeightedTs = block.timestamp - _newSecondsHeld;\n    _balances[_account].weightedTimestamp = SafeCastExtended.toUint64(\n      _newWeightedTs\n    );\n    _balances[_account].timeMultiplier = SafeCastExtended.toUint64(\n      _timeMultiplierCalculator.calculate(_newWeightedTs)\n    );\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /***************************************\n                    PRIVATE\n    updateReward should already be called by now\n    ****************************************/\n\n  /**\n   * @dev Fetches the balance of a given user, scales it, and also takes the opportunity\n   * to check if the season has just finished between now and their last action.\n   * @param _account Address of user to fetch\n   * @return oldBalance struct containing all balance information\n   * @return oldScaledBalance scaled balance after applying multipliers\n   */\n  function _prepareOldBalance(address _account)\n    private\n    returns (Balance memory oldBalance, uint256 oldScaledBalance)\n  {\n    // Get the old balance\n    oldBalance = _balances[_account];\n    oldScaledBalance = _scaleBalance(oldBalance);\n    // Take the opportunity to check for season finish\n    _balances[_account].achievementsMultiplier = achievementsManager\n      .checkForSeasonFinish(_account);\n  }\n\n  /**\n   * @dev Settles the scaled balance of a given account. The reason this is done here, is because\n   * in each of the write functions above, there is the chance that a users balance can go down,\n   * requiring to burn sacled tokens. This could happen at the end of a season when multipliers are slashed.\n   * This is called after updating all multipliers etc.\n   * @param _account Address of user that should be updated\n   * @param _oldScaledBalance Previous scaled balance of the user\n   */\n  function _settleScaledBalance(address _account, uint256 _oldScaledBalance)\n    private\n  {\n    uint256 newScaledBalance = _scaleBalance(_balances[_account]);\n    if (newScaledBalance > _oldScaledBalance) {\n      _mintScaled(_account, newScaledBalance - _oldScaledBalance);\n    }\n    // This can happen if the user moves back a time class, but is unlikely to result in a negative mint\n    else {\n      _burnScaled(_account, _oldScaledBalance - newScaledBalance);\n    }\n  }\n\n  /**\n   * @dev Propagates the minting of the tokens downwards.\n   * @param _account Address of user that has minted\n   * @param _amount Amount of scaled tokens minted\n   */\n  function _mintScaled(address _account, uint256 _amount) private {\n    emit Transfer(address(0), _account, _amount);\n\n    _afterTokenTransfer(address(0), _account, _amount);\n  }\n\n  /**\n   * @dev Propagates the burning of the tokens downwards.\n   * @param _account Address of user that has burned\n   * @param _amount Amount of scaled tokens burned\n   */\n  function _burnScaled(address _account, uint256 _amount) private {\n    emit Transfer(_account, address(0), _amount);\n\n    _afterTokenTransfer(_account, address(0), _amount);\n  }\n\n  /***************************************\n                    HOOKS\n    ****************************************/\n\n  /**\n   * @dev Triggered after a user claims rewards from the HeadlessStakingRewards. Used\n   * to check for season finish. If it has not, then do not spend gas updating the other vars.\n   * @param _account Address of user that has burned\n   */\n  function _claimRewardHook(address _account) internal override {\n    int64 _newMultiplier = achievementsManager.checkForSeasonFinish(_account);\n    if (_newMultiplier != _balances[_account].achievementsMultiplier) {\n      // 1. Get current balance & trigger season finish\n      uint256 oldScaledBalance = _scaleBalance(_balances[_account]);\n      _balances[_account].achievementsMultiplier = _newMultiplier;\n      // 2. Update scaled balance\n      _settleScaledBalance(_account, oldScaledBalance);\n    }\n  }\n\n  /**\n   * @dev Unchanged from OpenZeppelin. Used in child contracts to react to any balance changes.\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal virtual {}\n\n  uint256[46] private __gap;\n}\n"
    },
    "contracts/ppo-staking/shared/SafeCastExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastExtended {\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(\n      value <= type(uint224).max,\n      \"SafeCast: value doesn't fit in 224 bits\"\n    );\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(\n      value <= type(uint128).max,\n      \"SafeCast: value doesn't fit in 128 bits\"\n    );\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(\n      value <= type(uint96).max,\n      \"SafeCast: value doesn't fit in 96 bits\"\n    );\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(\n      value <= type(uint88).max,\n      \"SafeCast: value doesn't fit in 88 bits\"\n    );\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(\n      value <= type(uint64).max,\n      \"SafeCast: value doesn't fit in 64 bits\"\n    );\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(\n      value <= type(uint32).max,\n      \"SafeCast: value doesn't fit in 32 bits\"\n    );\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(\n      value <= type(uint16).max,\n      \"SafeCast: value doesn't fit in 16 bits\"\n    );\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, \"SafeCast: value must be positive\");\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(\n      value >= type(int128).min && value <= type(int128).max,\n      \"SafeCast: value doesn't fit in 128 bits\"\n    );\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(\n      value >= type(int64).min && value <= type(int64).max,\n      \"SafeCast: value doesn't fit in 64 bits\"\n    );\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(\n      value >= type(int32).min && value <= type(int32).max,\n      \"SafeCast: value doesn't fit in 32 bits\"\n    );\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(\n      value >= type(int16).min && value <= type(int16).max,\n      \"SafeCast: value doesn't fit in 16 bits\"\n    );\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(\n      value >= type(int8).min && value <= type(int8).max,\n      \"SafeCast: value doesn't fit in 8 bits\"\n    );\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(\n      value <= uint256(type(int256).max),\n      \"SafeCast: value doesn't fit in an int256\"\n    );\n    return int256(value);\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/ILockedERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface ILockedERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/IAchievementsManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n/**\n * This interface is for mocking purposes until AchievementsManager is\n * complete. `checkForSeasonFinish()` is the only function that will be called\n * by the staking contract and therefore the only one we need to mock.\n */\ninterface IAchievementsManager {\n  function checkForSeasonFinish(address account) external returns (int64);\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/ITimeMultiplierCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\ninterface ITimeMultiplierCalculator {\n  function calculate(uint256 _timestamp) external view returns (uint256);\n}\n"
    },
    "contracts/ppo-staking/governance/staking/deps/PPOGamifiedTokenStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n// TODO move to IPPOGamifiedToken\n\nstruct Balance {\n  /// units of staking token that has been deposited and consequently wrapped\n  uint128 raw;\n  /// (block.timestamp - weightedTimestamp) represents the seconds a user has had their full raw balance wrapped.\n  /// If they deposit or withdraw, the weightedTimestamp is dragged towards block.timestamp proportionately\n  uint64 weightedTimestamp;\n  /// multiplier awarded for staking for a long time\n  uint64 timeMultiplier;\n  /// TODO remove\n  uint8 questMultiplier;\n  /// multiplier obtained from AchievementsManager\n  int64 achievementsMultiplier;\n  /// Time at which the relative cooldown began\n  uint64 cooldownTimestamp;\n  /// Units up for cooldown\n  uint128 cooldownUnits;\n}\n\nstruct QuestBalance {\n  /// last timestamp at which the user made a write action to this contract\n  uint32 lastAction;\n  /// permanent multiplier applied to an account, awarded for PERMANENT QuestTypes\n  uint8 permMultiplier;\n  /// multiplier that decays after each \"season\" (~9 months) by 75%, to avoid multipliers getting out of control\n  uint8 seasonMultiplier;\n}\n\n/// @notice Quests can either give permanent rewards or only for the season\nenum QuestType {\n  PERMANENT,\n  SEASONAL\n}\n\n/// @notice Quests can be turned off by the questMaster. All those who already completed remain\nenum QuestStatus {\n  ACTIVE,\n  EXPIRED\n}\nstruct Quest {\n  /// Type of quest rewards\n  QuestType model;\n  /// Multiplier, from 1 == 1.01x to 100 == 2.00x\n  uint8 multiplier;\n  /// Is the current quest valid?\n  QuestStatus status;\n  /// Expiry date in seconds for the quest\n  uint32 expiry;\n}\n"
    },
    "contracts/ppo-staking/mocks/MockPPOGamifiedToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"../governance/staking/PPOGamifiedToken.sol\";\n\ncontract MockPPOGamifiedToken is PPOGamifiedToken {\n  constructor(\n    address _newNexus,\n    address _newRewardsToken,\n    address _newAchievementsManager\n  ) PPOGamifiedToken(_newNexus, _newRewardsToken, _newAchievementsManager) {}\n\n  function __mockPPOGamifiedToken_init(\n    string memory _newName,\n    string memory _newSymbol,\n    address _newRewardsDistributor\n  ) public initializer {\n    __PPOGamifiedToken_init(_newName, _newSymbol, _newRewardsDistributor);\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return 0;\n  }\n\n  function getScaledBalance(Balance memory _balance)\n    external\n    view\n    returns (uint256)\n  {\n    return _scaleBalance(_balance);\n  }\n\n  function setAchievementsManager(address _newAchievementsManager) external {\n    achievementsManager = IAchievementsManager(_newAchievementsManager);\n  }\n\n  function writeBalance(address _account, Balance memory _newBalance)\n    external\n  {\n    _balances[_account] = _newBalance;\n  }\n\n  function enterCooldownPeriod(address _account, uint256 _units) external {\n    _enterCooldownPeriod(_account, _units);\n  }\n\n  function exitCooldownPeriod(address _account) external {\n    _exitCooldownPeriod(_account);\n  }\n\n  function mintRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown\n  ) external {\n    _mintRaw(_account, _rawAmount, _exitCooldown);\n  }\n\n  function burnRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown,\n    bool _finalise\n  ) external {\n    _burnRaw(_account, _rawAmount, _exitCooldown, _finalise);\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/PPOGamifiedVotingToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport {MathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {PPOGamifiedToken} from \"./PPOGamifiedToken.sol\";\nimport {IGovernanceHook} from \"./interfaces/IGovernanceHook.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title GamifiedVotingToken\n * @notice GamifiedToken is a checkpointed Voting Token derived from OpenZeppelin \"ERC20VotesUpgradable\"\n * @author mStable\n * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9cdbd7d82d45a614ee98a5dc8c08fb4347d0fea/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\n * Changes:\n *   - Inherits custom GamifiedToken rather than basic ERC20\n *     - Removal of `Permit` functionality & `delegatebySig`\n *   - Override `delegates` fn as described in their docs\n *   - Prettier formatting\n *   - Addition of `totalSupply` method to get latest totalSupply\n *   - Move totalSupply checkpoints to `afterTokenTransfer`\n *   - Add _governanceHook hook\n */\nabstract contract PPOGamifiedVotingToken is Initializable, PPOGamifiedToken {\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint224 votes;\n  }\n\n  mapping(address => address) private _delegates;\n  mapping(address => Checkpoint[]) private _checkpoints;\n  Checkpoint[] private _totalSupplyCheckpoints;\n\n  IGovernanceHook private _governanceHook;\n\n  event GovernanceHookChange(address indexed hook);\n\n  /**\n   * @dev Emitted when an account changes their delegatee.\n   */\n  event DelegateeChange(\n    address indexed delegator,\n    address indexed fromDelegatee,\n    address indexed toDelegatee\n  );\n\n  /**\n   * @dev Emitted when a token transfer or delegatee change results in changes to an account's voting power.\n   */\n  event DelegateeVotesChange(\n    address indexed delegatee,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _achievementsManager\n  ) PPOGamifiedToken(_nexus, _rewardsToken, _achievementsManager) {}\n\n  function __PPOGamifiedVotingToken_init() internal {}\n\n  /**\n   * @dev\n   */\n  function setGovernanceHook(address _newHook) external onlyGovernor {\n    _governanceHook = IGovernanceHook(_newHook);\n\n    emit GovernanceHookChange(_newHook);\n  }\n\n  /**\n   * @dev Get the `pos`-th checkpoint for `account`.\n   */\n  function checkpoints(address account, uint32 pos)\n    public\n    view\n    virtual\n    returns (Checkpoint memory)\n  {\n    return _checkpoints[account][pos];\n  }\n\n  /**\n   * @dev Get number of checkpoints for `account`.\n   */\n  function numCheckpoints(address account)\n    public\n    view\n    virtual\n    returns (uint32)\n  {\n    return SafeCast.toUint32(_checkpoints[account].length);\n  }\n\n  /**\n   * @dev Get the address the `delegator` is currently delegating to.\n   * @param delegator the account that is delegating the votes from\n   * @return delegatee that is receiving the delegated votes\n   */\n  function delegates(address delegator) public view virtual returns (address) {\n    address delegatee = _delegates[delegator];\n    return delegatee == address(0) ? delegator : delegatee;\n  }\n\n  /**\n   * @dev Gets the current votes balance for `account`\n   */\n  function getVotes(address account) public view returns (uint256) {\n    uint256 pos = _checkpoints[account].length;\n    return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n  }\n\n  /**\n   * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n   *\n   * Requirements:\n   *\n   * - `blockNumber` must have been already mined\n   */\n  function getPastVotes(address account, uint256 blockNumber)\n    public\n    view\n    returns (uint256)\n  {\n    require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n    return _checkpointsLookup(_checkpoints[account], blockNumber);\n  }\n\n  /**\n   * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n   * It is but NOT the sum of all the delegated votes!\n   *\n   * Requirements:\n   *\n   * - `blockNumber` must have been already mined\n   */\n  function getPastTotalSupply(uint256 blockNumber)\n    public\n    view\n    returns (uint256)\n  {\n    require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n    return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n  }\n\n  /**\n   * @dev Total sum of all scaled balances\n   */\n  function totalSupply() public view override returns (uint256) {\n    uint256 len = _totalSupplyCheckpoints.length;\n    if (len == 0) return 0;\n    return _totalSupplyCheckpoints[len - 1].votes;\n  }\n\n  /**\n   * @dev Lookup a value in a list of (sorted) checkpoints.\n   */\n  function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n  {\n    // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n    //\n    // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n    // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n    // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n    // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n    // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n    // out of bounds (in which case we're looking too far in the past and the result is 0).\n    // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n    // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n    // the same.\n    uint256 high = ckpts.length;\n    uint256 low = 0;\n    while (low < high) {\n      uint256 mid = MathUpgradeable.average(low, high);\n      if (ckpts[mid].fromBlock > blockNumber) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return high == 0 ? 0 : ckpts[high - 1].votes;\n  }\n\n  /**\n   * @dev Delegate votes from the sender to `delegatee`.\n   * If `delegatee` is zero, the sender gets the voting power.\n   * @param _delegatee account that gets the voting power.\n   */\n  function delegate(address _delegatee) public virtual {\n    address _delegator = _msgSender();\n    address _currentDelegatee = delegates(_delegator);\n\n    _delegates[_delegator] = _delegatee;\n    // Ensures that address(0) defaults to the delegator\n    _delegatee = delegates(_delegator);\n\n    if (_currentDelegatee != _delegatee) {\n      emit DelegateeChange(_delegator, _currentDelegatee, _delegatee);\n    }\n    _moveVotingPower(_currentDelegatee, _delegatee, balanceOf(_delegator));\n  }\n\n  /**\n   * @dev Move voting power when tokens are transferred.\n   *\n   * Emits a {DelegateeVotesChange} event.\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._afterTokenTransfer(from, to, amount);\n\n    // mint or burn, update total supply\n    if (from == address(0) || to == address(0)) {\n      _writeCheckpoint(\n        _totalSupplyCheckpoints,\n        to == address(0) ? _subtract : _add,\n        amount\n      );\n    }\n\n    _moveVotingPower(delegates(from), delegates(to), amount);\n  }\n\n  function _moveVotingPower(\n    address src,\n    address dst,\n    uint256 amount\n  ) private {\n    if (src != dst && amount > 0) {\n      if (src != address(0)) {\n        (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\n          _checkpoints[src],\n          _subtract,\n          amount\n        );\n        emit DelegateeVotesChange(src, oldWeight, newWeight);\n      }\n\n      if (dst != address(0)) {\n        (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\n          _checkpoints[dst],\n          _add,\n          amount\n        );\n        emit DelegateeVotesChange(dst, oldWeight, newWeight);\n      }\n\n      if (address(_governanceHook) != address(0)) {\n        _governanceHook.moveVotingPowerHook(src, dst, amount);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    Checkpoint[] storage ckpts,\n    function(uint256, uint256) view returns (uint256) op,\n    uint256 delta\n  ) private returns (uint256 oldWeight, uint256 newWeight) {\n    uint256 pos = ckpts.length;\n    oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n    newWeight = op(oldWeight, delta);\n\n    if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n      ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n    } else {\n      ckpts.push(\n        Checkpoint({\n          fromBlock: SafeCast.toUint32(block.number),\n          votes: SafeCast.toUint224(newWeight)\n        })\n      );\n    }\n  }\n\n  function _add(uint256 a, uint256 b) private pure returns (uint256) {\n    return a + b;\n  }\n\n  function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n    return a - b;\n  }\n\n  uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/PPOStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport {IStakedToken} from \"./interfaces/IStakedToken.sol\";\nimport {PPOGamifiedVotingToken} from \"./PPOGamifiedVotingToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Root} from \"../../shared/Root.sol\";\nimport {InitializableReentrancyGuard} from \"../../shared/InitializableReentrancyGuard.sol\";\nimport \"./deps/PPOGamifiedTokenStructs.sol\";\n\n/**\n * @title StakedToken\n * @notice StakedToken is a non-transferrable ERC20 token that allows users to stake and withdraw, earning voting rights.\n * Scaled balance is determined by quests a user completes, and the length of time they keep the raw balance wrapped.\n * Stakers can unstake, after the elapsed cooldown period, and before the end of the unstake window. Users voting/earning\n * power is slashed during this time, and they may face a redemption fee if they leave early.\n * The reason for this unstake window is that this StakedToken acts as a source of insurance value for the mStable system,\n * which can access the funds via the Recollateralisation module, up to the amount defined in `safetyData`.\n * Voting power can be used for a number of things: voting in the mStable DAO/emission dials, boosting rewards, earning\n * rewards here. While a users \"balance\" is unique to themselves, they can choose to delegate their voting power (which will apply\n * to voting in the mStable DAO and emission dials).\n * @author mStable\n * @dev Only whitelisted contracts can communicate with this contract, in order to avoid having tokenised wrappers that\n * could potentially circumvent our unstaking procedure.\n **/\ncontract PPOStaking is PPOGamifiedVotingToken, InitializableReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  /// @notice Core token that is staked and tracked (e.g. MTA)\n  IERC20 public immutable STAKED_TOKEN;\n  /// @notice Seconds a user must wait after she initiates her cooldown before withdrawal is possible\n  uint256 public immutable COOLDOWN_SECONDS;\n  /// @notice Window in which it is possible to withdraw, following the cooldown period\n  uint256 public immutable UNSTAKE_WINDOW;\n  /// @notice A week\n  uint256 private constant ONE_WEEK = 7 days;\n\n  struct SafetyData {\n    /// Percentage of collateralisation where 100% = 1e18\n    uint128 collateralisationRatio;\n    /// Slash % where 100% = 1e18\n    uint128 slashingPercentage;\n  }\n\n  /// @notice Data relating to the re-collateralisation safety module\n  SafetyData public safetyData;\n\n  /// @notice Whitelisted smart contract integrations\n  mapping(address => bool) public whitelistedWrappers;\n\n  event Stake(address indexed user, uint256 amount);\n  event Withdraw(address indexed user, address indexed to, uint256 amount);\n  event Cooldown(address indexed user, uint256 percentage);\n  event CooldownExit(address indexed user);\n  event SlashRateChange(uint256 newRate);\n  event Recollateralise();\n  event WrapperWhitelist(address wallet);\n  event WrapperBlacklist(address wallet);\n\n  /***************************************\n                    INIT\n    ****************************************/\n\n  /**\n   * @param _nexus System nexus\n   * @param _rewardsToken Token that is being distributed as a reward. eg MTA\n   * @param _achievementsManager Centralised manager of achievements\n   * @param _stakedToken Core token that is staked and tracked (e.g. MTA)\n   * @param _cooldownSeconds Seconds a user must wait after she initiates her cooldown before withdrawal is possible\n   * @param _unstakeWindow Window in which it is possible to withdraw, following the cooldown period\n   */\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _achievementsManager,\n    address _stakedToken,\n    uint256 _cooldownSeconds,\n    uint256 _unstakeWindow\n  ) PPOGamifiedVotingToken(_nexus, _rewardsToken, _achievementsManager) {\n    STAKED_TOKEN = IERC20(_stakedToken);\n    COOLDOWN_SECONDS = _cooldownSeconds;\n    UNSTAKE_WINDOW = _unstakeWindow;\n  }\n\n  // TODO allow owner to change name and symbol\n  /**\n   * @param _rewardsDistributorArg mStable Rewards Distributor\n   */\n  function __PPOStaking_init(address _rewardsDistributorArg)\n    public\n    initializer\n  {\n    __PPOGamifiedToken_init(\"PPO Power\", \"pPPO\", _rewardsDistributorArg);\n    _initializeReentrancyGuard();\n    safetyData = SafetyData({\n      collateralisationRatio: 1e18,\n      slashingPercentage: 0\n    });\n  }\n\n  /**\n   * @dev Only the recollateralisation module, as specified in the mStable Nexus, can execute this\n   */\n  modifier onlyRecollateralisationModule() {\n    require(\n      _msgSender() == _recollateraliser(),\n      \"Only Recollateralisation Module\"\n    );\n    _;\n  }\n\n  /**\n   * @dev This protects against fn's being called after a recollateralisation event, when the contract is essentially finished\n   */\n  modifier onlyBeforeRecollateralisation() {\n    _onlyBeforeRecollateralisation();\n    _;\n  }\n\n  function _onlyBeforeRecollateralisation() internal view {\n    require(\n      safetyData.collateralisationRatio == 1e18,\n      \"Only while fully collateralised\"\n    );\n  }\n\n  /**\n   * @dev Only whitelisted contracts can call core fns. mStable governors can whitelist and de-whitelist wrappers.\n   * Access may be given to yield optimisers to boost rewards, but creating unlimited and ungoverned wrappers is unadvised.\n   */\n  modifier assertNotContract() {\n    _assertNotContract();\n    _;\n  }\n\n  function _assertNotContract() internal view {\n    if (_msgSender() != tx.origin) {\n      require(whitelistedWrappers[_msgSender()], \"Not a whitelisted contract\");\n    }\n  }\n\n  /***************************************\n                    ACTIONS\n    ****************************************/\n\n  // TODO Add reentrancyGuard here\n  /**\n   * TODO Add helper function to allow staking and delegation to happen\n   * together if msg.sender == _recipient (we do not want anyone besides\n   * the position holder to delegate)\n   */\n  /**\n   * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\n   * boosts their voting power. Take the opportunity to change delegatee.\n   * @param _recipient Recipient of staked position\n   * @param _amount Units of STAKED_TOKEN to stake\n   */\n  function stake(address _recipient, uint256 _amount)\n    external\n    assertNotContract\n  {\n    if (_amount == 0) return;\n    STAKED_TOKEN.safeTransferFrom(_msgSender(), address(this), _amount);\n\n    // 1. Deal with cooldown\n    //      If a user is currently in a cooldown period, re-calculate their cooldown timestamp\n    Balance memory _oldBalance = _balances[_recipient];\n    //      If we have missed the unstake window, or the user has chosen to exit the cooldown,\n    //      then reset the timestamp to 0\n    bool _exitCooldown = (_oldBalance.cooldownTimestamp > 0 &&\n      block.timestamp >\n      (_oldBalance.cooldownTimestamp + COOLDOWN_SECONDS + UNSTAKE_WINDOW));\n    if (_exitCooldown) {\n      emit CooldownExit(_recipient);\n    }\n\n    // 2. Settle the stake by depositing the STAKED_TOKEN and minting voting power\n    _mintRaw(_recipient, _amount, _exitCooldown);\n\n    emit Stake(_recipient, _amount);\n  }\n\n  /**\n   * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\n   * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\n   * @param _amount Units of raw token to withdraw\n   * @param _recipient Address of beneficiary who will receive the raw tokens\n   * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\n   * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\n   **/\n  function withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) external {\n    _withdraw(_amount, _recipient, _amountIncludesFee, _exitCooldown);\n  }\n\n  /**\n   * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\n   * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\n   * @param _amount Units of raw token to withdraw\n   * @param _recipient Address of beneficiary who will receive the raw tokens\n   * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\n   * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\n   **/\n  function _withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) internal assertNotContract {\n    require(_amount != 0, \"INVALID_ZERO_AMOUNT\");\n\n    // Is the contract post-recollateralisation?\n    if (safetyData.collateralisationRatio != 1e18) {\n      // 1. If recollateralisation has occured, the contract is finished and we can skip all checks\n      _burnRaw(_msgSender(), _amount, false, true);\n      // 2. Return a proportionate amount of tokens, based on the collateralisation ratio\n      STAKED_TOKEN.safeTransfer(\n        _recipient,\n        (_amount * safetyData.collateralisationRatio) / 1e18\n      );\n      emit Withdraw(_msgSender(), _recipient, _amount);\n    } else {\n      // 1. If no recollateralisation has occured, the user must be within their UNSTAKE_WINDOW period in order to withdraw\n      Balance memory oldBalance = _balances[_msgSender()];\n      require(\n        block.timestamp > oldBalance.cooldownTimestamp + COOLDOWN_SECONDS,\n        \"INSUFFICIENT_COOLDOWN\"\n      );\n      require(\n        block.timestamp - (oldBalance.cooldownTimestamp + COOLDOWN_SECONDS) <=\n          UNSTAKE_WINDOW,\n        \"UNSTAKE_WINDOW_FINISHED\"\n      );\n\n      // 2. Get current balance\n      Balance memory balance = _balances[_msgSender()];\n\n      // 3. Apply redemption fee\n      //      e.g. (55e18 / 5e18) - 2e18 = 9e18 / 100 = 9e16\n      uint256 feeRate = calcRedemptionFeeRate(balance.weightedTimestamp);\n      //      fee = amount * 1e18 / feeRate\n      //      totalAmount = amount + fee\n      uint256 totalWithdraw = _amountIncludesFee\n        ? _amount\n        : (_amount * (1e18 + feeRate)) / 1e18;\n      uint256 userWithdrawal = (totalWithdraw * 1e18) / (1e18 + feeRate);\n\n      //      Check for percentage withdrawal\n      uint256 maxWithdrawal = oldBalance.cooldownUnits;\n      require(totalWithdraw <= maxWithdrawal, \"Exceeds max withdrawal\");\n\n      // 4. Exit cooldown if the user has specified, or if they have withdrawn everything\n      // Otherwise, update the percentage remaining proportionately\n      bool exitCooldown = _exitCooldown || totalWithdraw == maxWithdrawal;\n\n      // 5. Settle the withdrawal by burning the voting tokens\n      _burnRaw(_msgSender(), totalWithdraw, exitCooldown, false);\n      //      Log any redemption fee to the rewards contract\n      _notifyAdditionalReward(totalWithdraw - userWithdrawal);\n      //      Finally transfer tokens back to recipient\n      STAKED_TOKEN.safeTransfer(_recipient, userWithdrawal);\n\n      emit Withdraw(_msgSender(), _recipient, _amount);\n    }\n  }\n\n  /**\n   * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\n   * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\n   * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\n   * @param _units Units of stake to cooldown for\n   **/\n  function startCooldown(uint256 _units) external {\n    _startCooldown(_units);\n  }\n\n  /**\n   * @dev Ends the cooldown of the sender and give them back their full voting power. This can be used to signal that\n   * the user no longer wishes to exit the system. Note, the cooldown can also be reset, more smoothly, as part of a stake or\n   * withdraw transaction.\n   **/\n  function endCooldown() external {\n    require(_balances[_msgSender()].cooldownTimestamp != 0, \"No cooldown\");\n\n    _exitCooldownPeriod(_msgSender());\n\n    emit CooldownExit(_msgSender());\n  }\n\n  /**\n   * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\n   * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\n   * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\n   * @param _units Units of stake to cooldown for\n   **/\n  function _startCooldown(uint256 _units) internal {\n    require(balanceOf(_msgSender()) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n\n    _enterCooldownPeriod(_msgSender(), _units);\n\n    emit Cooldown(_msgSender(), _units);\n  }\n\n  /***************************************\n                    ADMIN\n    ****************************************/\n\n  /**\n   * @dev This is a write function allowing the whitelisted recollateralisation module to slash stakers here and take\n   * the capital to use to recollateralise any lost value in the system. Trusting that the recollateralisation module has\n   * sufficient protections put in place. Note, once this has been executed, the contract is now finished, and undercollateralised,\n   * meaning that all users must withdraw, and will only receive a proportionate amount back relative to the colRatio.\n   **/\n  function emergencyRecollateralisation()\n    external\n    onlyRecollateralisationModule\n    onlyBeforeRecollateralisation\n  {\n    // 1. Change collateralisation rate\n    safetyData.collateralisationRatio = 1e18 - safetyData.slashingPercentage;\n    // 2. Take slashing percentage\n    uint256 balance = STAKED_TOKEN.balanceOf(address(this));\n    STAKED_TOKEN.safeTransfer(\n      _recollateraliser(),\n      (balance * safetyData.slashingPercentage) / 1e18\n    );\n    // 3. No functions should work anymore because the colRatio has changed\n    emit Recollateralise();\n  }\n\n  /**\n   * @dev Governance can change the slashing percentage here (initially 0). This is the amount of a stakers capital that is at\n   * risk in the recollateralisation process.\n   * @param _newRate Rate, where 50% == 5e17\n   **/\n  function changeSlashingPercentage(uint256 _newRate)\n    external\n    onlyGovernor\n    onlyBeforeRecollateralisation\n  {\n    require(_newRate <= 5e17, \"Cannot exceed 50%\");\n\n    safetyData.slashingPercentage = SafeCast.toUint128(_newRate);\n\n    emit SlashRateChange(_newRate);\n  }\n\n  /**\n   * @dev Allows governance to whitelist a smart contract to interact with the StakedToken (for example a yield aggregator or simply\n   * a Gnosis SAFE or other)\n   * @param _wrapper Address of the smart contract to list\n   **/\n  function whitelistWrapper(address _wrapper) external onlyGovernor {\n    whitelistedWrappers[_wrapper] = true;\n\n    emit WrapperWhitelist(_wrapper);\n  }\n\n  /**\n   * @dev Allows governance to blacklist a smart contract to end it's interaction with the StakedToken\n   * @param _wrapper Address of the smart contract to blacklist\n   **/\n  function blackListWrapper(address _wrapper) external onlyGovernor {\n    whitelistedWrappers[_wrapper] = false;\n\n    emit WrapperBlacklist(_wrapper);\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev fee = sqrt(300/x)-2.5, where x = weeks since user has staked\n   * @param _weightedTimestamp The users weightedTimestamp\n   * @return _feeRate where 1% == 1e16\n   */\n  function calcRedemptionFeeRate(uint256 _weightedTimestamp)\n    public\n    view\n    returns (uint256 _feeRate)\n  {\n    uint256 weeksStaked = ((block.timestamp - _weightedTimestamp) * 1e18) /\n      ONE_WEEK;\n    if (weeksStaked > 3e18) {\n      // e.g. weeks = 1  = sqrt(300e18) = 17320508075\n      // e.g. weeks = 10 = sqrt(30e18) =   5477225575\n      // e.g. weeks = 26 = sqrt(11.5) =    3391164991\n      _feeRate = Root.sqrt(300e36 / weeksStaked) * 1e7;\n      // e.g. weeks = 1  = 173e15 - 25e15 = 148e15 or 14.8%\n      // e.g. weeks = 10 =  55e15 - 25e15 = 30e15 or 3%\n      // e.g. weeks = 26 =  34e15 - 25e15 = 9e15 or 0.9%\n      _feeRate = _feeRate < 25e15 ? 0 : _feeRate - 25e15;\n    } else {\n      _feeRate = 75e15;\n    }\n  }\n\n  uint256[48] private __gap;\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/IStakedToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../deps/GamifiedTokenStructs.sol\";\n\ninterface IStakedToken {\n  // GETTERS\n  function COOLDOWN_SECONDS() external view returns (uint256);\n\n  function UNSTAKE_WINDOW() external view returns (uint256);\n\n  function STAKED_TOKEN() external view returns (IERC20);\n\n  function getRewardToken() external view returns (address);\n\n  function pendingAdditionalReward() external view returns (uint256);\n\n  function whitelistedWrappers(address) external view returns (bool);\n\n  function balanceData(address _account)\n    external\n    view\n    returns (Balance memory);\n\n  function balanceOf(address _account) external view returns (uint256);\n\n  function rawBalanceOf(address _account)\n    external\n    view\n    returns (uint256, uint256);\n\n  function calcRedemptionFeeRate(uint32 _weightedTimestamp)\n    external\n    view\n    returns (uint256 _feeRate);\n\n  function safetyData()\n    external\n    view\n    returns (uint128 collateralisationRatio, uint128 slashingPercentage);\n\n  function delegates(address account) external view returns (address);\n\n  function getPastTotalSupply(uint256 blockNumber)\n    external\n    view\n    returns (uint256);\n\n  function getPastVotes(address account, uint256 blockNumber)\n    external\n    view\n    returns (uint256);\n\n  function getVotes(address account) external view returns (uint256);\n\n  // HOOKS/PERMISSIONED\n  function applyQuestMultiplier(address _account, uint8 _newMultiplier)\n    external;\n\n  // ADMIN\n  function whitelistWrapper(address _wrapper) external;\n\n  function blackListWrapper(address _wrapper) external;\n\n  function changeSlashingPercentage(uint256 _newRate) external;\n\n  function emergencyRecollateralisation() external;\n\n  function setGovernanceHook(address _newHook) external;\n\n  // USER\n  function stake(uint256 _amount) external;\n\n  function stake(uint256 _amount, address _delegatee) external;\n\n  function stake(uint256 _amount, bool _exitCooldown) external;\n\n  function withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) external;\n\n  function delegate(address delegatee) external;\n\n  function startCooldown(uint256 _units) external;\n\n  function endCooldown() external;\n\n  function reviewTimestamp(address _account) external;\n\n  function claimReward() external;\n\n  function claimReward(address _to) external;\n\n  // Backwards compatibility\n  function createLock(uint256 _value, uint256) external;\n\n  function exit() external;\n\n  function increaseLockAmount(uint256 _value) external;\n\n  function increaseLockLength(uint256) external;\n}\n"
    },
    "contracts/ppo-staking/shared/Root.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nlibrary Root {\n  /**\n   * @dev Returns the square root of a given number\n   * @param x Input\n   * @return y Square root of Input\n   */\n  function sqrt(uint256 x) internal pure returns (uint256 y) {\n    if (x == 0) return 0;\n    else {\n      uint256 xx = x;\n      uint256 r = 1;\n      if (xx >= 0x100000000000000000000000000000000) {\n        xx >>= 128;\n        r <<= 64;\n      }\n      if (xx >= 0x10000000000000000) {\n        xx >>= 64;\n        r <<= 32;\n      }\n      if (xx >= 0x100000000) {\n        xx >>= 32;\n        r <<= 16;\n      }\n      if (xx >= 0x10000) {\n        xx >>= 16;\n        r <<= 8;\n      }\n      if (xx >= 0x100) {\n        xx >>= 8;\n        r <<= 4;\n      }\n      if (xx >= 0x10) {\n        xx >>= 4;\n        r <<= 2;\n      }\n      if (xx >= 0x8) {\n        r <<= 1;\n      }\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1; // Seven iterations should be enough\n      uint256 r1 = x / r;\n      return uint256(r < r1 ? r : r1);\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/shared/InitializableReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract InitializableReentrancyGuard {\n  bool private _notEntered;\n\n  function _initializeReentrancyGuard() internal {\n    // Storing an initial non-zero value makes deployment a bit more\n    // expensive, but in exchange the refund on every call to nonReentrant\n    // will be lower in amount. Since refunds are capped to a percetange of\n    // the total transaction's gas, it is best to keep them low in cases\n    // like this one, to increase the likelihood of the full refund coming\n    // into effect.\n    _notEntered = true;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _notEntered = false;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _notEntered = true;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/deps/GamifiedTokenStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nstruct Balance {\n  /// units of staking token that has been deposited and consequently wrapped\n  uint88 raw;\n  /// (block.timestamp - weightedTimestamp) represents the seconds a user has had their full raw balance wrapped.\n  /// If they deposit or withdraw, the weightedTimestamp is dragged towards block.timestamp proportionately\n  uint32 weightedTimestamp;\n  /// multiplier awarded for staking for a long time\n  uint8 timeMultiplier;\n  /// multiplier duplicated from QuestManager\n  uint8 questMultiplier;\n  /// Time at which the relative cooldown began\n  uint32 cooldownTimestamp;\n  /// Units up for cooldown\n  uint88 cooldownUnits;\n}\n\nstruct QuestBalance {\n  /// last timestamp at which the user made a write action to this contract\n  uint32 lastAction;\n  /// permanent multiplier applied to an account, awarded for PERMANENT QuestTypes\n  uint8 permMultiplier;\n  /// multiplier that decays after each \"season\" (~9 months) by 75%, to avoid multipliers getting out of control\n  uint8 seasonMultiplier;\n}\n\n/// @notice Quests can either give permanent rewards or only for the season\nenum QuestType {\n  PERMANENT,\n  SEASONAL\n}\n\n/// @notice Quests can be turned off by the questMaster. All those who already completed remain\nenum QuestStatus {\n  ACTIVE,\n  EXPIRED\n}\nstruct Quest {\n  /// Type of quest rewards\n  QuestType model;\n  /// Multiplier, from 1 == 1.01x to 100 == 2.00x\n  uint8 multiplier;\n  /// Is the current quest valid?\n  QuestStatus status;\n  /// Expiry date in seconds for the quest\n  uint32 expiry;\n}\n"
    },
    "contracts/ppo-staking/mocks/MockPPOStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"../governance/staking/PPOStaking.sol\";\n\ncontract MockPPOStaking is PPOStaking {\n  constructor(\n    address _newNexus,\n    address _newRewardsToken,\n    address _newAchievementsManager,\n    address _newStakedToken,\n    uint256 _newCooldownSeconds,\n    uint256 _newUnstakeWindow\n  )\n    PPOStaking(\n      _newNexus,\n      _newRewardsToken,\n      _newAchievementsManager,\n      _newStakedToken,\n      _newCooldownSeconds,\n      _newUnstakeWindow\n    )\n  {}\n\n  function __mockPPOStaking_init(address _newRewardsDistributor) public {\n    __PPOStaking_init(_newRewardsDistributor);\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/versions/MV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\n// Internal\nimport {Initializable} from \"../../shared/@openzeppelin-2.5/Initializable.sol\";\nimport {InitializableToken, IERC20} from \"../../shared/InitializableToken.sol\";\nimport {ImmutableModule} from \"../../shared/ImmutableModule.sol\";\nimport {InitializableReentrancyGuard} from \"../../shared/InitializableReentrancyGuard.sol\";\nimport {IMasset} from \"../../interfaces/IMasset.sol\";\nimport \"../MassetStructs.sol\";\n\n// Libs\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {StableMath} from \"../../shared/StableMath.sol\";\nimport {MassetLogic} from \"../MassetLogic.sol\";\nimport {MassetManager} from \"../MassetManager.sol\";\n\n/**\n * @title   Masset\n * @author  mStable\n * @notice  An incentivised constant sum market maker with hard limits at max region. This supports\n *          low slippage swaps and applies penalties towards min and max regions. AMM produces a\n *          stablecoin (mAsset) and redirects lending market interest and swap fees to the savings\n *          contract, producing a second yield bearing asset.\n * @dev     VERSION: 3.0\n *          DATE:    2021-01-22\n */\ncontract MV2 is\n  IMasset,\n  Initializable,\n  InitializableToken,\n  ImmutableModule,\n  InitializableReentrancyGuard\n{\n  using StableMath for uint256;\n\n  // Forging Events\n  event Minted(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address input,\n    uint256 inputQuantity\n  );\n  event MintedMulti(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] inputs,\n    uint256[] inputQuantities\n  );\n  event Swapped(\n    address indexed swapper,\n    address input,\n    address output,\n    uint256 outputAmount,\n    uint256 scaledFee,\n    address recipient\n  );\n  event Redeemed(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address output,\n    uint256 outputQuantity,\n    uint256 scaledFee\n  );\n  event RedeemedMulti(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] outputs,\n    uint256[] outputQuantity,\n    uint256 scaledFee\n  );\n\n  // State Events\n  event CacheSizeChanged(uint256 cacheSize);\n  event FeesChanged(uint256 swapFee, uint256 redemptionFee);\n  event WeightLimitsChanged(uint128 min, uint128 max);\n  event ForgeValidatorChanged(address forgeValidator);\n  event DeficitMinted(uint256 amt);\n  event SurplusBurned(address creditor, uint256 amt);\n  // Release 1.0 VARS\n  address public deprecated_forgeValidator;\n  bool private deprecated_forgeValidatorLocked;\n  // Deprecated - maintain for storage layout in mUSD\n  address private deprecated_basketManager;\n\n  // Basic redemption fee information\n  uint256 public deprecated_swapFee;\n  uint256 private MAX_FEE;\n\n  // Release 1.1 VARS\n  uint256 public deprecated_redemptionFee;\n\n  // Release 1.2 VARS\n  uint256 public deprecated_cacheSize;\n  uint256 public deprecated_surplus;\n\n  // Release 2.0 VARS\n  // Struct holding Basket details\n  BassetPersonal[] public deprecated_bAssetPersonal;\n  BassetData[] public deprecated_bAssetData;\n  mapping(address => uint8) public override bAssetIndexes;\n  uint8 public deprecated_maxBassets;\n  BasketState public deprecated_basket;\n  // Amplification Data\n  uint256 private constant A_PRECISION = 100;\n  AmpData public deprecated_ampData;\n  WeightLimits public deprecated_weightLimits;\n  // Core data storage\n  uint256 private immutable RECOL_FEE;\n  MassetData public data;\n\n  /**\n   * @dev Constructor to set immutable bytecode\n   * @param _nexus   Nexus address\n   */\n  constructor(address _nexus, uint256 _recolFee) ImmutableModule(_nexus) {\n    require(_recolFee <= 5e13, \"RecolFee too high\");\n    RECOL_FEE = _recolFee;\n  }\n\n  /**\n   * @dev Initialization function for upgradable proxy contract.\n   *      This function should be called via Proxy just after contract deployment.\n   *      To avoid variable shadowing appended `Arg` after arguments name.\n   * @param _nameArg          Name of the mAsset\n   * @param _symbolArg        Symbol of the mAsset\n   * @param _bAssets          Array of Basset data\n   */\n  function initialize(\n    string calldata _nameArg,\n    string calldata _symbolArg,\n    BassetPersonal[] calldata _bAssets,\n    BasicConfig memory _config\n  ) public initializer {\n    InitializableToken._initialize(_nameArg, _symbolArg);\n\n    _initializeReentrancyGuard();\n\n    uint256 len = _bAssets.length;\n    require(len > 0, \"No bAssets\");\n    for (uint256 i = 0; i < len; i++) {\n      MassetManager.addBasset(\n        data.bAssetPersonal,\n        data.bAssetData,\n        bAssetIndexes,\n        _bAssets[i].addr,\n        _bAssets[i].integrator,\n        1e8,\n        _bAssets[i].hasTxFee\n      );\n    }\n\n    uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\n    data.ampData = AmpData(startA, startA, 0, 0);\n    data.weightLimits = _config.limits;\n\n    data.swapFee = 6e14;\n    data.redemptionFee = 3e14;\n    data.cacheSize = 1e17;\n  }\n\n  /**\n   * @dev Verifies that the caller is the Savings Manager contract\n   */\n  modifier onlySavingsManager() {\n    _isSavingsManager();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isSavingsManager() internal view {\n    require(_savingsManager() == msg.sender, \"Must be savings manager\");\n  }\n\n  /**\n   * @dev Requires the overall basket composition to be healthy\n   */\n  modifier whenHealthy() {\n    _isHealthy();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isHealthy() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol && !basket_.failed, \"Unhealthy\");\n  }\n\n  /**\n   * @dev Requires the basket not to be undergoing recollateralisation\n   */\n  modifier whenNoRecol() {\n    _noRecol();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _noRecol() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol, \"In recol\");\n  }\n\n  /***************************************\n                MINTING (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\n   *      must have approval to spend the senders bAsset\n   * @param _input             Address of the bAsset to deposit for the minted mAsset.\n   * @param _inputQuantity     Quantity in bAsset units\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Receipient of the newly minted mAsset tokens\n   * @return mintOutput        Quantity of newly minted mAssets for the deposited bAsset.\n   */\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.mint(\n      data,\n      _getConfig(),\n      input,\n      _inputQuantity,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit Minted(msg.sender, _recipient, mintOutput, _input, _inputQuantity);\n  }\n\n  /**\n   * @dev Mint with multiple bAssets, at a 1:1 ratio to mAsset. This contract\n   *      must have approval to spend the senders bAssets\n   * @param _inputs            Non-duplicate address array of bASset addresses to deposit for the minted mAsset tokens.\n   * @param _inputQuantities   Quantity of each bAsset to deposit for the minted mAsset.\n   *                           Order of array should mirror the above bAsset addresses.\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Address to receive the newly minted mAsset tokens\n   * @return mintOutput    Quantity of newly minted mAssets for the deposited bAssets.\n   */\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n\n    uint8[] memory indexes = _getAssets(_inputs);\n    mintOutput = MassetLogic.mintMulti(\n      data,\n      _getConfig(),\n      indexes,\n      _inputQuantities,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit MintedMulti(\n      msg.sender,\n      _recipient,\n      mintOutput,\n      _inputs,\n      _inputQuantities\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _input             Address of the bAsset to deposit for the minted mAsset\n   * @param _inputQuantity     Quantity in bAsset units\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintOutput(address _input, uint256 _inputQuantity)\n    external\n    view\n    override\n    returns (uint256 mintOutput)\n  {\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.computeMint(\n      data.bAssetData,\n      input.idx,\n      _inputQuantity,\n      _getConfig()\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\n   * @param _inputQuantities  Quantity of each bAsset to deposit for the minted mAsset.\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintMultiOutput(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities\n  ) external view override returns (uint256 mintOutput) {\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n    uint8[] memory indexes = _getAssets(_inputs);\n    return\n      MassetLogic.computeMintMulti(\n        data.bAssetData,\n        indexes,\n        _inputQuantities,\n        _getConfig()\n      );\n  }\n\n  /***************************************\n                SWAP (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Swaps one bAsset for another bAsset using the bAsset addresses.\n   * bAsset <> bAsset swaps will incur a small fee (swapFee()).\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\n   * @param _recipient         Address to transfer output asset to\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 swapOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    uint256 scaledFee;\n    (swapOutput, scaledFee) = MassetLogic.swap(\n      data,\n      _getConfig(),\n      input,\n      output,\n      _inputQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Swapped(\n      msg.sender,\n      input.addr,\n      output.addr,\n      swapOutput,\n      scaledFee,\n      _recipient\n    );\n  }\n\n  /**\n   * @dev Determines both if a trade is valid, and the expected fee or output.\n   * Swap is valid if it does not result in the input asset exceeding its maximum weight.\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view override returns (uint256 swapOutput) {\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    // 1. Load the bAssets from storage\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    // 2. If a bAsset swap, calculate the validity, output and fee\n    (swapOutput, ) = MassetLogic.computeSwap(\n      data.bAssetData,\n      input.idx,\n      output.idx,\n      _inputQuantity,\n      data.swapFee,\n      _getConfig()\n    );\n  }\n\n  /***************************************\n                REDEMPTION (PUBLIC)\n    ****************************************/\n\n  /**\n   * @notice Redeems a specified quantity of mAsset in return for a bAsset specified by bAsset address.\n   * The bAsset is sent to the specified recipient.\n   * The bAsset quantity is relative to current vault balance levels and desired mAsset quantity.\n   * The quantity of mAsset is burnt as payment.\n   * A minimum quantity of bAsset is specified to protect against price slippage between the mAsset and bAsset.\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt mAssets. This protects against slippage.\n   * @param _recipient         Address to transfer the withdrawn bAssets to.\n   * @return outputQuantity    Quanity of bAsset units received for the burnt mAssets\n   */\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 outputQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    // Get config before burning. Config > Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    uint256 scaledFee;\n    (outputQuantity, scaledFee) = MassetLogic.redeem(\n      data,\n      config,\n      output,\n      _mAssetQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Redeemed(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      output.addr,\n      outputQuantity,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\n   * balance levels and desired mAsset quantity. Burns the mAsset as payment.\n   * @param _mAssetQuantity       Quantity of mAsset to redeem\n   * @param _minOutputQuantities  Min units of output to receive\n   * @param _recipient            Address to credit the withdrawn bAssets\n   */\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256[] memory outputQuantities)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    // Get config before burning. Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    address[] memory outputs;\n    uint256 scaledFee;\n    (scaledFee, outputs, outputQuantities) = MassetLogic.redeemProportionately(\n      data,\n      config,\n      _mAssetQuantity,\n      _minOutputQuantities,\n      _recipient\n    );\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      outputs,\n      outputQuantities,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\n   *      relative Masset quantity from the sender. Sender also incurs a small fee on the outgoing asset.\n   * @param _outputs           Addresses of the bAssets to receive\n   * @param _outputQuantities  Units of the bAssets to redeem\n   * @param _maxMassetQuantity Maximum mAsset quantity to burn for the received bAssets. This protects against slippage.\n   * @param _recipient         Address to receive the withdrawn bAssets\n   * @return mAssetQuantity    Quantity of mAsset units burned plus the swap fee to pay for the redeemed bAssets\n   */\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 mAssetQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n    require(_maxMassetQuantity > 0, \"Qty==0\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    uint256 fee;\n    (mAssetQuantity, fee) = MassetLogic.redeemExactBassets(\n      data,\n      _getConfig(),\n      indexes,\n      _outputQuantities,\n      _maxMassetQuantity,\n      _recipient\n    );\n\n    _burn(msg.sender, mAssetQuantity);\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      mAssetQuantity,\n      _outputs,\n      _outputQuantities,\n      fee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt mAssets\n   */\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n    external\n    view\n    override\n    returns (uint256 bAssetOutput)\n  {\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    (bAssetOutput, ) = MassetLogic.computeRedeem(\n      data.bAssetData,\n      output.idx,\n      _mAssetQuantity,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _outputs           Addresses of the bAsset to receive\n   * @param _outputQuantities  Quantities of bAsset to redeem\n   * @return mAssetQuantity    Estimated quantity of mAsset units needed to burn to receive output\n   */\n  function getRedeemExactBassetsOutput(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities\n  ) external view override returns (uint256 mAssetQuantity) {\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    // calculate the value of mAssets need to cover the value of bAssets being redeemed\n    (mAssetQuantity, ) = MassetLogic.computeRedeemExact(\n      data.bAssetData,\n      indexes,\n      _outputQuantities,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev Get basket details for `Masset_MassetStructs.Basket`\n   * @return b   Basket struct\n   */\n  function getBasket() external view override returns (bool, bool) {\n    return (data.basket.undergoingRecol, data.basket.failed);\n  }\n\n  /**\n   * @dev Get data for a all bAssets in basket\n   * @return personal  Struct[] with full bAsset data\n   * @return bData      Number of bAssets in the Basket\n   */\n  function getBassets()\n    external\n    view\n    override\n    returns (BassetPersonal[] memory personal, BassetData[] memory bData)\n  {\n    return (data.bAssetPersonal, data.bAssetData);\n  }\n\n  /**\n   * @dev Get data for a specific bAsset, if it exists\n   * @param _bAsset   Address of bAsset\n   * @return personal  Struct with full bAsset data\n   * @return bData  Struct with full bAsset data\n   */\n  function getBasset(address _bAsset)\n    external\n    view\n    override\n    returns (BassetPersonal memory personal, BassetData memory bData)\n  {\n    uint8 idx = bAssetIndexes[_bAsset];\n    personal = data.bAssetPersonal[idx];\n    require(personal.addr == _bAsset, \"Invalid asset\");\n    bData = data.bAssetData[idx];\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function getConfig() external view returns (InvariantConfig memory config) {\n    return _getConfig();\n  }\n\n  /**\n   * @notice Gets the price of the fpToken, and invariant value k\n   * @return price    Price of an fpToken\n   * @return k        Total value of basket, k\n   */\n  function getPrice()\n    external\n    view\n    override\n    returns (uint256 price, uint256 k)\n  {\n    return MassetLogic.computePrice(data.bAssetData, _getConfig());\n  }\n\n  /***************************************\n                GETTERS - INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Gets a bAsset from storage\n   * @param _asset      Address of the asset\n   * @return asset      Struct containing bAsset details (idx, data)\n   */\n  function _getAsset(address _asset)\n    internal\n    view\n    returns (Asset memory asset)\n  {\n    asset.idx = bAssetIndexes[_asset];\n    asset.addr = _asset;\n    asset.exists = data.bAssetPersonal[asset.idx].addr == _asset;\n    require(asset.exists, \"Invalid asset\");\n  }\n\n  /**\n   * @dev Gets a an array of bAssets from storage and protects against duplicates\n   * @param _bAssets    Addresses of the assets\n   * @return indexes    Indexes of the assets\n   */\n  function _getAssets(address[] memory _bAssets)\n    internal\n    view\n    returns (uint8[] memory indexes)\n  {\n    uint256 len = _bAssets.length;\n\n    indexes = new uint8[](len);\n\n    Asset memory input_;\n    for (uint256 i = 0; i < len; i++) {\n      input_ = _getAsset(_bAssets[i]);\n      indexes[i] = input_.idx;\n\n      for (uint256 j = i + 1; j < len; j++) {\n        require(_bAssets[i] != _bAssets[j], \"Duplicate asset\");\n      }\n    }\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function _getConfig() internal view returns (InvariantConfig memory) {\n    return\n      InvariantConfig(\n        totalSupply() + data.surplus,\n        _getA(),\n        data.weightLimits,\n        RECOL_FEE\n      );\n  }\n\n  /**\n   * @dev Gets current amplification var A\n   */\n  function _getA() internal view returns (uint256) {\n    AmpData memory ampData_ = data.ampData;\n\n    uint64 endA = ampData_.targetA;\n    uint64 endTime = ampData_.rampEndTime;\n\n    // If still changing, work out based on current timestmap\n    if (block.timestamp < endTime) {\n      uint64 startA = ampData_.initialA;\n      uint64 startTime = ampData_.rampStartTime;\n\n      (uint256 elapsed, uint256 total) = (\n        block.timestamp - startTime,\n        endTime - startTime\n      );\n\n      if (endA > startA) {\n        return startA + (((endA - startA) * elapsed) / total);\n      } else {\n        return startA - (((startA - endA) * elapsed) / total);\n      }\n    }\n    // Else return final value\n    else {\n      return endA;\n    }\n  }\n\n  /***************************************\n                    YIELD\n    ****************************************/\n\n  /**\n   * @dev Converts recently accrued swap and redeem fees into mAsset\n   * @return mintAmount   mAsset units generated from swap and redeem fees\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectInterest()\n    external\n    override\n    onlySavingsManager\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    // Set the surplus variable to 1 to optimise for SSTORE costs.\n    // If setting to 0 here, it would save 5k per savings deposit, but cost 20k for the\n    // first surplus call (a SWAP or REDEEM).\n    uint256 surplusFees = data.surplus;\n    if (surplusFees > 1) {\n      mintAmount = surplusFees - 1;\n      data.surplus = 1;\n\n      // mint new mAsset to savings manager\n      _mint(msg.sender, mintAmount);\n      emit MintedMulti(\n        address(this),\n        msg.sender,\n        mintAmount,\n        new address[](0),\n        new uint256[](0)\n      );\n    }\n    newSupply = totalSupply();\n  }\n\n  /**\n   * @dev Collects the interest generated from the Basket, minting a relative\n   *      amount of mAsset and sends it over to the SavingsMassetManager.\n   * @return mintAmount   mAsset units generated from interest collected from lending markets\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectPlatformInterest()\n    external\n    override\n    onlySavingsManager\n    whenHealthy\n    nonReentrant\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    (uint8[] memory idxs, uint256[] memory gains) = MassetManager\n      .collectPlatformInterest(data.bAssetPersonal, data.bAssetData);\n\n    mintAmount = MassetLogic.computeMintMulti(\n      data.bAssetData,\n      idxs,\n      gains,\n      _getConfig()\n    );\n\n    require(mintAmount > 0, \"Must collect something\");\n\n    _mint(msg.sender, mintAmount);\n    emit MintedMulti(\n      address(this),\n      msg.sender,\n      mintAmount,\n      new address[](0),\n      gains\n    );\n\n    newSupply = totalSupply();\n  }\n\n  /***************************************\n                    STATE\n    ****************************************/\n\n  /**\n   * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\n   *      _cacheSize * totalSupply / 2 under normal circumstances.\n   * @param _cacheSize Maximum percent of total mAsset supply to hold for each bAsset\n   */\n  function setCacheSize(uint256 _cacheSize) external override onlyGovernor {\n    require(_cacheSize <= 2e17, \"Must be <= 20%\");\n\n    data.cacheSize = _cacheSize;\n\n    emit CacheSizeChanged(_cacheSize);\n  }\n\n  /**\n   * @dev Set the ecosystem fee for sewapping bAssets or redeeming specific bAssets\n   * @param _swapFee Fee calculated in (%/100 * 1e18)\n   */\n  function setFees(uint256 _swapFee, uint256 _redemptionFee)\n    external\n    override\n    onlyGovernor\n  {\n    require(_swapFee <= MAX_FEE, \"Swap rate oob\");\n    require(_redemptionFee <= MAX_FEE, \"Redemption rate oob\");\n\n    data.swapFee = _swapFee;\n    data.redemptionFee = _redemptionFee;\n\n    emit FeesChanged(_swapFee, _redemptionFee);\n  }\n\n  /**\n   * @dev Set the maximum weight for a given bAsset\n   * @param _min Weight where 100% = 1e18\n   * @param _max Weight where 100% = 1e18\n   */\n  function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\n    require(_min <= 1e18 / (data.bAssetData.length * 2), \"Min weight oob\");\n    require(_max >= 1e18 / (data.bAssetData.length - 1), \"Max weight oob\");\n\n    data.weightLimits = WeightLimits(_min, _max);\n\n    emit WeightLimitsChanged(_min, _max);\n  }\n\n  /**\n   * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\n   * @param _bAsset   bAsset address\n   * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\n   */\n  function setTransferFeesFlag(address _bAsset, bool _flag)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.setTransferFeesFlag(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _flag\n    );\n  }\n\n  /**\n   * @dev Transfers all collateral from one lending market to another - used initially\n   *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\n   *      tx fee enabled assets. Supports going from no integration to integration, but\n   *      not the other way around.\n   * @param _bAssets Array of basket assets to migrate\n   * @param _newIntegration Address of the new platform integration\n   */\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.migrateBassets(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAssets,\n      _newIntegration\n    );\n  }\n\n  /**\n   * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\n   * @param _bAsset          Address of the ERC20 token to isolate\n   * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\n   *                         or above (f)\n   */\n  function handlePegLoss(address _bAsset, bool _belowPeg)\n    external\n    onlyGovernor\n  {\n    MassetManager.handlePegLoss(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _belowPeg\n    );\n  }\n\n  /**\n   * @dev Negates the isolation of a given bAsset\n   * @param _bAsset Address of the bAsset\n   */\n  function negateIsolation(address _bAsset) external onlyGovernor {\n    MassetManager.negateIsolation(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset\n    );\n  }\n\n  /**\n   * @dev Starts changing of the amplification var A\n   * @param _targetA      Target A value\n   * @param _rampEndTime  Time at which A will arrive at _targetA\n   */\n  function startRampA(uint256 _targetA, uint256 _rampEndTime)\n    external\n    onlyGovernor\n  {\n    MassetManager.startRampA(\n      data.ampData,\n      _targetA,\n      _rampEndTime,\n      _getA(),\n      A_PRECISION\n    );\n  }\n\n  /**\n   * @dev Stops the changing of the amplification var A, setting\n   * it to whatever the current value is.\n   */\n  function stopRampA() external onlyGovernor {\n    MassetManager.stopRampA(data.ampData, _getA());\n  }\n\n  /**\n   * @dev Mints deficit to SAVE if k > token supply\n   */\n  function mintDeficit() external returns (uint256 mintAmount) {\n    require(\n      msg.sender == _governor() || msg.sender == _proxyAdmin(),\n      \"Gov or ProxyAdmin\"\n    );\n\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(k > config.supply, \"No deficit\");\n    mintAmount = k - config.supply;\n    data.surplus += mintAmount;\n\n    emit DeficitMinted(mintAmount);\n  }\n\n  /**\n   * @dev Burns surplus if token supply > k\n   */\n  function burnSurplus() external returns (uint256 burnAmount) {\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(config.supply > k, \"No surplus\");\n    burnAmount = config.supply - k;\n    // Transfer to ensure approval has been given\n    transferFrom(msg.sender, address(this), burnAmount);\n\n    _burn(address(this), burnAmount);\n    emit SurplusBurned(msg.sender, burnAmount);\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/MassetLogic.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n// External\nimport {IPlatformIntegration} from \"../interfaces/IPlatformIntegration.sol\";\n\n// Internal\nimport \"../masset/MassetStructs.sol\";\n\n// Libs\nimport {Root} from \"../shared/Root.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {MassetHelpers} from \"../shared/MassetHelpers.sol\";\nimport {StableMath} from \"../shared/StableMath.sol\";\n\n/**\n * @title   MassetLogic\n * @author  mStable\n * @notice  Builds on and enforces the StableSwap invariant conceived by Michael Egorov. (https://www.curve.fi/stableswap-paper.pdf)\n *          Derived by mStable and adapted for the needs of an mAsset, as described in MIP-7 (http://mips.mstable.org/MIPS/mip-7)\n *          Calculates and validates the result of Masset operations with respect to the invariant.\n *          This supports low slippage swaps and applies penalties towards min and max regions.\n * @dev     VERSION: 1.0\n *          DATE:    2021-04-23\n */\nlibrary MassetLogic {\n  using StableMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 internal constant A_PRECISION = 100;\n\n  /***************************************\n                    MINT\n    ****************************************/\n\n  /**\n   * @notice Transfers token in, updates internal balances and computes the mAsset output\n   * @param _data                 Masset storage state\n   * @param _config               Core config for use in the invariant validator\n   * @param _input                Data on the bAsset to deposit for the minted mAsset.\n   * @param _inputQuantity        Quantity in input token units.\n   * @param _minOutputQuantity    Minimum mAsset quantity to be minted. This protects against slippage.\n   * @return mintOutput           Quantity of mAsset minted from the deposited bAsset.\n   */\n  function mint(\n    MassetData storage _data,\n    InvariantConfig calldata _config,\n    Asset calldata _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity\n  ) external returns (uint256 mintOutput) {\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n    // Transfer collateral to the platform integration address and call deposit\n    uint256 quantityDeposited = _depositTokens(\n      _data.bAssetPersonal[_input.idx],\n      cachedBassetData[_input.idx].ratio,\n      _inputQuantity,\n      _getCacheDetails(_data, _config.supply)\n    );\n    // Validation should be after token transfer, as bAssetQty is unknown before\n    mintOutput = computeMint(\n      cachedBassetData,\n      _input.idx,\n      quantityDeposited,\n      _config\n    );\n    require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\n    // Log the Vault increase - can only be done when basket is healthy\n    _data.bAssetData[_input.idx].vaultBalance =\n      cachedBassetData[_input.idx].vaultBalance +\n      SafeCast.toUint128(quantityDeposited);\n  }\n\n  /**\n   * @notice Transfers tokens in, updates internal balances and computes the mAsset output.\n   * Only fAsset & mAsset are supported in this path.\n   * @param _data                 Masset storage state\n   * @param _config               Core config for use in the invariant validator\n   * @param _indices              Non-duplicate addresses of the bAssets to deposit for the minted mAsset.\n   * @param _inputQuantities      Quantity of each input in input token units.\n   * @param _minOutputQuantity    Minimum mAsset quantity to be minted. This protects against slippage.\n   * @return mintOutput           Quantity of mAsset minted from the deposited bAsset.\n   */\n  function mintMulti(\n    MassetData storage _data,\n    InvariantConfig calldata _config,\n    uint8[] calldata _indices,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity\n  ) external returns (uint256 mintOutput) {\n    uint256 len = _indices.length;\n    uint256[] memory quantitiesDeposited = new uint256[](len);\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n    uint256 maxCache = _getCacheDetails(_data, _config.supply);\n    // Transfer the Bassets to the integrator, update storage and calc MassetQ\n    for (uint256 i = 0; i < len; i++) {\n      if (_inputQuantities[i] > 0) {\n        uint8 idx = _indices[i];\n        BassetData memory bData = cachedBassetData[idx];\n        quantitiesDeposited[i] = _depositTokens(\n          _data.bAssetPersonal[idx],\n          bData.ratio,\n          _inputQuantities[i],\n          maxCache\n        );\n\n        _data.bAssetData[idx].vaultBalance =\n          bData.vaultBalance +\n          SafeCast.toUint128(quantitiesDeposited[i]);\n      }\n    }\n    // Validate the proposed mint, after token transfer\n    mintOutput = computeMintMulti(\n      cachedBassetData,\n      _indices,\n      quantitiesDeposited,\n      _config\n    );\n    require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\n    require(mintOutput > 0, \"Zero mAsset quantity\");\n  }\n\n  /***************************************\n                    SWAP\n    ****************************************/\n\n  /**\n   * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\n   * first routing through the mAsset pool.\n   * @param _data              Masset storage state\n   * @param _config            Core config for use in the invariant validator\n   * @param _input             Data on bAsset to deposit\n   * @param _output            Data on bAsset to withdraw\n   * @param _inputQuantity     Units of input bAsset to swap in\n   * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\n   * @param _recipient         Address to transfer output asset to\n   * @return swapOutput        Quantity of output asset returned from swap\n   * @return scaledFee          Fee paid, in mAsset terms\n   */\n  function swap(\n    MassetData storage _data,\n    InvariantConfig calldata _config,\n    Asset calldata _input,\n    Asset calldata _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 swapOutput, uint256 scaledFee) {\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n    // 3. Deposit the input tokens\n    uint256 quantityDeposited = _depositTokens(\n      _data.bAssetPersonal[_input.idx],\n      cachedBassetData[_input.idx].ratio,\n      _inputQuantity,\n      _getCacheDetails(_data, _config.supply)\n    );\n    // 3.1. Update the input balance\n    _data.bAssetData[_input.idx].vaultBalance =\n      cachedBassetData[_input.idx].vaultBalance +\n      SafeCast.toUint128(quantityDeposited);\n\n    // 3. Validate the swap\n    (swapOutput, scaledFee) = computeSwap(\n      cachedBassetData,\n      _input.idx,\n      _output.idx,\n      quantityDeposited,\n      _data.swapFee,\n      _config\n    );\n    require(swapOutput >= _minOutputQuantity, \"Output qty < minimum qty\");\n    require(swapOutput > 0, \"Zero output quantity\");\n    //4. Settle the swap\n    //4.1. Decrease output bal\n    uint256 maxCache = _getCacheDetails(_data, _config.supply);\n    _withdrawTokens(\n      swapOutput,\n      _data.bAssetPersonal[_output.idx],\n      cachedBassetData[_output.idx],\n      _recipient,\n      maxCache\n    );\n    _data.bAssetData[_output.idx].vaultBalance =\n      cachedBassetData[_output.idx].vaultBalance -\n      SafeCast.toUint128(swapOutput);\n    // Save new surplus to storage\n    _data.surplus += scaledFee;\n  }\n\n  /***************************************\n                    REDEEM\n    ****************************************/\n\n  /**\n   * @notice Burns a specified quantity of the senders mAsset in return for a bAsset. The output amount is derived\n   * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\n   * @param _data              Masset storage state\n   * @param _config            Core config for use in the invariant validator\n   * @param _output            Data on bAsset to withdraw\n   * @param _inputQuantity   Quantity of mAsset to burn\n   * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt mAsset. This protects against slippage.\n   * @param _recipient         Address to transfer the withdrawn bAssets to.\n   * @return bAssetQuantity    Quanity of bAsset units received for the burnt mAsset\n   * @return scaledFee          Fee paid, in mAsset terms\n   */\n  function redeem(\n    MassetData storage _data,\n    InvariantConfig calldata _config,\n    Asset calldata _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 bAssetQuantity, uint256 scaledFee) {\n    // Load the bAsset data from storage into memory\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n    // Calculate redemption quantities\n    (bAssetQuantity, scaledFee) = computeRedeem(\n      cachedBassetData,\n      _output.idx,\n      _inputQuantity,\n      _config,\n      _data.swapFee\n    );\n    require(bAssetQuantity >= _minOutputQuantity, \"bAsset qty < min qty\");\n    require(bAssetQuantity > 0, \"Output == 0\");\n    // Apply fees, burn mAsset and return bAsset to recipient\n    _data.surplus += scaledFee;\n    // 2.0. Transfer the Bassets to the recipient\n    uint256 maxCache = _getCacheDetails(\n      _data,\n      _config.supply - _inputQuantity + scaledFee\n    );\n    _withdrawTokens(\n      bAssetQuantity,\n      _data.bAssetPersonal[_output.idx],\n      cachedBassetData[_output.idx],\n      _recipient,\n      maxCache\n    );\n    // 3.0. Set vault balance\n    _data.bAssetData[_output.idx].vaultBalance =\n      cachedBassetData[_output.idx].vaultBalance -\n      SafeCast.toUint128(bAssetQuantity);\n  }\n\n  /**\n   * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\n   * balance levels and desired mAsset quantity. Burns the mAsset as payment. Only fAsset & mAsset are supported in this path.\n   * @param _data                 Masset storage state\n   * @param _config               Core config for use in the invariant validator\n   * @param _inputQuantity        Quantity of mAsset to redeem\n   * @param _minOutputQuantities  Min units of output to receive\n   * @param _recipient            Address to credit the withdrawn bAssets\n   * @return scaledFee            Fee collected in mAsset terms\n   * @return outputs              Array of output asset addresses\n   * @return outputQuantities     Array of output asset quantities\n   */\n  function redeemProportionately(\n    MassetData storage _data,\n    InvariantConfig calldata _config,\n    uint256 _inputQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  )\n    external\n    returns (\n      uint256 scaledFee,\n      address[] memory outputs,\n      uint256[] memory outputQuantities\n    )\n  {\n    // Load the bAsset data from storage into memory\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n\n    // Calculate mAsset redemption quantities\n    uint256 deductedInput;\n    (deductedInput, scaledFee) = _getDeducted(\n      cachedBassetData,\n      _config,\n      _inputQuantity,\n      _data.redemptionFee\n    );\n\n    _data.surplus += scaledFee;\n\n    // Calc cache and total mAsset circulating\n    uint256 maxCache = _getCacheDetails(\n      _data,\n      _config.supply - _inputQuantity + scaledFee\n    );\n\n    uint256 len = cachedBassetData.length;\n    outputs = new address[](len);\n    outputQuantities = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      // Get amount out, proportionate to redemption quantity\n      uint256 amountOut = (cachedBassetData[i].vaultBalance * deductedInput) /\n        _config.supply;\n      require(amountOut > 1, \"Output == 0\");\n      amountOut -= 1;\n      require(amountOut >= _minOutputQuantities[i], \"bAsset qty < min qty\");\n      // reduce vaultBalance\n      _data.bAssetData[i].vaultBalance =\n        cachedBassetData[i].vaultBalance -\n        SafeCast.toUint128(amountOut);\n      // Set output in array\n      BassetPersonal memory personal = _data.bAssetPersonal[i];\n      (outputQuantities[i], outputs[i]) = (amountOut, personal.addr);\n      // Transfer the bAsset to the recipient\n      _withdrawTokens(\n        amountOut,\n        personal,\n        cachedBassetData[i],\n        _recipient,\n        maxCache\n      );\n    }\n  }\n\n  /** @dev Internal func to get the deducted input to avoid stack depth error */\n  function _getDeducted(\n    BassetData[] memory _bData,\n    InvariantConfig memory _config,\n    uint256 _input,\n    uint256 _redemptionFee\n  ) internal pure returns (uint256 deductedInput, uint256 scaledFee) {\n    deductedInput = _input;\n    // If supply > k, deduct recolFee\n    (uint256 price, ) = computePrice(_bData, _config);\n    if (price < 1e18) {\n      deductedInput -= ((_input * _config.recolFee) / 1e18);\n    }\n    scaledFee = deductedInput.mulTruncate(_redemptionFee);\n    deductedInput -= scaledFee;\n  }\n\n  /**\n   * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\n   *      relative mAsset quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\n   * @param _data                 Masset storage state\n   * @param _config               Core config for use in the invariant validator\n   * @param _indices              Indices of the bAssets to receive\n   * @param _outputQuantities     Units of the bAssets to receive\n   * @param _maxMassetQuantity     Maximum mAsset quantity to burn for the received bAssets. This protects against slippage.\n   * @param _recipient            Address to receive the withdrawn bAssets\n   * @return mAssetQuantity      Quantity of mAsset units to burn as payment\n   * @return fee             Fee collected, in mAsset terms\n   */\n  function redeemExactBassets(\n    MassetData storage _data,\n    InvariantConfig memory _config,\n    uint8[] calldata _indices,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  ) external returns (uint256 mAssetQuantity, uint256 fee) {\n    // Load bAsset data from storage to memory\n    BassetData[] memory cachedBassetData = _data.bAssetData;\n\n    (mAssetQuantity, fee) = computeRedeemExact(\n      cachedBassetData,\n      _indices,\n      _outputQuantities,\n      _config,\n      _data.swapFee\n    );\n    require(\n      mAssetQuantity <= _maxMassetQuantity,\n      \"Redeem mAsset qty > max quantity\"\n    );\n    // Apply fees, burn mAsset and return bAsset to recipient\n    _data.surplus += fee;\n    // Transfer the Bassets to the recipient and count fees\n    uint256 maxCache = _getCacheDetails(\n      _data,\n      _config.supply - mAssetQuantity + fee\n    );\n    for (uint256 i = 0; i < _indices.length; i++) {\n      uint8 idx = _indices[i];\n      _withdrawTokens(\n        _outputQuantities[i],\n        _data.bAssetPersonal[idx],\n        cachedBassetData[idx],\n        _recipient,\n        maxCache\n      );\n      _data.bAssetData[idx].vaultBalance =\n        cachedBassetData[idx].vaultBalance -\n        SafeCast.toUint128(_outputQuantities[i]);\n    }\n  }\n\n  /***************************************\n                FORGING - INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Deposits a given asset to the system. If there is sufficient room for the asset\n   * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\n   * depositing the delta in the platform\n   */\n  function _depositTokens(\n    BassetPersonal memory _bAsset,\n    uint256 _bAssetRatio,\n    uint256 _quantity,\n    uint256 _maxCache\n  ) internal returns (uint256 quantityDeposited) {\n    // 0. If integration is 0, short circuit\n    if (_bAsset.integrator == address(0)) {\n      (uint256 received, ) = MassetHelpers.transferReturnBalance(\n        msg.sender,\n        address(this),\n        _bAsset.addr,\n        _quantity\n      );\n      return received;\n    }\n\n    // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\n    uint256 cacheBal;\n    (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\n      msg.sender,\n      _bAsset.integrator,\n      _bAsset.addr,\n      _quantity\n    );\n\n    // 2 - Deposit X if necessary\n    // 2.1 - Deposit if xfer fees\n    if (_bAsset.hasTxFee) {\n      uint256 deposited = IPlatformIntegration(_bAsset.integrator).deposit(\n        _bAsset.addr,\n        quantityDeposited,\n        true\n      );\n\n      return StableMath.min(deposited, quantityDeposited);\n    }\n    // 2.2 - Else Deposit X if Cache > %\n    // This check is in place to ensure that any token with a txFee is rejected\n    require(quantityDeposited == _quantity, \"Asset not fully transferred\");\n\n    uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\n\n    if (cacheBal > relativeMaxCache) {\n      uint256 delta = cacheBal - (relativeMaxCache / 2);\n      IPlatformIntegration(_bAsset.integrator).deposit(\n        _bAsset.addr,\n        delta,\n        false\n      );\n    }\n  }\n\n  /**\n   * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\n   * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\n   * cache to the mid level.\n   */\n  function _withdrawTokens(\n    uint256 _quantity,\n    BassetPersonal memory _personal,\n    BassetData memory _data,\n    address _recipient,\n    uint256 _maxCache\n  ) internal {\n    if (_quantity == 0) return;\n\n    // 1.0 If there is no integrator, send from here\n    if (_personal.integrator == address(0)) {\n      IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\n    }\n    // 1.1 If txFee then short circuit - there is no cache\n    else if (_personal.hasTxFee) {\n      IPlatformIntegration(_personal.integrator).withdraw(\n        _recipient,\n        _personal.addr,\n        _quantity,\n        _quantity,\n        true\n      );\n    }\n    // 1.2. Else, withdraw from either cache or main vault\n    else {\n      uint256 cacheBal = IERC20(_personal.addr).balanceOf(\n        _personal.integrator\n      );\n      // 2.1 - If balance b in cache, simply withdraw\n      if (cacheBal >= _quantity) {\n        IPlatformIntegration(_personal.integrator).withdrawRaw(\n          _recipient,\n          _personal.addr,\n          _quantity\n        );\n      }\n      // 2.2 - Else reset the cache to X, or as far as possible\n      //       - Withdraw X+b from platform\n      //       - Send b to user\n      else {\n        uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) /\n          2;\n        uint256 totalWithdrawal = StableMath.min(\n          relativeMidCache + _quantity - cacheBal,\n          _data.vaultBalance - SafeCast.toUint128(cacheBal)\n        );\n\n        IPlatformIntegration(_personal.integrator).withdraw(\n          _recipient,\n          _personal.addr,\n          _quantity,\n          totalWithdrawal,\n          false\n        );\n      }\n    }\n  }\n\n  /**\n   * @dev Gets the max cache size, given the supply of mAsset\n   * @return maxCache    Max units of any given bAsset that should be held in the cache\n   */\n  function _getCacheDetails(MassetData storage _data, uint256 _supply)\n    internal\n    view\n    returns (uint256 maxCache)\n  {\n    maxCache = (_supply * _data.cacheSize) / 1e18;\n  }\n\n  /***************************************\n                    INVARIANT\n    ****************************************/\n\n  /**\n   * @notice Compute the amount of mAsset received for minting\n   * with `quantity` amount of bAsset index `i`.\n   * @param _bAssets      Array of all bAsset Data\n   * @param _i            Index of bAsset with which to mint\n   * @param _rawInput     Raw amount of bAsset to use in mint\n   * @param _config       Generalised invariantConfig stored externally\n   * @return mintAmount   Quantity of mAssets minted\n   */\n  function computeMint(\n    BassetData[] memory _bAssets,\n    uint8 _i,\n    uint256 _rawInput,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 mintAmount) {\n    // 1. Get raw reserves\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    // 2. Get value of reserves according to invariant\n    uint256 k0 = _invariant(x, sum, _config.a);\n    uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\n\n    // 3. Add deposit to x and sum\n    x[_i] += scaledInput;\n    sum += scaledInput;\n    // 4. Finalise mint\n    require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\n    mintAmount = _computeMintOutput(x, sum, k0, _config);\n  }\n\n  /**\n   * @notice Compute the amount of mAsset received for minting\n   * with the given array of inputs.\n   * @param _bAssets      Array of all bAsset Data\n   * @param _indices      Indexes of bAssets with which to mint\n   * @param _rawInputs    Raw amounts of bAssets to use in mint\n   * @param _config       Generalised invariantConfig stored externally\n   * @return mintAmount   Quantity of mAssets minted\n   */\n  function computeMintMulti(\n    BassetData[] memory _bAssets,\n    uint8[] memory _indices,\n    uint256[] memory _rawInputs,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 mintAmount) {\n    // 1. Get raw reserves\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    // 2. Get value of reserves according to invariant\n    uint256 k0 = _invariant(x, sum, _config.a);\n\n    // 3. Add deposits to x and sum\n    uint256 len = _indices.length;\n    uint8 idx;\n    uint256 scaledInput;\n    for (uint256 i = 0; i < len; i++) {\n      idx = _indices[i];\n      scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\n      x[idx] += scaledInput;\n      sum += scaledInput;\n    }\n    // 4. Finalise mint\n    require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\n    mintAmount = _computeMintOutput(x, sum, k0, _config);\n  }\n\n  /**\n   * @notice Compute the amount of bAsset received for swapping\n   * `quantity` amount of index `input_idx` to index `output_idx`.\n   * @param _bAssets      Array of all bAsset Data\n   * @param _i            Index of bAsset to swap IN\n   * @param _o            Index of bAsset to swap OUT\n   * @param _rawInput     Raw amounts of input bAsset to input\n   * @param _feeRate      Swap fee rate to apply to output\n   * @param _config       Generalised invariantConfig stored externally\n   * @return bAssetOutputQuantity   Raw bAsset output quantity\n   * @return scaledSwapFee          Swap fee collected, in mAsset terms\n   */\n  function computeSwap(\n    BassetData[] memory _bAssets,\n    uint8 _i,\n    uint8 _o,\n    uint256 _rawInput,\n    uint256 _feeRate,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\n    // 1. Get raw reserves\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    // 2. Get value of reserves according to invariant\n    uint256 k0 = _invariant(x, sum, _config.a);\n    // 3. Add deposits to x and sum\n    uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\n    x[_i] += scaledInput;\n    sum += scaledInput;\n    // 4. Calc total mAsset q\n    uint256 k2;\n    (k2, scaledSwapFee) = _getSwapFee(\n      k0,\n      _invariant(x, sum, _config.a),\n      _feeRate,\n      _config\n    );\n    // 5. Calc output bAsset\n    uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k2);\n    require(newOutputReserve < x[_o], \"Zero swap output\");\n    uint256 output = x[_o] - newOutputReserve - 1;\n    bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\n    // 6. Check for bounds\n    x[_o] -= output;\n    sum -= output;\n    require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\n  }\n\n  /** @dev Gets swap fee and scales to avoid stack depth errors in computeSwap */\n  function _getSwapFee(\n    uint256 _k0,\n    uint256 _k1,\n    uint256 _feeRate,\n    InvariantConfig memory _config\n  ) internal pure returns (uint256 k2, uint256 scaledSwapFee) {\n    uint256 minted = _k1 - _k0;\n    // Under col? Deduct fee\n    if (_config.supply > _k0) {\n      minted -= ((minted * _config.recolFee) / 1e18);\n    }\n    // base swap fee\n    scaledSwapFee = (minted * _feeRate) / 1e18;\n    k2 = _k1 - minted + scaledSwapFee;\n    // swap fee in lpToken terms\n    scaledSwapFee = (scaledSwapFee * _config.supply) / _k0;\n  }\n\n  /**\n   * @notice Compute the amount of bAsset index `i` received for\n   * redeeming `quantity` amount of mAsset.\n   * @param _bAssets              Array of all bAsset Data\n   * @param _o                    Index of output bAsset\n   * @param _grossMassetQuantity  Net amount of mAsset to redeem\n   * @param _config               Generalised invariantConfig stored externally\n   * @return rawOutputUnits       Raw bAsset output returned\n   */\n  function computeRedeem(\n    BassetData[] memory _bAssets,\n    uint8 _o,\n    uint256 _grossMassetQuantity,\n    InvariantConfig memory _config,\n    uint256 _feeRate\n  ) public pure returns (uint256 rawOutputUnits, uint256 scaledFee) {\n    // 1. Get raw reserves\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    // 2. Get value of reserves according to invariant\n    uint256 k0 = _invariant(x, sum, _config.a);\n    uint256 redemption;\n    (redemption, scaledFee) = _getFee(\n      _grossMassetQuantity,\n      _config,\n      _feeRate,\n      k0\n    );\n    uint256 kFinal = (k0 * (_config.supply - redemption)) / _config.supply + 1;\n    // 3. Compute bAsset output\n    uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, kFinal);\n    uint256 output = x[_o] - newOutputReserve - 1;\n    rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\n    // 4. Check for max weight\n    x[_o] -= output;\n    sum -= output;\n    require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\n  }\n\n  function _getFee(\n    uint256 _grossMassetQuantity,\n    InvariantConfig memory _config,\n    uint256 _feeRate,\n    uint256 _k0\n  ) internal pure returns (uint256 redemption, uint256 scaledFee) {\n    redemption = _grossMassetQuantity;\n    if (_config.supply > _k0) {\n      redemption -= ((redemption * _config.recolFee) / 1e18);\n    }\n    scaledFee = redemption.mulTruncate(_feeRate);\n    redemption -= scaledFee;\n  }\n\n  /**\n   * @notice Compute the amount of mAsset required to redeem\n   * a given selection of bAssets.\n   * @param _bAssets          Array of all bAsset Data\n   * @param _indices          Indexes of output bAssets\n   * @param _rawOutputs       Desired raw bAsset outputs\n   * @param _config           Generalised invariantConfig stored externally\n   * @return grossMasset      Amount of mAsset required to redeem bAssets\n   * @return fee              Fee to subtract from gross\n   */\n  function computeRedeemExact(\n    BassetData[] memory _bAssets,\n    uint8[] memory _indices,\n    uint256[] memory _rawOutputs,\n    InvariantConfig memory _config,\n    uint256 _feeRate\n  ) public pure returns (uint256 grossMasset, uint256 fee) {\n    // 1. Get raw reserves\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    // 2. Get value of reserves according to invariant\n    uint256 k0 = _invariant(x, sum, _config.a);\n    // 3. Sub deposits from x and sum\n    uint256 len = _indices.length;\n    uint256 ratioed;\n    for (uint256 i = 0; i < len; i++) {\n      ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\n      x[_indices[i]] -= ratioed;\n      sum -= ratioed;\n    }\n    require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\n    // 4. Get new value of reserves according to invariant\n    uint256 k1 = _invariant(x, sum, _config.a);\n    // 5. Total mAsset is the difference between values\n    uint256 redeemed = (_config.supply * (k0 - k1)) / k0;\n    require(redeemed > 1e6, \"Must redeem > 1e6 units\");\n    grossMasset = redeemed.divPrecisely(1e18 - _feeRate);\n    fee = grossMasset - redeemed;\n    grossMasset += 1;\n    if (_config.supply > k0) {\n      grossMasset = ((grossMasset * 1e18) / (1e18 - _config.recolFee));\n    }\n  }\n\n  /**\n   * @notice Gets the price of the mAsset, and invariant value k\n   * @param _bAssets  Array of all bAsset Data\n   * @param _config   Generalised InvariantConfig stored externally\n   * @return price    Price of an mAsset\n   * @return k        Total value of basket, k\n   */\n  function computePrice(\n    BassetData[] memory _bAssets,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 price, uint256 k) {\n    (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n    k = _invariant(x, sum, _config.a);\n    price = (1e18 * k) / _config.supply;\n  }\n\n  /***************************************\n                    INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Computes the actual mint output after adding mint inputs\n   * to the vault balances.\n   * @param _x            Scaled vaultBalances\n   * @param _sum          Sum of vaultBalances, to avoid another loop\n   * @param _k            Previous value of invariant, k, before addition\n   * @param _config       Generalised InvariantConfig stored externally\n   * @return mintAmount   Amount of value added to invariant, in mAsset terms\n   */\n  function _computeMintOutput(\n    uint256[] memory _x,\n    uint256 _sum,\n    uint256 _k,\n    InvariantConfig memory _config\n  ) internal pure returns (uint256 mintAmount) {\n    // 1. Get value of reserves according to invariant\n    uint256 kFinal = _invariant(_x, _sum, _config.a);\n    // 2. Total minted is the difference between values, with respect to total supply\n    if (_config.supply == 0) {\n      mintAmount = kFinal - _k;\n    } else {\n      mintAmount = (_config.supply * (kFinal - _k)) / _k;\n    }\n    // 3. Deviation? deduct recolFee of 0.5 bps\n    if (_config.supply > _k) {\n      mintAmount -= ((mintAmount * _config.recolFee) / 1e18);\n    }\n  }\n\n  /**\n   * @dev Simply scaled raw reserve values and returns the sum\n   * @param _bAssets  All bAssets\n   * @return x        Scaled vault balances\n   * @return sum      Sum of scaled vault balances\n   */\n  function _getReserves(BassetData[] memory _bAssets)\n    internal\n    pure\n    returns (uint256[] memory x, uint256 sum)\n  {\n    uint256 len = _bAssets.length;\n    x = new uint256[](len);\n    uint256 r;\n    for (uint256 i = 0; i < len; i++) {\n      BassetData memory bAsset = _bAssets[i];\n      r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\n      x[i] = r;\n      sum += r;\n    }\n  }\n\n  /**\n   * @dev Checks that no bAsset reserves exceed max weight\n   * @param _x            Scaled bAsset reserves\n   * @param _sum          Sum of x, precomputed\n   * @param _limits       Config object containing max and min weights\n   * @return inBounds     Bool, true if all assets are within bounds\n   */\n  function _inBounds(\n    uint256[] memory _x,\n    uint256 _sum,\n    WeightLimits memory _limits\n  ) internal pure returns (bool inBounds) {\n    uint256 len = _x.length;\n    inBounds = true;\n    uint256 w;\n    for (uint256 i = 0; i < len; i++) {\n      w = (_x[i] * 1e18) / _sum;\n      if (w > _limits.max || w < _limits.min) return false;\n    }\n  }\n\n  /***************************************\n                    INVARIANT\n    ****************************************/\n\n  /**\n   * @dev Compute the invariant f(x) for a given array of supplies `x`.\n   * @param _x        Scaled vault balances\n   * @param _sum      Sum of scaled vault balances\n   * @param _a        Precise amplification coefficient\n   * @return k        Cumulative value of all assets according to the invariant\n   */\n  function _invariant(\n    uint256[] memory _x,\n    uint256 _sum,\n    uint256 _a\n  ) internal pure returns (uint256 k) {\n    uint256 len = _x.length;\n\n    if (_sum == 0) return 0;\n\n    uint256 nA = _a * len;\n    uint256 kPrev;\n    k = _sum;\n\n    for (uint256 i = 0; i < 256; i++) {\n      uint256 kP = k;\n      for (uint256 j = 0; j < len; j++) {\n        kP = (kP * k) / (_x[j] * len);\n      }\n      kPrev = k;\n      k =\n        (((nA * _sum) / A_PRECISION + (kP * len)) * k) /\n        (((nA - A_PRECISION) * k) / A_PRECISION + ((len + 1) * kP));\n      if (_hasConverged(k, kPrev)) {\n        return k;\n      }\n    }\n\n    revert(\"Invariant did not converge\");\n  }\n\n  /**\n   * @dev Checks if a given solution has converged within a factor of 1\n   * @param _k              Current solution k\n   * @param _kPrev          Previous iteration solution\n   * @return hasConverged   Bool, true if diff abs(k, kPrev) <= 1\n   */\n  function _hasConverged(uint256 _k, uint256 _kPrev)\n    internal\n    pure\n    returns (bool)\n  {\n    if (_kPrev > _k) {\n      return (_kPrev - _k) <= 1;\n    } else {\n      return (_k - _kPrev) <= 1;\n    }\n  }\n\n  /**\n   * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\n   * @param _x        Scaled reserve balances\n   * @param _a        Precise amplification coefficient\n   * @param _idx      Index of asset for which to solve\n   * @param _targetK  Target invariant value K\n   * @return y        New reserve of _i\n   */\n  function _solveInvariant(\n    uint256[] memory _x,\n    uint256 _a,\n    uint8 _idx,\n    uint256 _targetK\n  ) internal pure returns (uint256 y) {\n    uint256 len = _x.length;\n    require(_idx >= 0 && _idx < len, \"Invalid index\");\n\n    (uint256 sum_, uint256 nA, uint256 kP) = (0, _a * len, _targetK);\n\n    for (uint256 i = 0; i < len; i++) {\n      if (i != _idx) {\n        sum_ += _x[i];\n        kP = (kP * _targetK) / (_x[i] * len);\n      }\n    }\n\n    uint256 c = (((kP * _targetK) * A_PRECISION) / nA) / len;\n    uint256 g = (_targetK * (nA - A_PRECISION)) / nA;\n    uint256 b = 0;\n\n    if (g > sum_) {\n      b = g - sum_;\n      y = (Root.sqrt((b**2) + (4 * c)) + b) / 2 + 1;\n    } else {\n      b = sum_ - g;\n      y = (Root.sqrt((b**2) + (4 * c)) - b) / 2 + 1;\n    }\n\n    if (y < 1e8) revert(\"Invalid solution\");\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/MassetManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\n// External\nimport {IPlatformIntegration} from \"../interfaces/IPlatformIntegration.sol\";\nimport {IInvariantValidator} from \"../interfaces/IInvariantValidator.sol\";\nimport {IBasicToken} from \"../shared/IBasicToken.sol\";\n\n// Internal\nimport \"./MassetStructs.sol\";\n\n// Libs\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {StableMath} from \"../shared/StableMath.sol\";\nimport {MassetHelpers} from \"../shared/MassetHelpers.sol\";\n\n/**\n * @title   Manager\n * @author  mStable\n * @notice  Simply contains logic to perform Basket Manager duties for an mAsset.\n *          Allowing logic can be abstracted here to avoid bytecode inflation.\n * @dev     VERSION: 1.0\n *          DATE:    2021-01-22\n */\nlibrary MassetManager {\n  using SafeERC20 for IERC20;\n  using StableMath for uint256;\n\n  event BassetsMigrated(address[] bAssets, address newIntegrator);\n  event TransferFeeEnabled(address indexed bAsset, bool enabled);\n  event BassetAdded(address indexed bAsset, address integrator);\n  event BassetStatusChanged(address indexed bAsset, BassetStatus status);\n  event BasketStatusChanged();\n  event StartRampA(\n    uint256 currentA,\n    uint256 targetA,\n    uint256 startTime,\n    uint256 rampEndTime\n  );\n  event StopRampA(uint256 currentA, uint256 time);\n\n  uint256 private constant MIN_RAMP_TIME = 1 days;\n  uint256 private constant MAX_A = 1e6;\n\n  /**\n   * @notice Adds a bAsset to the given personal, data and mapping, provided it is valid\n   * @param _bAssetPersonal   Basset data storage array\n   * @param _bAssetData       Basset data storage array\n   * @param _bAssetIndexes    Mapping of bAsset address to their index\n   * @param _bAsset           Address of the ERC20 token to add to the Basket\n   * @param _integration      Address of the Platform Integration\n   * @param _mm               Base 1e8 var to determine measurement ratio\n   * @param _hasTxFee         Are transfer fees charged on this bAsset (e.g. USDT)\n   */\n  function addBasset(\n    BassetPersonal[] storage _bAssetPersonal,\n    BassetData[] storage _bAssetData,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address _bAsset,\n    address _integration,\n    uint256 _mm,\n    bool _hasTxFee\n  ) external {\n    require(_bAsset != address(0), \"bAsset address must be valid\");\n    uint8 bAssetCount = uint8(_bAssetPersonal.length);\n\n    uint8 idx = _bAssetIndexes[_bAsset];\n    require(\n      bAssetCount == 0 || _bAssetPersonal[idx].addr != _bAsset,\n      \"bAsset already exists in Basket\"\n    );\n\n    // Should fail if bAsset is not added to integration\n    // Programmatic enforcement of bAsset validity should service through decentralised feed\n    if (_integration != address(0)) {\n      IPlatformIntegration(_integration).checkBalance(_bAsset);\n    }\n\n    uint256 bAssetDecimals = IBasicToken(_bAsset).decimals();\n    require(\n      bAssetDecimals >= 4 && bAssetDecimals <= 18,\n      \"Token must have sufficient decimal places\"\n    );\n\n    uint256 delta = uint256(18) - bAssetDecimals;\n    uint256 ratio = _mm * (10**delta);\n\n    _bAssetIndexes[_bAsset] = bAssetCount;\n\n    _bAssetPersonal.push(\n      BassetPersonal({\n        addr: _bAsset,\n        integrator: _integration,\n        hasTxFee: _hasTxFee,\n        status: BassetStatus.Normal\n      })\n    );\n    _bAssetData.push(\n      BassetData({ratio: SafeCast.toUint128(ratio), vaultBalance: 0})\n    );\n\n    emit BassetAdded(_bAsset, _integration);\n  }\n\n  /**\n   * @dev Collects the interest generated from the Basket, minting a relative\n   *      amount of mAsset and sending it over to the SavingsManager.\n   * @param _bAssetPersonal   Basset personal storage array\n   * @param _bAssetData       Basset data storage array\n   * @return indices          Array of bAsset idxs [0,1...]\n   * @return rawGains         Raw increases in vault Balance\n   */\n  function collectPlatformInterest(\n    BassetPersonal[] memory _bAssetPersonal,\n    BassetData[] storage _bAssetData\n  ) external returns (uint8[] memory indices, uint256[] memory rawGains) {\n    // Get basket details\n    BassetData[] memory bAssetData_ = _bAssetData;\n    uint256 count = bAssetData_.length;\n    indices = new uint8[](count);\n    rawGains = new uint256[](count);\n    // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\n    for (uint256 i = 0; i < count; i++) {\n      indices[i] = uint8(i);\n      BassetPersonal memory bPersonal = _bAssetPersonal[i];\n      BassetData memory bData = bAssetData_[i];\n      // If there is no integration, then nothing can have accrued\n      if (bPersonal.integrator == address(0)) continue;\n      uint256 lending = IPlatformIntegration(bPersonal.integrator)\n        .checkBalance(bPersonal.addr);\n      uint256 cache = 0;\n      if (!bPersonal.hasTxFee) {\n        cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\n      }\n      uint256 balance = lending + cache;\n      uint256 oldVaultBalance = bData.vaultBalance;\n      if (\n        balance > oldVaultBalance && bPersonal.status == BassetStatus.Normal\n      ) {\n        _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\n        uint256 interestDelta = balance - oldVaultBalance;\n        rawGains[i] = interestDelta;\n      } else {\n        rawGains[i] = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\n   * @param _bAssetPersonal   Basset data storage array\n   * @param _bAssetIndexes    Mapping of bAsset address to their index\n   * @param _bAsset   bAsset address\n   * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\n   */\n  function setTransferFeesFlag(\n    BassetPersonal[] storage _bAssetPersonal,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address _bAsset,\n    bool _flag\n  ) external {\n    uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\n    _bAssetPersonal[index].hasTxFee = _flag;\n\n    if (_flag) {\n      // if token has tx fees, it can no longer operate with a cache\n      address integration = _bAssetPersonal[index].integrator;\n      if (integration != address(0)) {\n        uint256 bal = IERC20(_bAsset).balanceOf(integration);\n        if (bal > 0) {\n          IPlatformIntegration(integration).deposit(_bAsset, bal, true);\n        }\n      }\n    }\n\n    emit TransferFeeEnabled(_bAsset, _flag);\n  }\n\n  /**\n   * @dev Transfers all collateral from one lending market to another - used initially\n   *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\n   *      tx fee enabled assets. Supports going from no integration to integration, but\n   *      not the other way around.\n   * @param _bAssetPersonal   Basset data storage array\n   * @param _bAssetIndexes    Mapping of bAsset address to their index\n   * @param _bAssets          Array of basket assets to migrate\n   * @param _newIntegration   Address of the new platform integration\n   */\n  function migrateBassets(\n    BassetPersonal[] storage _bAssetPersonal,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address[] calldata _bAssets,\n    address _newIntegration\n  ) external {\n    uint256 len = _bAssets.length;\n    require(len > 0, \"Must migrate some bAssets\");\n\n    for (uint256 i = 0; i < len; i++) {\n      // 1. Check that the bAsset is in the basket\n      address bAsset = _bAssets[i];\n      uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, bAsset);\n      require(!_bAssetPersonal[index].hasTxFee, \"A bAsset has a transfer fee\");\n\n      // 2. Withdraw everything from the old platform integration\n      address oldAddress = _bAssetPersonal[index].integrator;\n      require(\n        oldAddress != _newIntegration,\n        \"Must transfer to new integrator\"\n      );\n      (uint256 cache, uint256 lendingBal) = (0, 0);\n      if (oldAddress == address(0)) {\n        cache = IERC20(bAsset).balanceOf(address(this));\n      } else {\n        IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\n        cache = IERC20(bAsset).balanceOf(address(oldIntegration));\n        // 2.1. Withdraw from the lending market\n        lendingBal = oldIntegration.checkBalance(bAsset);\n        if (lendingBal > 0) {\n          oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\n        }\n        // 2.2. Withdraw from the cache, if any\n        if (cache > 0) {\n          oldIntegration.withdrawRaw(address(this), bAsset, cache);\n        }\n      }\n      uint256 sum = lendingBal + cache;\n\n      // 3. Update the integration address for this bAsset\n      _bAssetPersonal[index].integrator = _newIntegration;\n\n      // 4. Deposit everything into the new\n      //    This should fail if we did not receive the full amount from the platform withdrawal\n      // 4.1. Deposit all bAsset\n      IERC20(bAsset).safeTransfer(_newIntegration, sum);\n      IPlatformIntegration newIntegration = IPlatformIntegration(\n        _newIntegration\n      );\n      if (lendingBal > 0) {\n        newIntegration.deposit(bAsset, lendingBal, false);\n      }\n      // 4.2. Check balances\n      uint256 newLendingBal = newIntegration.checkBalance(bAsset);\n      uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\n      uint256 upperMargin = 10001e14;\n      uint256 lowerMargin = 9999e14;\n\n      require(\n        newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\n          newLendingBal <= lendingBal.mulTruncate(upperMargin),\n        \"Must transfer full amount\"\n      );\n      require(\n        newCache >= cache.mulTruncate(lowerMargin) &&\n          newCache <= cache.mulTruncate(upperMargin),\n        \"Must transfer full amount\"\n      );\n    }\n\n    emit BassetsMigrated(_bAssets, _newIntegration);\n  }\n\n  /**\n   * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\n   * @param _basket          Struct containing core basket info\n   * @param _bAssetPersonal  Basset data storage array\n   * @param _bAsset          Address of the ERC20 token to isolate\n   * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\n   *                         or above (f)\n   */\n  function handlePegLoss(\n    BasketState storage _basket,\n    BassetPersonal[] storage _bAssetPersonal,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address _bAsset,\n    bool _belowPeg\n  ) external {\n    require(!_basket.failed, \"Basket must be alive\");\n\n    uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\n\n    BassetStatus newStatus = _belowPeg\n      ? BassetStatus.BrokenBelowPeg\n      : BassetStatus.BrokenAbovePeg;\n    _bAssetPersonal[i].status = newStatus;\n\n    _basket.undergoingRecol = true;\n\n    emit BassetStatusChanged(_bAsset, newStatus);\n  }\n\n  /**\n   * @dev Negates the isolation of a given bAsset\n   * @param _basket          Struct containing core basket info\n   * @param _bAssetPersonal  Basset data storage array\n   * @param _bAssetIndexes    Mapping of bAsset address to their index\n   * @param _bAsset Address of the bAsset\n   */\n  function negateIsolation(\n    BasketState storage _basket,\n    BassetPersonal[] storage _bAssetPersonal,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address _bAsset\n  ) external {\n    uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\n\n    _bAssetPersonal[i].status = BassetStatus.Normal;\n\n    bool undergoingRecol = false;\n    for (uint256 j = 0; j < _bAssetPersonal.length; j++) {\n      if (_bAssetPersonal[j].status != BassetStatus.Normal) {\n        undergoingRecol = true;\n        break;\n      }\n    }\n    _basket.undergoingRecol = undergoingRecol;\n\n    emit BassetStatusChanged(_bAsset, BassetStatus.Normal);\n  }\n\n  /**\n   * @dev Starts changing of the amplification var A\n   * @param _targetA      Target A value\n   * @param _rampEndTime  Time at which A will arrive at _targetA\n   */\n  function startRampA(\n    AmpData storage _ampData,\n    uint256 _targetA,\n    uint256 _rampEndTime,\n    uint256 _currentA,\n    uint256 _precision\n  ) external {\n    require(\n      block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\n      \"Sufficient period of previous ramp has not elapsed\"\n    );\n    require(\n      _rampEndTime >= (block.timestamp + MIN_RAMP_TIME),\n      \"Ramp time too short\"\n    );\n    require(_targetA > 0 && _targetA < MAX_A, \"A target out of bounds\");\n\n    uint256 preciseTargetA = _targetA * _precision;\n\n    if (preciseTargetA > _currentA) {\n      require(preciseTargetA <= _currentA * 10, \"A target increase too big\");\n    } else {\n      require(preciseTargetA >= _currentA / 10, \"A target decrease too big\");\n    }\n\n    _ampData.initialA = SafeCast.toUint64(_currentA);\n    _ampData.targetA = SafeCast.toUint64(preciseTargetA);\n    _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\n    _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\n\n    emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\n  }\n\n  /**\n   * @dev Stops the changing of the amplification var A, setting\n   * it to whatever the current value is.\n   */\n  function stopRampA(AmpData storage _ampData, uint256 _currentA) external {\n    require(\n      block.timestamp < _ampData.rampEndTime,\n      \"Amplification not changing\"\n    );\n\n    _ampData.initialA = SafeCast.toUint64(_currentA);\n    _ampData.targetA = SafeCast.toUint64(_currentA);\n    _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\n    _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\n\n    emit StopRampA(_currentA, block.timestamp);\n  }\n\n  /**\n   * @dev Gets a bAsset index from storage\n   * @param _asset      Address of the asset\n   * @return idx        Index of the asset\n   */\n  function _getAssetIndex(\n    BassetPersonal[] storage _bAssetPersonal,\n    mapping(address => uint8) storage _bAssetIndexes,\n    address _asset\n  ) internal view returns (uint8 idx) {\n    idx = _bAssetIndexes[_asset];\n    require(_bAssetPersonal[idx].addr == _asset, \"Invalid asset input\");\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IInvariantValidator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"../masset/MassetStructs.sol\";\n\nabstract contract IInvariantValidator {\n  // Mint\n  function computeMint(\n    BassetData[] calldata _bAssets,\n    uint8 _i,\n    uint256 _rawInput,\n    InvariantConfig memory _config\n  ) external view virtual returns (uint256);\n\n  function computeMintMulti(\n    BassetData[] calldata _bAssets,\n    uint8[] calldata _indices,\n    uint256[] calldata _rawInputs,\n    InvariantConfig memory _config\n  ) external view virtual returns (uint256);\n\n  // Swap\n  function computeSwap(\n    BassetData[] calldata _bAssets,\n    uint8 _i,\n    uint8 _o,\n    uint256 _rawInput,\n    uint256 _feeRate,\n    InvariantConfig memory _config\n  ) external view virtual returns (uint256, uint256);\n\n  // Redeem\n  function computeRedeem(\n    BassetData[] calldata _bAssets,\n    uint8 _i,\n    uint256 _mAssetQuantity,\n    InvariantConfig memory _config\n  ) external view virtual returns (uint256);\n\n  function computeRedeemExact(\n    BassetData[] calldata _bAssets,\n    uint8[] calldata _indices,\n    uint256[] calldata _rawOutputs,\n    InvariantConfig memory _config\n  ) external view virtual returns (uint256);\n\n  function computePrice(\n    BassetData[] memory _bAssets,\n    InvariantConfig memory _config\n  ) public pure virtual returns (uint256 price, uint256 k);\n}\n"
    },
    "contracts/ppo-staking/shared/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IBasicToken {\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/ppo-staking/masset/versions/MV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\n// Internal\nimport {Initializable} from \"../../shared/@openzeppelin-2.5/Initializable.sol\";\nimport {InitializableToken, IERC20} from \"../../shared/InitializableToken.sol\";\nimport {ImmutableModule} from \"../../shared/ImmutableModule.sol\";\nimport {InitializableReentrancyGuard} from \"../../shared/InitializableReentrancyGuard.sol\";\nimport {IMasset} from \"../../interfaces/IMasset.sol\";\nimport \"../MassetStructs.sol\";\n\n// Libs\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {StableMath} from \"../../shared/StableMath.sol\";\nimport {MassetManager} from \"../MassetManager.sol\";\nimport {MassetLogic} from \"../MassetLogic.sol\";\nimport {MV1Migrator} from \"./MV1Migrator.sol\";\n\n// Legacy\nimport {IBasketManager} from \"../../z_mocks/masset/migrate2/IBasketManager.sol\";\nimport {Basket, Basset} from \"../../z_mocks/masset/migrate2/MassetStructsV1.sol\";\nimport {InitializableModuleV1} from \"../../z_mocks/masset/migrate2/InitializableModuleV1.sol\";\n\n/**\n * @title   Masset used to migrate mUSD from V2.0 to V3.0\n * @author  mStable\n * @notice  An incentivised constant sum market maker with hard limits at max region. This supports\n *          low slippage swaps and applies penalties towards min and max regions. AMM produces a\n *          stablecoin (mAsset) and redirects lending market interest and swap fees to the savings\n *          contract, producing a second yield bearing asset.\n * @dev     VERSION: 3.0\n *          DATE:    2021-01-22\n */\ncontract MV1 is\n  IMasset,\n  Initializable,\n  InitializableToken,\n  InitializableModuleV1,\n  InitializableReentrancyGuard,\n  ImmutableModule\n{\n  using StableMath for uint256;\n\n  // Forging Events\n  event Minted(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address input,\n    uint256 inputQuantity\n  );\n  event MintedMulti(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] inputs,\n    uint256[] inputQuantities\n  );\n  event Swapped(\n    address indexed swapper,\n    address input,\n    address output,\n    uint256 outputAmount,\n    uint256 scaledFee,\n    address recipient\n  );\n  event Redeemed(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address output,\n    uint256 outputQuantity,\n    uint256 scaledFee\n  );\n  event RedeemedMulti(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] outputs,\n    uint256[] outputQuantity,\n    uint256 scaledFee\n  );\n\n  // State Events\n  event CacheSizeChanged(uint256 cacheSize);\n  event FeesChanged(uint256 swapFee, uint256 redemptionFee);\n  event WeightLimitsChanged(uint128 min, uint128 max);\n  event ForgeValidatorChanged(address forgeValidator);\n  event DeficitMinted(uint256 amt);\n  event SurplusBurned(address creditor, uint256 amt);\n\n  // Release 1.0 VARS\n  address public forgeValidator;\n  bool private forgeValidatorLocked;\n  // Deprecated - maintain for storage layout in mUSD\n  address private deprecated_basketManager;\n\n  // Basic redemption fee information\n  uint256 public swapFee;\n  uint256 private MAX_FEE;\n\n  // Release 1.1 VARS\n  uint256 public redemptionFee;\n\n  // Release 1.2 VARS\n  uint256 public cacheSize;\n  uint256 public surplus;\n\n  // Release 2.0 VARS\n  // Struct holding Basket details\n  BassetPersonal[] public bAssetPersonal;\n  BassetData[] public bAssetData;\n  mapping(address => uint8) public override bAssetIndexes;\n  uint8 public maxBassets;\n  BasketState public basket;\n  // Amplification Data\n  uint256 private constant A_PRECISION = 100;\n  AmpData public ampData;\n  WeightLimits public weightLimits;\n\n  // Release 3.0 VARS\n  uint256 private immutable RECOL_FEE;\n  MassetData public data;\n\n  /**\n   * @dev Constructor to set immutable bytecode\n   * @param _nexus   Nexus address\n   */\n  constructor(address _nexus, uint256 _recolFee) ImmutableModule(_nexus) {\n    require(_recolFee <= 5e13, \"RecolFee too high\");\n    RECOL_FEE = _recolFee;\n  }\n\n  /**\n   * @dev Initialization function for upgradable proxy contract.\n   *      This function should be called via Proxy just after contract deployment.\n   *      To avoid variable shadowing appended `Arg` after arguments name.\n   * @param _nameArg          Name of the mAsset\n   * @param _symbolArg        Symbol of the mAsset\n   * @param _bAssets          Array of Basset data\n   */\n  function initialize(\n    string calldata _nameArg,\n    string calldata _symbolArg,\n    BassetPersonal[] calldata _bAssets,\n    BasicConfig memory _config\n  ) public initializer {\n    InitializableToken._initialize(_nameArg, _symbolArg);\n\n    _initializeReentrancyGuard();\n\n    uint256 len = _bAssets.length;\n    require(len > 0, \"No bAssets\");\n    for (uint256 i = 0; i < len; i++) {\n      MassetManager.addBasset(\n        data.bAssetPersonal,\n        data.bAssetData,\n        bAssetIndexes,\n        _bAssets[i].addr,\n        _bAssets[i].integrator,\n        1e8,\n        _bAssets[i].hasTxFee\n      );\n    }\n\n    uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\n    data.ampData = AmpData(startA, startA, 0, 0);\n    data.weightLimits = _config.limits;\n\n    data.swapFee = 6e14;\n    data.redemptionFee = 3e14;\n    data.cacheSize = 1e17;\n  }\n\n  /**\n   * @dev Verifies that the caller is the Savings Manager contract\n   */\n  modifier onlySavingsManager() {\n    _isSavingsManager();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isSavingsManager() internal view {\n    require(_savingsManager() == msg.sender, \"Must be savings manager\");\n  }\n\n  /**\n   * @dev Requires the overall basket composition to be healthy\n   */\n  modifier whenHealthy() {\n    _isHealthy();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isHealthy() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol && !basket_.failed, \"Unhealthy\");\n  }\n\n  /**\n   * @dev Requires the basket not to be undergoing recollateralisation\n   */\n  modifier whenNoRecol() {\n    _noRecol();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _noRecol() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol, \"In recol\");\n  }\n\n  /***************************************\n                MINTING (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\n   *      must have approval to spend the senders bAsset\n   * @param _input             Address of the bAsset to deposit for the minted mAsset.\n   * @param _inputQuantity     Quantity in bAsset units\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Receipient of the newly minted mAsset tokens\n   * @return mintOutput        Quantity of newly minted mAssets for the deposited bAsset.\n   */\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.mint(\n      data,\n      _getConfig(),\n      input,\n      _inputQuantity,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit Minted(msg.sender, _recipient, mintOutput, _input, _inputQuantity);\n  }\n\n  /**\n   * @dev Mint with multiple bAssets, at a 1:1 ratio to mAsset. This contract\n   *      must have approval to spend the senders bAssets\n   * @param _inputs            Non-duplicate address array of bASset addresses to deposit for the minted mAsset tokens.\n   * @param _inputQuantities   Quantity of each bAsset to deposit for the minted mAsset.\n   *                           Order of array should mirror the above bAsset addresses.\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Address to receive the newly minted mAsset tokens\n   * @return mintOutput    Quantity of newly minted mAssets for the deposited bAssets.\n   */\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n\n    uint8[] memory indexes = _getAssets(_inputs);\n    mintOutput = MassetLogic.mintMulti(\n      data,\n      _getConfig(),\n      indexes,\n      _inputQuantities,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit MintedMulti(\n      msg.sender,\n      _recipient,\n      mintOutput,\n      _inputs,\n      _inputQuantities\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _input             Address of the bAsset to deposit for the minted mAsset\n   * @param _inputQuantity     Quantity in bAsset units\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintOutput(address _input, uint256 _inputQuantity)\n    external\n    view\n    override\n    returns (uint256 mintOutput)\n  {\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.computeMint(\n      data.bAssetData,\n      input.idx,\n      _inputQuantity,\n      _getConfig()\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\n   * @param _inputQuantities  Quantity of each bAsset to deposit for the minted mAsset.\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintMultiOutput(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities\n  ) external view override returns (uint256 mintOutput) {\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n    uint8[] memory indexes = _getAssets(_inputs);\n    return\n      MassetLogic.computeMintMulti(\n        data.bAssetData,\n        indexes,\n        _inputQuantities,\n        _getConfig()\n      );\n  }\n\n  /***************************************\n                SWAP (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Swaps one bAsset for another bAsset using the bAsset addresses.\n   * bAsset <> bAsset swaps will incur a small fee (swapFee()).\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\n   * @param _recipient         Address to transfer output asset to\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 swapOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    uint256 scaledFee;\n    (swapOutput, scaledFee) = MassetLogic.swap(\n      data,\n      _getConfig(),\n      input,\n      output,\n      _inputQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Swapped(\n      msg.sender,\n      input.addr,\n      output.addr,\n      swapOutput,\n      scaledFee,\n      _recipient\n    );\n  }\n\n  /**\n   * @dev Determines both if a trade is valid, and the expected fee or output.\n   * Swap is valid if it does not result in the input asset exceeding its maximum weight.\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view override returns (uint256 swapOutput) {\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    // 1. Load the bAssets from storage\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    // 2. If a bAsset swap, calculate the validity, output and fee\n    (swapOutput, ) = MassetLogic.computeSwap(\n      data.bAssetData,\n      input.idx,\n      output.idx,\n      _inputQuantity,\n      data.swapFee,\n      _getConfig()\n    );\n  }\n\n  /***************************************\n                REDEMPTION (PUBLIC)\n    ****************************************/\n\n  /**\n   * @notice Redeems a specified quantity of mAsset in return for a bAsset specified by bAsset address.\n   * The bAsset is sent to the specified recipient.\n   * The bAsset quantity is relative to current vault balance levels and desired mAsset quantity.\n   * The quantity of mAsset is burnt as payment.\n   * A minimum quantity of bAsset is specified to protect against price slippage between the mAsset and bAsset.\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt mAssets. This protects against slippage.\n   * @param _recipient         Address to transfer the withdrawn bAssets to.\n   * @return outputQuantity    Quanity of bAsset units received for the burnt mAssets\n   */\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 outputQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    // Get config before burning. Config > Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    uint256 scaledFee;\n    (outputQuantity, scaledFee) = MassetLogic.redeem(\n      data,\n      config,\n      output,\n      _mAssetQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Redeemed(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      output.addr,\n      outputQuantity,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\n   * balance levels and desired mAsset quantity. Burns the mAsset as payment.\n   * @param _mAssetQuantity       Quantity of mAsset to redeem\n   * @param _minOutputQuantities  Min units of output to receive\n   * @param _recipient            Address to credit the withdrawn bAssets\n   */\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256[] memory outputQuantities)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    // Get config before burning. Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    address[] memory outputs;\n    uint256 scaledFee;\n    (scaledFee, outputs, outputQuantities) = MassetLogic.redeemProportionately(\n      data,\n      config,\n      _mAssetQuantity,\n      _minOutputQuantities,\n      _recipient\n    );\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      outputs,\n      outputQuantities,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\n   *      relative Masset quantity from the sender. Sender also incurs a small fee on the outgoing asset.\n   * @param _outputs           Addresses of the bAssets to receive\n   * @param _outputQuantities  Units of the bAssets to redeem\n   * @param _maxMassetQuantity Maximum mAsset quantity to burn for the received bAssets. This protects against slippage.\n   * @param _recipient         Address to receive the withdrawn bAssets\n   * @return mAssetQuantity    Quantity of mAsset units burned plus the swap fee to pay for the redeemed bAssets\n   */\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 mAssetQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n    require(_maxMassetQuantity > 0, \"Qty==0\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    uint256 fee;\n    (mAssetQuantity, fee) = MassetLogic.redeemExactBassets(\n      data,\n      _getConfig(),\n      indexes,\n      _outputQuantities,\n      _maxMassetQuantity,\n      _recipient\n    );\n\n    _burn(msg.sender, mAssetQuantity);\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      mAssetQuantity,\n      _outputs,\n      _outputQuantities,\n      fee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt mAssets\n   */\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n    external\n    view\n    override\n    returns (uint256 bAssetOutput)\n  {\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    (bAssetOutput, ) = MassetLogic.computeRedeem(\n      data.bAssetData,\n      output.idx,\n      _mAssetQuantity,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _outputs           Addresses of the bAsset to receive\n   * @param _outputQuantities  Quantities of bAsset to redeem\n   * @return mAssetQuantity    Estimated quantity of mAsset units needed to burn to receive output\n   */\n  function getRedeemExactBassetsOutput(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities\n  ) external view override returns (uint256 mAssetQuantity) {\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    // calculate the value of mAssets need to cover the value of bAssets being redeemed\n    (mAssetQuantity, ) = MassetLogic.computeRedeemExact(\n      data.bAssetData,\n      indexes,\n      _outputQuantities,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev Get basket details for `Masset_MassetStructs.Basket`\n   * @return b   Basket struct\n   */\n  function getBasket() external view override returns (bool, bool) {\n    return (data.basket.undergoingRecol, data.basket.failed);\n  }\n\n  /**\n   * @dev Get data for a all bAssets in basket\n   * @return personal  Struct[] with full bAsset data\n   * @return bData      Number of bAssets in the Basket\n   */\n  function getBassets()\n    external\n    view\n    override\n    returns (BassetPersonal[] memory personal, BassetData[] memory bData)\n  {\n    return (data.bAssetPersonal, data.bAssetData);\n  }\n\n  /**\n   * @dev Get data for a specific bAsset, if it exists\n   * @param _bAsset   Address of bAsset\n   * @return personal  Struct with full bAsset data\n   * @return bData  Struct with full bAsset data\n   */\n  function getBasset(address _bAsset)\n    external\n    view\n    override\n    returns (BassetPersonal memory personal, BassetData memory bData)\n  {\n    uint8 idx = bAssetIndexes[_bAsset];\n    personal = data.bAssetPersonal[idx];\n    require(personal.addr == _bAsset, \"Invalid asset\");\n    bData = data.bAssetData[idx];\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function getConfig() external view returns (InvariantConfig memory config) {\n    return _getConfig();\n  }\n\n  /**\n   * @notice Gets the price of the fpToken, and invariant value k\n   * @return price    Price of an fpToken\n   * @return k        Total value of basket, k\n   */\n  function getPrice()\n    external\n    view\n    override\n    returns (uint256 price, uint256 k)\n  {\n    return MassetLogic.computePrice(data.bAssetData, _getConfig());\n  }\n\n  /***************************************\n                GETTERS - INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Gets a bAsset from storage\n   * @param _asset      Address of the asset\n   * @return asset      Struct containing bAsset details (idx, data)\n   */\n  function _getAsset(address _asset)\n    internal\n    view\n    returns (Asset memory asset)\n  {\n    asset.idx = bAssetIndexes[_asset];\n    asset.addr = _asset;\n    asset.exists = data.bAssetPersonal[asset.idx].addr == _asset;\n    require(asset.exists, \"Invalid asset\");\n  }\n\n  /**\n   * @dev Gets a an array of bAssets from storage and protects against duplicates\n   * @param _bAssets    Addresses of the assets\n   * @return indexes    Indexes of the assets\n   */\n  function _getAssets(address[] memory _bAssets)\n    internal\n    view\n    returns (uint8[] memory indexes)\n  {\n    uint256 len = _bAssets.length;\n\n    indexes = new uint8[](len);\n\n    Asset memory input_;\n    for (uint256 i = 0; i < len; i++) {\n      input_ = _getAsset(_bAssets[i]);\n      indexes[i] = input_.idx;\n\n      for (uint256 j = i + 1; j < len; j++) {\n        require(_bAssets[i] != _bAssets[j], \"Duplicate asset\");\n      }\n    }\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function _getConfig() internal view returns (InvariantConfig memory) {\n    return\n      InvariantConfig(\n        totalSupply() + data.surplus,\n        _getA(),\n        data.weightLimits,\n        RECOL_FEE\n      );\n  }\n\n  /**\n   * @dev Gets current amplification var A\n   */\n  function _getA() internal view returns (uint256) {\n    AmpData memory ampData_ = data.ampData;\n\n    uint64 endA = ampData_.targetA;\n    uint64 endTime = ampData_.rampEndTime;\n\n    // If still changing, work out based on current timestmap\n    if (block.timestamp < endTime) {\n      uint64 startA = ampData_.initialA;\n      uint64 startTime = ampData_.rampStartTime;\n\n      (uint256 elapsed, uint256 total) = (\n        block.timestamp - startTime,\n        endTime - startTime\n      );\n\n      if (endA > startA) {\n        return startA + (((endA - startA) * elapsed) / total);\n      } else {\n        return startA - (((startA - endA) * elapsed) / total);\n      }\n    }\n    // Else return final value\n    else {\n      return endA;\n    }\n  }\n\n  /***************************************\n                    YIELD\n    ****************************************/\n\n  /**\n   * @dev Converts recently accrued swap and redeem fees into mAsset\n   * @return mintAmount   mAsset units generated from swap and redeem fees\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectInterest()\n    external\n    override\n    onlySavingsManager\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    // Set the surplus variable to 1 to optimise for SSTORE costs.\n    // If setting to 0 here, it would save 5k per savings deposit, but cost 20k for the\n    // first surplus call (a SWAP or REDEEM).\n    uint256 surplusFees = data.surplus;\n    if (surplusFees > 1) {\n      mintAmount = surplusFees - 1;\n      data.surplus = 1;\n\n      // mint new mAsset to savings manager\n      _mint(msg.sender, mintAmount);\n      emit MintedMulti(\n        address(this),\n        msg.sender,\n        mintAmount,\n        new address[](0),\n        new uint256[](0)\n      );\n    }\n    newSupply = totalSupply();\n  }\n\n  /**\n   * @dev Collects the interest generated from the Basket, minting a relative\n   *      amount of mAsset and sends it over to the SavingsMassetManager.\n   * @return mintAmount   mAsset units generated from interest collected from lending markets\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectPlatformInterest()\n    external\n    override\n    onlySavingsManager\n    whenHealthy\n    nonReentrant\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    (uint8[] memory idxs, uint256[] memory gains) = MassetManager\n      .collectPlatformInterest(data.bAssetPersonal, data.bAssetData);\n\n    mintAmount = MassetLogic.computeMintMulti(\n      data.bAssetData,\n      idxs,\n      gains,\n      _getConfig()\n    );\n\n    require(mintAmount > 0, \"Must collect something\");\n\n    _mint(msg.sender, mintAmount);\n    emit MintedMulti(\n      address(this),\n      msg.sender,\n      mintAmount,\n      new address[](0),\n      gains\n    );\n\n    newSupply = totalSupply();\n  }\n\n  /***************************************\n                    STATE\n    ****************************************/\n\n  /**\n   * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\n   *      _cacheSize * totalSupply / 2 under normal circumstances.\n   * @param _cacheSize Maximum percent of total mAsset supply to hold for each bAsset\n   */\n  function setCacheSize(uint256 _cacheSize) external override onlyGovernor {\n    require(_cacheSize <= 2e17, \"Must be <= 20%\");\n\n    data.cacheSize = _cacheSize;\n\n    emit CacheSizeChanged(_cacheSize);\n  }\n\n  /**\n   * @dev Set the ecosystem fee for sewapping bAssets or redeeming specific bAssets\n   * @param _swapFee Fee calculated in (%/100 * 1e18)\n   */\n  function setFees(uint256 _swapFee, uint256 _redemptionFee)\n    external\n    override\n    onlyGovernor\n  {\n    require(_swapFee <= MAX_FEE, \"Swap rate oob\");\n    require(_redemptionFee <= MAX_FEE, \"Redemption rate oob\");\n\n    data.swapFee = _swapFee;\n    data.redemptionFee = _redemptionFee;\n\n    emit FeesChanged(_swapFee, _redemptionFee);\n  }\n\n  /**\n   * @dev Set the maximum weight for a given bAsset\n   * @param _min Weight where 100% = 1e18\n   * @param _max Weight where 100% = 1e18\n   */\n  function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\n    require(_min <= 1e18 / (data.bAssetData.length * 2), \"Min weight oob\");\n    require(_max >= 1e18 / (data.bAssetData.length - 1), \"Max weight oob\");\n\n    data.weightLimits = WeightLimits(_min, _max);\n\n    emit WeightLimitsChanged(_min, _max);\n  }\n\n  /**\n   * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\n   * @param _bAsset   bAsset address\n   * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\n   */\n  function setTransferFeesFlag(address _bAsset, bool _flag)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.setTransferFeesFlag(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _flag\n    );\n  }\n\n  /**\n   * @dev Transfers all collateral from one lending market to another - used initially\n   *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\n   *      tx fee enabled assets. Supports going from no integration to integration, but\n   *      not the other way around.\n   * @param _bAssets Array of basket assets to migrate\n   * @param _newIntegration Address of the new platform integration\n   */\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.migrateBassets(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAssets,\n      _newIntegration\n    );\n  }\n\n  /**\n   * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\n   * @param _bAsset          Address of the ERC20 token to isolate\n   * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\n   *                         or above (f)\n   */\n  function handlePegLoss(address _bAsset, bool _belowPeg)\n    external\n    onlyGovernor\n  {\n    MassetManager.handlePegLoss(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _belowPeg\n    );\n  }\n\n  /**\n   * @dev Negates the isolation of a given bAsset\n   * @param _bAsset Address of the bAsset\n   */\n  function negateIsolation(address _bAsset) external onlyGovernor {\n    MassetManager.negateIsolation(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset\n    );\n  }\n\n  /**\n   * @dev Starts changing of the amplification var A\n   * @param _targetA      Target A value\n   * @param _rampEndTime  Time at which A will arrive at _targetA\n   */\n  function startRampA(uint256 _targetA, uint256 _rampEndTime)\n    external\n    onlyGovernor\n  {\n    MassetManager.startRampA(\n      data.ampData,\n      _targetA,\n      _rampEndTime,\n      _getA(),\n      A_PRECISION\n    );\n  }\n\n  /**\n   * @dev Stops the changing of the amplification var A, setting\n   * it to whatever the current value is.\n   */\n  function stopRampA() external onlyGovernor {\n    MassetManager.stopRampA(data.ampData, _getA());\n  }\n\n  /**\n   * @dev Mints deficit to SAVE if k > token supply\n   */\n  function mintDeficit() external returns (uint256 mintAmount) {\n    require(\n      msg.sender == _governor() || msg.sender == _proxyAdmin(),\n      \"Gov or ProxyAdmin\"\n    );\n\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(k > config.supply, \"No deficit\");\n    mintAmount = k - config.supply;\n    data.surplus += mintAmount;\n\n    emit DeficitMinted(mintAmount);\n  }\n\n  /**\n   * @dev Burns surplus if token supply > k\n   */\n  function burnSurplus() external returns (uint256 burnAmount) {\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(config.supply > k, \"No surplus\");\n    burnAmount = config.supply - k;\n    // Transfer to ensure approval has been given\n    transferFrom(msg.sender, address(this), burnAmount);\n\n    _burn(address(this), burnAmount);\n    emit SurplusBurned(msg.sender, burnAmount);\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/versions/MV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport \"../MassetStructs.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {IBasketManager} from \"../../z_mocks/masset/migrate2/IBasketManager.sol\";\nimport {Basket, Basset} from \"../../z_mocks/masset/migrate2/MassetStructsV1.sol\";\n\nlibrary MV1Migrator {\n  function upgrade(\n    IBasketManager basketManager,\n    BassetPersonal[] storage bAssetPersonal,\n    BassetData[] storage bAssetData,\n    mapping(address => uint8) storage bAssetIndexes\n  ) external {\n    Basket memory importedBasket = basketManager.getBasket();\n\n    uint256 len = importedBasket.bassets.length;\n    uint256[] memory scaledVaultBalances = new uint256[](len);\n    uint256 maxScaledVaultBalance;\n    for (uint8 i = 0; i < len; i++) {\n      Basset memory bAsset = importedBasket.bassets[i];\n      address bAssetAddress = bAsset.addr;\n      bAssetIndexes[bAssetAddress] = i;\n\n      address integratorAddress = basketManager.getBassetIntegrator(\n        bAssetAddress\n      );\n      bAssetPersonal.push(\n        BassetPersonal({\n          addr: bAssetAddress,\n          integrator: integratorAddress,\n          hasTxFee: false,\n          status: BassetStatus.Normal\n        })\n      );\n\n      uint128 ratio = SafeCast.toUint128(bAsset.ratio);\n      uint128 vaultBalance = SafeCast.toUint128(bAsset.vaultBalance);\n      bAssetData.push(BassetData({ratio: ratio, vaultBalance: vaultBalance}));\n\n      // caclulate scaled vault bAsset balance and total vault balance\n      uint128 scaledVaultBalance = (vaultBalance * ratio) / 1e8;\n      scaledVaultBalances[i] = scaledVaultBalance;\n      maxScaledVaultBalance += scaledVaultBalance;\n    }\n\n    // Check each bAsset is under 25.01% weight\n    uint256 maxWeight = 2501;\n    if (len == 3) {\n      maxWeight = 3334;\n    } else if (len != 4) {\n      revert(\"Invalid length\");\n    }\n    maxScaledVaultBalance = (maxScaledVaultBalance * 2501) / 10000;\n    for (uint8 i = 0; i < len; i++) {\n      require(scaledVaultBalances[i] < maxScaledVaultBalance, \"imbalanced\");\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/migrate2/IBasketManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Basket} from \"./MassetStructsV1.sol\";\n\n/**\n * @notice  Is the Basket Manager V2.0 interface used in the upgrade of mUSD from V2.0 to V3.0.\n * @author  mStable\n * @dev     VERSION: 2.0\n *          DATE:    2021-02-23\n */\ninterface IBasketManager {\n  function getBassetIntegrator(address _bAsset)\n    external\n    view\n    returns (address integrator);\n\n  function getBasket() external view returns (Basket memory b);\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/migrate2/MassetStructsV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @notice  Is the Masset V2.0 structs used in the upgrade of mUSD from V2.0 to V3.0.\n * @author  mStable\n * @dev     VERSION: 2.0\n *          DATE:    2021-02-23\n */\n\n/** @dev Stores high level basket info */\nstruct Basket {\n  Basset[] bassets;\n  uint8 maxBassets;\n  bool undergoingRecol;\n  bool failed;\n  uint256 collateralisationRatio;\n}\n\n/** @dev Stores bAsset info. The struct takes 5 storage slots per Basset */\nstruct Basset {\n  address addr;\n  BassetStatus status;\n  bool isTransferFeeCharged;\n  uint256 ratio;\n  uint256 maxWeight;\n  uint256 vaultBalance;\n}\n\n/** @dev Status of the Basset - has it broken its peg? */\nenum BassetStatus {\n  Default,\n  Normal,\n  BrokenBelowPeg,\n  BrokenAbovePeg,\n  Blacklisted,\n  Liquidating,\n  Liquidated,\n  Failed\n}\n\n/** @dev Internal details on Basset */\nstruct BassetDetails {\n  Basset bAsset;\n  address integrator;\n  uint8 index;\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/migrate2/InitializableModuleV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\n/**\n * @notice  Is only used in the upgrade of mUSD from V2.0 to V3.0.\n            This contract preserves the V2.0 storage positions in\n            the new V3.0 Masset contract.\n * @author  mStable\n * @dev     VERSION: 3.0\n *          DATE:    2021-02-23\n */\ncontract InitializableModuleKeysV1 {\n  // Governance                             // Phases\n  bytes32 private KEY_GOVERNANCE_DEPRICATED; // 2.x\n  bytes32 private KEY_STAKING_DEPRICATED; // 1.2\n  bytes32 private KEY_PROXY_ADMIN_DEPRICATED; // 1.0\n\n  // mStable\n  bytes32 private KEY_ORACLE_HUB_DEPRICATED; // 1.2\n  bytes32 private KEY_MANAGER_DEPRICATED; // 1.2\n  bytes32 private KEY_RECOLLATERALISER_DEPRICATED; // 2.x\n  bytes32 private KEY_META_TOKEN_DEPRICATED; // 1.1\n  bytes32 private KEY_SAVINGS_MANAGER_DEPRICATED; // 1.0\n}\n\ncontract InitializableModuleV1 is InitializableModuleKeysV1 {\n  address private nexus_depricated;\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/ExposedMassetLogic.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"../../masset/MassetStructs.sol\";\nimport {MassetLogic} from \"../../masset/MassetLogic.sol\";\n\ncontract ExposedMassetLogic {\n  function computeMint(\n    BassetData[] memory _bAssets,\n    uint8 _i,\n    uint256 _rawInput,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 mintAmount) {\n    return MassetLogic.computeMint(_bAssets, _i, _rawInput, _config);\n  }\n\n  function computeMintMulti(\n    BassetData[] memory _bAssets,\n    uint8[] memory _indices,\n    uint256[] memory _rawInputs,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 mintAmount) {\n    return\n      MassetLogic.computeMintMulti(_bAssets, _indices, _rawInputs, _config);\n  }\n\n  function computeSwap(\n    BassetData[] memory _bAssets,\n    uint8 _i,\n    uint8 _o,\n    uint256 _rawInput,\n    uint256 _feeRate,\n    InvariantConfig memory _config\n  ) public pure returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\n    return\n      MassetLogic.computeSwap(_bAssets, _i, _o, _rawInput, _feeRate, _config);\n  }\n\n  function computeRedeem(\n    BassetData[] memory _bAssets,\n    uint8 _o,\n    uint256 _netMassetQuantity,\n    InvariantConfig memory _config,\n    uint256 _feeRate\n  ) public pure returns (uint256 rawOutputUnits, uint256 scaledFee) {\n    return\n      MassetLogic.computeRedeem(\n        _bAssets,\n        _o,\n        _netMassetQuantity,\n        _config,\n        _feeRate\n      );\n  }\n\n  function computeRedeemExact(\n    BassetData[] memory _bAssets,\n    uint8[] memory _indices,\n    uint256[] memory _rawOutputs,\n    InvariantConfig memory _config,\n    uint256 _feeRate\n  ) public pure returns (uint256 grossMasset, uint256 fee) {\n    return\n      MassetLogic.computeRedeemExact(\n        _bAssets,\n        _indices,\n        _rawOutputs,\n        _config,\n        _feeRate\n      );\n  }\n\n  function getK(BassetData[] memory _bAssets, InvariantConfig memory _config)\n    external\n    pure\n    returns (uint256 k)\n  {\n    (, k) = MassetLogic.computePrice(_bAssets, _config);\n  }\n}\n"
    },
    "contracts/ppo-staking/masset/Masset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\n// Internal\nimport {Initializable} from \"../shared/@openzeppelin-2.5/Initializable.sol\";\nimport {InitializableToken, IERC20} from \"../shared/InitializableToken.sol\";\nimport {ImmutableModule} from \"../shared/ImmutableModule.sol\";\nimport {InitializableReentrancyGuard} from \"../shared/InitializableReentrancyGuard.sol\";\nimport {IMasset} from \"../interfaces/IMasset.sol\";\nimport \"./MassetStructs.sol\";\n\n// Libs\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {StableMath} from \"../shared/StableMath.sol\";\nimport {MassetLogic} from \"./MassetLogic.sol\";\nimport {MassetManager} from \"./MassetManager.sol\";\n\n/**\n * @title   Masset\n * @author  mStable\n * @notice  An incentivised constant sum market maker with hard limits at max region. This supports\n *          low slippage swaps and applies penalties towards min and max regions. AMM produces a\n *          stablecoin (mAsset) and redirects lending market interest and swap fees to the savings\n *          contract, producing a second yield bearing asset.\n * @dev     VERSION: 3.0\n *          DATE:    2021-04-22\n */\ncontract Masset is\n  IMasset,\n  Initializable,\n  InitializableToken,\n  ImmutableModule,\n  InitializableReentrancyGuard\n{\n  using StableMath for uint256;\n\n  // Forging Events\n  event Minted(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address input,\n    uint256 inputQuantity\n  );\n  event MintedMulti(\n    address indexed minter,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] inputs,\n    uint256[] inputQuantities\n  );\n  event Swapped(\n    address indexed swapper,\n    address input,\n    address output,\n    uint256 outputAmount,\n    uint256 scaledFee,\n    address recipient\n  );\n  event Redeemed(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address output,\n    uint256 outputQuantity,\n    uint256 scaledFee\n  );\n  event RedeemedMulti(\n    address indexed redeemer,\n    address recipient,\n    uint256 mAssetQuantity,\n    address[] outputs,\n    uint256[] outputQuantity,\n    uint256 scaledFee\n  );\n\n  // State Events\n  event CacheSizeChanged(uint256 cacheSize);\n  event FeesChanged(uint256 swapFee, uint256 redemptionFee);\n  event WeightLimitsChanged(uint128 min, uint128 max);\n  event ForgeValidatorChanged(address forgeValidator);\n  event DeficitMinted(uint256 amt);\n  event SurplusBurned(address creditor, uint256 amt);\n\n  // Amplification Data\n  uint256 private constant MAX_FEE = 1e16;\n  uint256 private constant A_PRECISION = 100;\n  uint256 private immutable RECOL_FEE;\n  // Core data storage\n  mapping(address => uint8) public override bAssetIndexes;\n  MassetData public data;\n\n  /**\n   * @dev Constructor to set immutable bytecode\n   * @param _nexus   Nexus address\n   */\n  constructor(address _nexus, uint256 _recolFee) ImmutableModule(_nexus) {\n    require(_recolFee <= 5e13, \"RecolFee too high\");\n    RECOL_FEE = _recolFee;\n  }\n\n  /**\n   * @dev Initialization function for upgradable proxy contract.\n   *      This function should be called via Proxy just after contract deployment.\n   *      To avoid variable shadowing appended `Arg` after arguments name.\n   * @param _nameArg          Name of the mAsset\n   * @param _symbolArg        Symbol of the mAsset\n   * @param _bAssets          Array of Basset data\n   */\n  function initialize(\n    string calldata _nameArg,\n    string calldata _symbolArg,\n    BassetPersonal[] calldata _bAssets,\n    BasicConfig memory _config\n  ) public initializer {\n    InitializableToken._initialize(_nameArg, _symbolArg);\n\n    _initializeReentrancyGuard();\n\n    uint256 len = _bAssets.length;\n    require(len > 0, \"No bAssets\");\n    for (uint256 i = 0; i < len; i++) {\n      MassetManager.addBasset(\n        data.bAssetPersonal,\n        data.bAssetData,\n        bAssetIndexes,\n        _bAssets[i].addr,\n        _bAssets[i].integrator,\n        1e8,\n        _bAssets[i].hasTxFee\n      );\n    }\n\n    uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\n    data.ampData = AmpData(startA, startA, 0, 0);\n    data.weightLimits = _config.limits;\n\n    data.swapFee = 6e14; // 0.06% or 6 bps\n    data.redemptionFee = 3e14; // normally 3e14 0.03% or 3 bps\n    data.cacheSize = 1e17; // normally 1e17 (10%)\n  }\n\n  /**\n   * @dev Verifies that the caller is the Savings Manager contract\n   */\n  modifier onlySavingsManager() {\n    _isSavingsManager();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isSavingsManager() internal view {\n    require(_savingsManager() == msg.sender, \"Must be savings manager\");\n  }\n\n  /**\n   * @dev Requires the overall basket composition to be healthy\n   */\n  modifier whenHealthy() {\n    _isHealthy();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _isHealthy() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol && !basket_.failed, \"Unhealthy\");\n  }\n\n  /**\n   * @dev Requires the basket not to be undergoing recollateralisation\n   */\n  modifier whenNoRecol() {\n    _noRecol();\n    _;\n  }\n\n  // Internal fn for modifier to reduce deployment size\n  function _noRecol() internal view {\n    BasketState memory basket_ = data.basket;\n    require(!basket_.undergoingRecol, \"In recol\");\n  }\n\n  /***************************************\n                MINTING (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\n   *      must have approval to spend the senders bAsset\n   * @param _input             Address of the bAsset to deposit for the minted mAsset.\n   * @param _inputQuantity     Quantity in bAsset units\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Receipient of the newly minted mAsset tokens\n   * @return mintOutput        Quantity of newly minted mAssets for the deposited bAsset.\n   */\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.mint(\n      data,\n      _getConfig(),\n      input,\n      _inputQuantity,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit Minted(msg.sender, _recipient, mintOutput, _input, _inputQuantity);\n  }\n\n  /**\n   * @dev Mint with multiple bAssets, at a 1:1 ratio to mAsset. This contract\n   *      must have approval to spend the senders bAssets\n   * @param _inputs            Non-duplicate address array of bASset addresses to deposit for the minted mAsset tokens.\n   * @param _inputQuantities   Quantity of each bAsset to deposit for the minted mAsset.\n   *                           Order of array should mirror the above bAsset addresses.\n   * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\n   * @param _recipient         Address to receive the newly minted mAsset tokens\n   * @return mintOutput    Quantity of newly minted mAssets for the deposited bAssets.\n   */\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n\n    uint8[] memory indexes = _getAssets(_inputs);\n    mintOutput = MassetLogic.mintMulti(\n      data,\n      _getConfig(),\n      indexes,\n      _inputQuantities,\n      _minOutputQuantity\n    );\n\n    // Mint the Masset\n    _mint(_recipient, mintOutput);\n    emit MintedMulti(\n      msg.sender,\n      _recipient,\n      mintOutput,\n      _inputs,\n      _inputQuantities\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _input             Address of the bAsset to deposit for the minted mAsset\n   * @param _inputQuantity     Quantity in bAsset units\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintOutput(address _input, uint256 _inputQuantity)\n    external\n    view\n    override\n    returns (uint256 mintOutput)\n  {\n    require(_inputQuantity > 0, \"Qty==0\");\n\n    Asset memory input = _getAsset(_input);\n\n    mintOutput = MassetLogic.computeMint(\n      data.bAssetData,\n      input.idx,\n      _inputQuantity,\n      _getConfig()\n    );\n  }\n\n  /**\n   * @dev Get the projected output of a given mint\n   * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\n   * @param _inputQuantities  Quantity of each bAsset to deposit for the minted mAsset.\n   * @return mintOutput        Estimated mint output in mAsset terms\n   */\n  function getMintMultiOutput(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities\n  ) external view override returns (uint256 mintOutput) {\n    uint256 len = _inputQuantities.length;\n    require(len > 0 && len == _inputs.length, \"Input array mismatch\");\n    uint8[] memory indexes = _getAssets(_inputs);\n    return\n      MassetLogic.computeMintMulti(\n        data.bAssetData,\n        indexes,\n        _inputQuantities,\n        _getConfig()\n      );\n  }\n\n  /***************************************\n                SWAP (PUBLIC)\n    ****************************************/\n\n  /**\n   * @dev Swaps one bAsset for another bAsset using the bAsset addresses.\n   * bAsset <> bAsset swaps will incur a small fee (swapFee()).\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\n   * @param _recipient         Address to transfer output asset to\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external override nonReentrant whenHealthy returns (uint256 swapOutput) {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    uint256 scaledFee;\n    (swapOutput, scaledFee) = MassetLogic.swap(\n      data,\n      _getConfig(),\n      input,\n      output,\n      _inputQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Swapped(\n      msg.sender,\n      input.addr,\n      output.addr,\n      swapOutput,\n      scaledFee,\n      _recipient\n    );\n  }\n\n  /**\n   * @dev Determines both if a trade is valid, and the expected fee or output.\n   * Swap is valid if it does not result in the input asset exceeding its maximum weight.\n   * @param _input             Address of bAsset to deposit\n   * @param _output            Address of bAsset to receive\n   * @param _inputQuantity     Units of input bAsset to swap\n   * @return swapOutput        Quantity of output asset returned from swap\n   */\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view override returns (uint256 swapOutput) {\n    require(_input != _output, \"Invalid pair\");\n    require(_inputQuantity > 0, \"Invalid swap quantity\");\n\n    // 1. Load the bAssets from storage\n    Asset memory input = _getAsset(_input);\n    Asset memory output = _getAsset(_output);\n\n    // 2. If a bAsset swap, calculate the validity, output and fee\n    (swapOutput, ) = MassetLogic.computeSwap(\n      data.bAssetData,\n      input.idx,\n      output.idx,\n      _inputQuantity,\n      data.swapFee,\n      _getConfig()\n    );\n  }\n\n  /***************************************\n                REDEMPTION (PUBLIC)\n    ****************************************/\n\n  /**\n   * @notice Redeems a specified quantity of mAsset in return for a bAsset specified by bAsset address.\n   * The bAsset is sent to the specified recipient.\n   * The bAsset quantity is relative to current vault balance levels and desired mAsset quantity.\n   * The quantity of mAsset is burnt as payment.\n   * A minimum quantity of bAsset is specified to protect against price slippage between the mAsset and bAsset.\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt mAssets. This protects against slippage.\n   * @param _recipient         Address to transfer the withdrawn bAssets to.\n   * @return outputQuantity    Quanity of bAsset units received for the burnt mAssets\n   */\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 outputQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    // Get config before burning. Config > Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    uint256 scaledFee;\n    (outputQuantity, scaledFee) = MassetLogic.redeem(\n      data,\n      config,\n      output,\n      _mAssetQuantity,\n      _minOutputQuantity,\n      _recipient\n    );\n\n    emit Redeemed(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      output.addr,\n      outputQuantity,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\n   * balance levels and desired mAsset quantity. Burns the mAsset as payment.\n   * @param _mAssetQuantity       Quantity of mAsset to redeem\n   * @param _minOutputQuantities  Min units of output to receive\n   * @param _recipient            Address to credit the withdrawn bAssets\n   */\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256[] memory outputQuantities)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    // Get config before burning. Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    _burn(msg.sender, _mAssetQuantity);\n\n    address[] memory outputs;\n    uint256 scaledFee;\n    (scaledFee, outputs, outputQuantities) = MassetLogic.redeemProportionately(\n      data,\n      config,\n      _mAssetQuantity,\n      _minOutputQuantities,\n      _recipient\n    );\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      _mAssetQuantity,\n      outputs,\n      outputQuantities,\n      scaledFee\n    );\n  }\n\n  /**\n   * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\n   *      relative Masset quantity from the sender. Sender also incurs a small fee on the outgoing asset.\n   * @param _outputs           Addresses of the bAssets to receive\n   * @param _outputQuantities  Units of the bAssets to redeem\n   * @param _maxMassetQuantity Maximum mAsset quantity to burn for the received bAssets. This protects against slippage.\n   * @param _recipient         Address to receive the withdrawn bAssets\n   * @return mAssetQuantity    Quantity of mAsset units burned plus the swap fee to pay for the redeemed bAssets\n   */\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  )\n    external\n    override\n    nonReentrant\n    whenNoRecol\n    returns (uint256 mAssetQuantity)\n  {\n    require(_recipient != address(0), \"Invalid recipient\");\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n    require(_maxMassetQuantity > 0, \"Qty==0\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    uint256 fee;\n    (mAssetQuantity, fee) = MassetLogic.redeemExactBassets(\n      data,\n      _getConfig(),\n      indexes,\n      _outputQuantities,\n      _maxMassetQuantity,\n      _recipient\n    );\n\n    _burn(msg.sender, mAssetQuantity);\n\n    emit RedeemedMulti(\n      msg.sender,\n      _recipient,\n      mAssetQuantity,\n      _outputs,\n      _outputQuantities,\n      fee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _output            Address of the bAsset to receive\n   * @param _mAssetQuantity    Quantity of mAsset to redeem\n   * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt mAssets\n   */\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n    external\n    view\n    override\n    returns (uint256 bAssetOutput)\n  {\n    require(_mAssetQuantity > 0, \"Qty==0\");\n\n    Asset memory output = _getAsset(_output);\n\n    (bAssetOutput, ) = MassetLogic.computeRedeem(\n      data.bAssetData,\n      output.idx,\n      _mAssetQuantity,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /**\n   * @notice Gets the estimated output from a given redeem\n   * @param _outputs           Addresses of the bAsset to receive\n   * @param _outputQuantities  Quantities of bAsset to redeem\n   * @return mAssetQuantity    Estimated quantity of mAsset units needed to burn to receive output\n   */\n  function getRedeemExactBassetsOutput(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities\n  ) external view override returns (uint256 mAssetQuantity) {\n    uint256 len = _outputQuantities.length;\n    require(len > 0 && len == _outputs.length, \"Invalid array input\");\n\n    uint8[] memory indexes = _getAssets(_outputs);\n\n    // calculate the value of mAssets need to cover the value of bAssets being redeemed\n    (mAssetQuantity, ) = MassetLogic.computeRedeemExact(\n      data.bAssetData,\n      indexes,\n      _outputQuantities,\n      _getConfig(),\n      data.swapFee\n    );\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev Get basket details for `Masset_MassetStructs.Basket`\n   * @return b   Basket struct\n   */\n  function getBasket() external view override returns (bool, bool) {\n    return (data.basket.undergoingRecol, data.basket.failed);\n  }\n\n  /**\n   * @dev Get data for a all bAssets in basket\n   * @return personal  Struct[] with full bAsset data\n   * @return bData      Number of bAssets in the Basket\n   */\n  function getBassets()\n    external\n    view\n    override\n    returns (BassetPersonal[] memory personal, BassetData[] memory bData)\n  {\n    return (data.bAssetPersonal, data.bAssetData);\n  }\n\n  /**\n   * @dev Get data for a specific bAsset, if it exists\n   * @param _bAsset   Address of bAsset\n   * @return personal  Struct with full bAsset data\n   * @return bData  Struct with full bAsset data\n   */\n  function getBasset(address _bAsset)\n    external\n    view\n    override\n    returns (BassetPersonal memory personal, BassetData memory bData)\n  {\n    uint8 idx = bAssetIndexes[_bAsset];\n    personal = data.bAssetPersonal[idx];\n    require(personal.addr == _bAsset, \"Invalid asset\");\n    bData = data.bAssetData[idx];\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function getConfig() external view returns (InvariantConfig memory config) {\n    return _getConfig();\n  }\n\n  /**\n   * @notice Gets the price of the fpToken, and invariant value k\n   * @return price    Price of an fpToken\n   * @return k        Total value of basket, k\n   */\n  function getPrice()\n    external\n    view\n    override\n    returns (uint256 price, uint256 k)\n  {\n    return MassetLogic.computePrice(data.bAssetData, _getConfig());\n  }\n\n  /***************************************\n                GETTERS - INTERNAL\n    ****************************************/\n\n  /**\n   * @dev Gets a bAsset from storage\n   * @param _asset      Address of the asset\n   * @return asset      Struct containing bAsset details (idx, data)\n   */\n  function _getAsset(address _asset)\n    internal\n    view\n    returns (Asset memory asset)\n  {\n    asset.idx = bAssetIndexes[_asset];\n    asset.addr = _asset;\n    asset.exists = data.bAssetPersonal[asset.idx].addr == _asset;\n    require(asset.exists, \"Invalid asset\");\n  }\n\n  /**\n   * @dev Gets a an array of bAssets from storage and protects against duplicates\n   * @param _bAssets    Addresses of the assets\n   * @return indexes    Indexes of the assets\n   */\n  function _getAssets(address[] memory _bAssets)\n    internal\n    view\n    returns (uint8[] memory indexes)\n  {\n    uint256 len = _bAssets.length;\n\n    indexes = new uint8[](len);\n\n    Asset memory input_;\n    for (uint256 i = 0; i < len; i++) {\n      input_ = _getAsset(_bAssets[i]);\n      indexes[i] = input_.idx;\n\n      for (uint256 j = i + 1; j < len; j++) {\n        require(_bAssets[i] != _bAssets[j], \"Duplicate asset\");\n      }\n    }\n  }\n\n  /**\n   * @dev Gets all config needed for general InvariantValidator calls\n   */\n  function _getConfig() internal view returns (InvariantConfig memory) {\n    return\n      InvariantConfig(\n        totalSupply() + data.surplus,\n        _getA(),\n        data.weightLimits,\n        RECOL_FEE\n      );\n  }\n\n  /**\n   * @dev Gets current amplification var A\n   */\n  function _getA() internal view returns (uint256) {\n    AmpData memory ampData_ = data.ampData;\n\n    uint64 endA = ampData_.targetA;\n    uint64 endTime = ampData_.rampEndTime;\n\n    // If still changing, work out based on current timestmap\n    if (block.timestamp < endTime) {\n      uint64 startA = ampData_.initialA;\n      uint64 startTime = ampData_.rampStartTime;\n\n      (uint256 elapsed, uint256 total) = (\n        block.timestamp - startTime,\n        endTime - startTime\n      );\n\n      if (endA > startA) {\n        return startA + (((endA - startA) * elapsed) / total);\n      } else {\n        return startA - (((startA - endA) * elapsed) / total);\n      }\n    }\n    // Else return final value\n    else {\n      return endA;\n    }\n  }\n\n  /***************************************\n                    YIELD\n    ****************************************/\n\n  /**\n   * @dev Converts recently accrued swap and redeem fees into mAsset\n   * @return mintAmount   mAsset units generated from swap and redeem fees\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectInterest()\n    external\n    override\n    onlySavingsManager\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    // Set the surplus variable to 1 to optimise for SSTORE costs.\n    // If setting to 0 here, it would save 5k per savings deposit, but cost 20k for the\n    // first surplus call (a SWAP or REDEEM).\n    uint256 surplusFees = data.surplus;\n    if (surplusFees > 1) {\n      mintAmount = surplusFees - 1;\n      data.surplus = 1;\n\n      // mint new mAsset to savings manager\n      _mint(msg.sender, mintAmount);\n      emit MintedMulti(\n        address(this),\n        msg.sender,\n        mintAmount,\n        new address[](0),\n        new uint256[](0)\n      );\n    }\n    newSupply = totalSupply();\n  }\n\n  /**\n   * @dev Collects the interest generated from the Basket, minting a relative\n   *      amount of mAsset and sends it over to the SavingsMassetManager.\n   * @return mintAmount   mAsset units generated from interest collected from lending markets\n   * @return newSupply    mAsset total supply after mint\n   */\n  function collectPlatformInterest()\n    external\n    override\n    onlySavingsManager\n    whenHealthy\n    nonReentrant\n    returns (uint256 mintAmount, uint256 newSupply)\n  {\n    (uint8[] memory idxs, uint256[] memory gains) = MassetManager\n      .collectPlatformInterest(data.bAssetPersonal, data.bAssetData);\n\n    mintAmount = MassetLogic.computeMintMulti(\n      data.bAssetData,\n      idxs,\n      gains,\n      _getConfig()\n    );\n\n    require(mintAmount > 0, \"Must collect something\");\n\n    _mint(msg.sender, mintAmount);\n    emit MintedMulti(\n      address(this),\n      msg.sender,\n      mintAmount,\n      new address[](0),\n      gains\n    );\n\n    newSupply = totalSupply();\n  }\n\n  /***************************************\n                    STATE\n    ****************************************/\n\n  /**\n   * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\n   *      _cacheSize * totalSupply / 2 under normal circumstances.\n   * @param _cacheSize Maximum percent of total mAsset supply to hold for each bAsset\n   */\n  function setCacheSize(uint256 _cacheSize) external override onlyGovernor {\n    require(_cacheSize <= 2e17, \"Must be <= 20%\");\n\n    data.cacheSize = _cacheSize;\n\n    emit CacheSizeChanged(_cacheSize);\n  }\n\n  /**\n   * @dev Set the ecosystem fee for sewapping bAssets or redeeming specific bAssets\n   * @param _swapFee Fee calculated in (%/100 * 1e18)\n   */\n  function setFees(uint256 _swapFee, uint256 _redemptionFee)\n    external\n    override\n    onlyGovernor\n  {\n    require(_swapFee <= MAX_FEE, \"Swap rate oob\");\n    require(_redemptionFee <= MAX_FEE, \"Redemption rate oob\");\n\n    data.swapFee = _swapFee;\n    data.redemptionFee = _redemptionFee;\n\n    emit FeesChanged(_swapFee, _redemptionFee);\n  }\n\n  /**\n   * @dev Set the maximum weight for a given bAsset\n   * @param _min Weight where 100% = 1e18\n   * @param _max Weight where 100% = 1e18\n   */\n  function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\n    require(_min <= 1e18 / (data.bAssetData.length * 2), \"Min weight oob\");\n    require(_max >= 1e18 / (data.bAssetData.length - 1), \"Max weight oob\");\n\n    data.weightLimits = WeightLimits(_min, _max);\n\n    emit WeightLimitsChanged(_min, _max);\n  }\n\n  /**\n   * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\n   * @param _bAsset   bAsset address\n   * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\n   */\n  function setTransferFeesFlag(address _bAsset, bool _flag)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.setTransferFeesFlag(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _flag\n    );\n  }\n\n  /**\n   * @dev Transfers all collateral from one lending market to another - used initially\n   *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\n   *      tx fee enabled assets. Supports going from no integration to integration, but\n   *      not the other way around.\n   * @param _bAssets Array of basket assets to migrate\n   * @param _newIntegration Address of the new platform integration\n   */\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration)\n    external\n    override\n    onlyGovernor\n  {\n    MassetManager.migrateBassets(\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAssets,\n      _newIntegration\n    );\n  }\n\n  /**\n   * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\n   * @param _bAsset          Address of the ERC20 token to isolate\n   * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\n   *                         or above (f)\n   */\n  function handlePegLoss(address _bAsset, bool _belowPeg)\n    external\n    onlyGovernor\n  {\n    MassetManager.handlePegLoss(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset,\n      _belowPeg\n    );\n  }\n\n  /**\n   * @dev Negates the isolation of a given bAsset\n   * @param _bAsset Address of the bAsset\n   */\n  function negateIsolation(address _bAsset) external onlyGovernor {\n    MassetManager.negateIsolation(\n      data.basket,\n      data.bAssetPersonal,\n      bAssetIndexes,\n      _bAsset\n    );\n  }\n\n  /**\n   * @dev Starts changing of the amplification var A\n   * @param _targetA      Target A value\n   * @param _rampEndTime  Time at which A will arrive at _targetA\n   */\n  function startRampA(uint256 _targetA, uint256 _rampEndTime)\n    external\n    onlyGovernor\n  {\n    MassetManager.startRampA(\n      data.ampData,\n      _targetA,\n      _rampEndTime,\n      _getA(),\n      A_PRECISION\n    );\n  }\n\n  /**\n   * @dev Stops the changing of the amplification var A, setting\n   * it to whatever the current value is.\n   */\n  function stopRampA() external onlyGovernor {\n    MassetManager.stopRampA(data.ampData, _getA());\n  }\n\n  /**\n   * @dev Mints deficit to SAVE if k > token supply\n   */\n  function mintDeficit() external returns (uint256 mintAmount) {\n    require(\n      msg.sender == _governor() || msg.sender == _proxyAdmin(),\n      \"Gov or ProxyAdmin\"\n    );\n\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(k > config.supply, \"No deficit\");\n    mintAmount = k - config.supply;\n    data.surplus += mintAmount;\n\n    emit DeficitMinted(mintAmount);\n  }\n\n  /**\n   * @dev Burns surplus if token supply > k\n   */\n  function burnSurplus() external returns (uint256 burnAmount) {\n    InvariantConfig memory config = _getConfig();\n    (, uint256 k) = MassetLogic.computePrice(data.bAssetData, config);\n    require(config.supply > k, \"No surplus\");\n    burnAmount = config.supply - k;\n\n    _burn(msg.sender, burnAmount);\n\n    emit SurplusBurned(msg.sender, burnAmount);\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/ExposedMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Masset, InvariantConfig} from \"../../masset/Masset.sol\";\nimport {MassetLogic} from \"../../masset/MassetLogic.sol\";\n\ncontract ExposedMasset is Masset {\n  constructor(address _nexus, uint256 _recolFee) Masset(_nexus, _recolFee) {}\n\n  uint256 private amountToMint = 0;\n\n  function getK() external view returns (uint256 k) {\n    (, k) = MassetLogic.computePrice(data.bAssetData, _getConfig());\n  }\n\n  function getA() public view returns (uint256) {\n    return super._getA();\n  }\n\n  function simulateRedeemMasset(\n    uint256 _amt,\n    uint256[] calldata _minOut,\n    uint256 _recolFee\n  ) external {\n    // Get config before burning. Burn > CacheSize\n    InvariantConfig memory config = _getConfig();\n    config.recolFee = _recolFee;\n    MassetLogic.redeemProportionately(data, config, _amt, _minOut, msg.sender);\n  }\n\n  // Inject amount of tokens to mint\n  function setAmountForCollectInterest(uint256 _amount) public {\n    amountToMint = _amount;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/savings/MockSavingsManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IMasset} from \"../../interfaces/IMasset.sol\";\nimport {ISavingsContractV1} from \"../../interfaces/ISavingsContract.sol\";\nimport {IRevenueRecipient} from \"../../interfaces/IRevenueRecipient.sol\";\nimport {IERC20} from \"../shared/MockERC20.sol\";\n\ncontract MockSavingsManager {\n  address public immutable save;\n  IRevenueRecipient public recipient;\n  uint256 public rate = 1e18;\n\n  constructor(address _save) {\n    save = _save;\n  }\n\n  function collectAndDistributeInterest(address _mAsset) public {\n    require(save != address(0), \"Must have a valid savings contract\");\n\n    // 1. Collect the new interest from the mAsset\n    IMasset mAsset = IMasset(_mAsset);\n    (uint256 interestCollected, ) = mAsset.collectInterest();\n\n    // 3. Validate that interest is collected correctly and does not exceed max APY\n    if (interestCollected > 0) {\n      IERC20(_mAsset).approve(save, interestCollected);\n\n      ISavingsContractV1(save).depositInterest(\n        (interestCollected * rate) / 1e18\n      );\n    }\n  }\n\n  function setRecipient(address _recipient, uint256 _rate) public {\n    recipient = IRevenueRecipient(_recipient);\n    rate = _rate;\n  }\n\n  function distributeUnallocatedInterest(address _mAsset) public {\n    require(save != address(0), \"Must have a valid savings contract\");\n\n    uint256 bal = IERC20(_mAsset).balanceOf(address(this));\n    IERC20(_mAsset).approve(save, bal);\n\n    recipient.notifyRedistributionAmount(_mAsset, bal);\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  uint8 dec;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) ERC20(_name, _symbol) {\n    dec = _decimals;\n    _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));\n  }\n\n  function decimals() public view override returns (uint8) {\n    return dec;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/MockMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {MockERC20} from \"../shared/MockERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IBasicToken} from \"../../shared/IBasicToken.sol\";\n\ncontract MockMasset is MockERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) MockERC20(_name, _symbol, _decimals, _initialRecipient, _initialMint) {}\n\n  function setRatio(uint256 _newRatio) external {\n    ratio = _newRatio;\n  }\n\n  uint256 ratio = 98e16;\n  uint256 private amountToMint = 0;\n  uint256 private platformAmountToMint = 0;\n\n  // Inject amount of tokens to mint\n  function setAmountForCollectInterest(uint256 _amount) public {\n    amountToMint = _amount;\n  }\n\n  // Inject amount of tokens to mint\n  function setAmountForPlatformInterest(uint256 _amount) public {\n    platformAmountToMint = _amount;\n  }\n\n  function collectInterest()\n    external\n    returns (uint256 totalInterestGained, uint256 newSupply)\n  {\n    _mint(msg.sender, amountToMint);\n    totalInterestGained = amountToMint;\n    newSupply = totalSupply();\n    // Set back to zero\n    amountToMint = 0;\n  }\n\n  function collectPlatformInterest()\n    external\n    returns (uint256 totalInterestGained, uint256 newSupply)\n  {\n    _mint(msg.sender, platformAmountToMint);\n    totalInterestGained = platformAmountToMint;\n    newSupply = totalSupply();\n    // Set back to zero\n    platformAmountToMint = 0;\n  }\n\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 out_amt) {\n    uint256 decimals = IBasicToken(_input).decimals();\n    out_amt = (_inputQuantity * (10**(18 - decimals)) * ratio) / 1e18;\n    require(out_amt >= _minOutputQuantity, \"MINT: Output amount not enough\");\n    IERC20(_input).transferFrom(msg.sender, address(this), _inputQuantity);\n    _mint(_recipient, out_amt);\n  }\n\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 outputQuantity) {\n    _burn(msg.sender, _mAssetQuantity);\n\n    uint256 decimals = IBasicToken(_output).decimals();\n    outputQuantity = (_mAssetQuantity * ratio * (10**decimals)) / 1e36;\n    require(outputQuantity >= _minOutputQuantity, \"bAsset qty < min qty\");\n    require(outputQuantity > 0, \"Output == 0\");\n\n    IERC20(_output).transfer(_recipient, outputQuantity);\n  }\n}\n\ncontract MockMasset1 is MockERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) MockERC20(_name, _symbol, _decimals, _initialRecipient, _initialMint) {}\n\n  uint256 private amountToMint = 0;\n\n  // Inject amount of tokens to mint\n  function setAmountForCollectInterest(uint256 _amount) public {\n    amountToMint = _amount;\n  }\n\n  function collectInterest()\n    external\n    returns (uint256 totalInterestGained, uint256 newSupply)\n  {\n    totalInterestGained = amountToMint;\n    newSupply = totalSupply();\n    // Set back to zero\n    amountToMint = 0;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockInitializableToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ERC205} from \"../../shared/@openzeppelin-2.5/ERC205.sol\";\nimport {InitializableERC20Detailed} from \"../../shared/InitializableERC20Detailed.sol\";\n\n/**\n * @title  InitializableToken\n * @author mStable\n * @dev    Basic ERC20Detailed Token functionality for Masset\n */\ncontract MockInitializableToken is ERC205, InitializableERC20Detailed {\n  /**\n   * @dev Initialization function for implementing contract\n   * @notice To avoid variable shadowing appended `Arg` after arguments name.\n   */\n  function initialize(\n    string calldata _nameArg,\n    string calldata _symbolArg,\n    uint8 _decimals,\n    address _initialRecipient,\n    uint256 _initialMint\n  ) external {\n    InitializableERC20Detailed._initialize(_nameArg, _symbolArg, _decimals);\n\n    _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IFeederPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport \"../masset/MassetStructs.sol\";\n\nabstract contract IFeederPool {\n  // Mint\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mintOutput);\n\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mintOutput);\n\n  function getMintOutput(address _input, uint256 _inputQuantity)\n    external\n    view\n    virtual\n    returns (uint256 mintOutput);\n\n  function getMintMultiOutput(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities\n  ) external view virtual returns (uint256 mintOutput);\n\n  // Swaps\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 swapOutput);\n\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view virtual returns (uint256 swapOutput);\n\n  // Redemption\n  function redeem(\n    address _output,\n    uint256 _fpTokenQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external virtual returns (uint256 outputQuantity);\n\n  function redeemProportionately(\n    uint256 _fpTokenQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  ) external virtual returns (uint256[] memory outputQuantities);\n\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  ) external virtual returns (uint256 mAssetRedeemed);\n\n  function getRedeemOutput(address _output, uint256 _fpTokenQuantity)\n    external\n    view\n    virtual\n    returns (uint256 bAssetOutput);\n\n  function getRedeemExactBassetsOutput(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities\n  ) external view virtual returns (uint256 mAssetAmount);\n\n  // Views\n  function mAsset() external view virtual returns (address);\n\n  function getPrice() public view virtual returns (uint256 price, uint256 k);\n\n  function getConfig()\n    external\n    view\n    virtual\n    returns (FeederConfig memory config);\n\n  function getBasset(address _token)\n    external\n    view\n    virtual\n    returns (BassetPersonal memory personal, BassetData memory data);\n\n  function getBassets()\n    external\n    view\n    virtual\n    returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n  // SavingsManager\n  function collectPlatformInterest()\n    external\n    virtual\n    returns (uint256 mintAmount, uint256 newSupply);\n\n  function collectPendingFees() external virtual;\n}\n"
    },
    "contracts/ppo-staking/z_mocks/shared/MockRoot.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Root} from \"../../shared/Root.sol\";\n\ncontract MockRoot {\n  function sqrt(uint256 r) public pure returns (uint256) {\n    return Root.sqrt(r);\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/StakedToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport {IStakedToken} from \"./interfaces/IStakedToken.sol\";\nimport {GamifiedVotingToken} from \"./GamifiedVotingToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Root} from \"../../shared/Root.sol\";\nimport {InitializableReentrancyGuard} from \"../../shared/InitializableReentrancyGuard.sol\";\nimport \"./deps/GamifiedTokenStructs.sol\";\n\n/**\n * @title StakedToken\n * @notice StakedToken is a non-transferrable ERC20 token that allows users to stake and withdraw, earning voting rights.\n * Scaled balance is determined by quests a user completes, and the length of time they keep the raw balance wrapped.\n * Stakers can unstake, after the elapsed cooldown period, and before the end of the unstake window. Users voting/earning\n * power is slashed during this time, and they may face a redemption fee if they leave early.\n * The reason for this unstake window is that this StakedToken acts as a source of insurance value for the mStable system,\n * which can access the funds via the Recollateralisation module, up to the amount defined in `safetyData`.\n * Voting power can be used for a number of things: voting in the mStable DAO/emission dials, boosting rewards, earning\n * rewards here. While a users \"balance\" is unique to themselves, they can choose to delegate their voting power (which will apply\n * to voting in the mStable DAO and emission dials).\n * @author mStable\n * @dev Only whitelisted contracts can communicate with this contract, in order to avoid having tokenised wrappers that\n * could potentially circumvent our unstaking procedure.\n **/\ncontract StakedToken is GamifiedVotingToken, InitializableReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  /// @notice Core token that is staked and tracked (e.g. MTA)\n  IERC20 public immutable STAKED_TOKEN;\n  /// @notice Seconds a user must wait after she initiates her cooldown before withdrawal is possible\n  uint256 public immutable COOLDOWN_SECONDS;\n  /// @notice Window in which it is possible to withdraw, following the cooldown period\n  uint256 public immutable UNSTAKE_WINDOW;\n  /// @notice A week\n  uint256 private constant ONE_WEEK = 7 days;\n\n  struct SafetyData {\n    /// Percentage of collateralisation where 100% = 1e18\n    uint128 collateralisationRatio;\n    /// Slash % where 100% = 1e18\n    uint128 slashingPercentage;\n  }\n\n  /// @notice Data relating to the re-collateralisation safety module\n  SafetyData public safetyData;\n\n  /// @notice Whitelisted smart contract integrations\n  mapping(address => bool) public whitelistedWrappers;\n\n  event Staked(address indexed user, uint256 amount, address delegatee);\n  event Withdraw(address indexed user, address indexed to, uint256 amount);\n  event Cooldown(address indexed user, uint256 percentage);\n  event CooldownExited(address indexed user);\n  event SlashRateChanged(uint256 newRate);\n  event Recollateralised();\n  event WrapperWhitelisted(address wallet);\n  event WrapperBlacklisted(address wallet);\n\n  /***************************************\n                    INIT\n    ****************************************/\n\n  /**\n   * @param _nexus System nexus\n   * @param _rewardsToken Token that is being distributed as a reward. eg MTA\n   * @param _questManager Centralised manager of quests\n   * @param _stakedToken Core token that is staked and tracked (e.g. MTA)\n   * @param _cooldownSeconds Seconds a user must wait after she initiates her cooldown before withdrawal is possible\n   * @param _unstakeWindow Window in which it is possible to withdraw, following the cooldown period\n   * @param _hasPriceCoeff true if raw staked amount is multiplied by price coeff to get staked amount. eg BPT Staked Token\n   */\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _questManager,\n    address _stakedToken,\n    uint256 _cooldownSeconds,\n    uint256 _unstakeWindow,\n    bool _hasPriceCoeff\n  ) GamifiedVotingToken(_nexus, _rewardsToken, _questManager, _hasPriceCoeff) {\n    STAKED_TOKEN = IERC20(_stakedToken);\n    COOLDOWN_SECONDS = _cooldownSeconds;\n    UNSTAKE_WINDOW = _unstakeWindow;\n  }\n\n  /**\n   * @param _nameArg Token name\n   * @param _symbolArg Token symbol\n   * @param _rewardsDistributorArg mStable Rewards Distributor\n   */\n  function __StakedToken_init(\n    bytes32 _nameArg,\n    bytes32 _symbolArg,\n    address _rewardsDistributorArg\n  ) public initializer {\n    __GamifiedToken_init(_nameArg, _symbolArg, _rewardsDistributorArg);\n    _initializeReentrancyGuard();\n    safetyData = SafetyData({\n      collateralisationRatio: 1e18,\n      slashingPercentage: 0\n    });\n  }\n\n  /**\n   * @dev Only the recollateralisation module, as specified in the mStable Nexus, can execute this\n   */\n  modifier onlyRecollateralisationModule() {\n    require(\n      _msgSender() == _recollateraliser(),\n      \"Only Recollateralisation Module\"\n    );\n    _;\n  }\n\n  /**\n   * @dev This protects against fn's being called after a recollateralisation event, when the contract is essentially finished\n   */\n  modifier onlyBeforeRecollateralisation() {\n    _onlyBeforeRecollateralisation();\n    _;\n  }\n\n  function _onlyBeforeRecollateralisation() internal view {\n    require(\n      safetyData.collateralisationRatio == 1e18,\n      \"Only while fully collateralised\"\n    );\n  }\n\n  /**\n   * @dev Only whitelisted contracts can call core fns. mStable governors can whitelist and de-whitelist wrappers.\n   * Access may be given to yield optimisers to boost rewards, but creating unlimited and ungoverned wrappers is unadvised.\n   */\n  modifier assertNotContract() {\n    _assertNotContract();\n    _;\n  }\n\n  function _assertNotContract() internal view {\n    if (_msgSender() != tx.origin) {\n      require(whitelistedWrappers[_msgSender()], \"Not a whitelisted contract\");\n    }\n  }\n\n  /***************************************\n                    ACTIONS\n    ****************************************/\n\n  /**\n   * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\n   * boosts their voting power.\n   * @param _amount Units of STAKED_TOKEN to stake\n   */\n  function stake(uint256 _amount) external {\n    _transferAndStake(_amount, address(0), false);\n  }\n\n  /**\n   * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\n   * boosts their voting power.\n   * @param _amount Units of STAKED_TOKEN to stake\n   * @param _exitCooldown Bool signalling whether to take this opportunity to end any outstanding cooldown and\n   * return the user back to their full voting power\n   */\n  function stake(uint256 _amount, bool _exitCooldown) external {\n    _transferAndStake(_amount, address(0), _exitCooldown);\n  }\n\n  /**\n   * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\n   * boosts their voting power. Take the opportunity to change delegatee.\n   * @param _amount Units of STAKED_TOKEN to stake\n   * @param _delegatee Address of the user to whom the sender would like to delegate their voting power\n   */\n  function stake(uint256 _amount, address _delegatee) external {\n    _transferAndStake(_amount, _delegatee, false);\n  }\n\n  /**\n   * @dev Transfers tokens from sender before calling `_settleStake`\n   */\n  function _transferAndStake(\n    uint256 _amount,\n    address _delegatee,\n    bool _exitCooldown\n  ) internal {\n    STAKED_TOKEN.safeTransferFrom(_msgSender(), address(this), _amount);\n    _settleStake(_amount, _delegatee, _exitCooldown);\n  }\n\n  /**\n   * @dev Internal stake fn. Can only be called by whitelisted contracts/EOAs and only before a recollateralisation event.\n   * NOTE - Assumes tokens have already been transferred\n   * @param _amount Units of STAKED_TOKEN to stake\n   * @param _delegatee Address of the user to whom the sender would like to delegate their voting power\n   * @param _exitCooldown Bool signalling whether to take this opportunity to end any outstanding cooldown and\n   * return the user back to their full voting power\n   */\n  function _settleStake(\n    uint256 _amount,\n    address _delegatee,\n    bool _exitCooldown\n  ) internal onlyBeforeRecollateralisation assertNotContract {\n    require(_amount != 0, \"INVALID_ZERO_AMOUNT\");\n\n    // 1. Apply the delegate if it has been chosen (else it defaults to the sender)\n    if (_delegatee != address(0)) {\n      _delegate(_msgSender(), _delegatee);\n    }\n\n    // 2. Deal with cooldown\n    //      If a user is currently in a cooldown period, re-calculate their cooldown timestamp\n    Balance memory oldBalance = _balances[_msgSender()];\n    //      If we have missed the unstake window, or the user has chosen to exit the cooldown,\n    //      then reset the timestamp to 0\n    bool exitCooldown = _exitCooldown ||\n      (oldBalance.cooldownTimestamp > 0 &&\n        block.timestamp >\n        (oldBalance.cooldownTimestamp + COOLDOWN_SECONDS + UNSTAKE_WINDOW));\n    if (exitCooldown) {\n      emit CooldownExited(_msgSender());\n    }\n\n    // 3. Settle the stake by depositing the STAKED_TOKEN and minting voting power\n    _mintRaw(_msgSender(), _amount, exitCooldown);\n\n    emit Staked(_msgSender(), _amount, _delegatee);\n  }\n\n  /**\n   * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\n   * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\n   * @param _amount Units of raw token to withdraw\n   * @param _recipient Address of beneficiary who will receive the raw tokens\n   * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\n   * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\n   **/\n  function withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) external {\n    _withdraw(_amount, _recipient, _amountIncludesFee, _exitCooldown);\n  }\n\n  /**\n   * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\n   * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\n   * @param _amount Units of raw token to withdraw\n   * @param _recipient Address of beneficiary who will receive the raw tokens\n   * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\n   * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\n   **/\n  function _withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) internal assertNotContract {\n    require(_amount != 0, \"INVALID_ZERO_AMOUNT\");\n\n    // Is the contract post-recollateralisation?\n    if (safetyData.collateralisationRatio != 1e18) {\n      // 1. If recollateralisation has occured, the contract is finished and we can skip all checks\n      _burnRaw(_msgSender(), _amount, false, true);\n      // 2. Return a proportionate amount of tokens, based on the collateralisation ratio\n      STAKED_TOKEN.safeTransfer(\n        _recipient,\n        (_amount * safetyData.collateralisationRatio) / 1e18\n      );\n      emit Withdraw(_msgSender(), _recipient, _amount);\n    } else {\n      // 1. If no recollateralisation has occured, the user must be within their UNSTAKE_WINDOW period in order to withdraw\n      Balance memory oldBalance = _balances[_msgSender()];\n      require(\n        block.timestamp > oldBalance.cooldownTimestamp + COOLDOWN_SECONDS,\n        \"INSUFFICIENT_COOLDOWN\"\n      );\n      require(\n        block.timestamp - (oldBalance.cooldownTimestamp + COOLDOWN_SECONDS) <=\n          UNSTAKE_WINDOW,\n        \"UNSTAKE_WINDOW_FINISHED\"\n      );\n\n      // 2. Get current balance\n      Balance memory balance = _balances[_msgSender()];\n\n      // 3. Apply redemption fee\n      //      e.g. (55e18 / 5e18) - 2e18 = 9e18 / 100 = 9e16\n      uint256 feeRate = calcRedemptionFeeRate(balance.weightedTimestamp);\n      //      fee = amount * 1e18 / feeRate\n      //      totalAmount = amount + fee\n      uint256 totalWithdraw = _amountIncludesFee\n        ? _amount\n        : (_amount * (1e18 + feeRate)) / 1e18;\n      uint256 userWithdrawal = (totalWithdraw * 1e18) / (1e18 + feeRate);\n\n      //      Check for percentage withdrawal\n      uint256 maxWithdrawal = oldBalance.cooldownUnits;\n      require(totalWithdraw <= maxWithdrawal, \"Exceeds max withdrawal\");\n\n      // 4. Exit cooldown if the user has specified, or if they have withdrawn everything\n      // Otherwise, update the percentage remaining proportionately\n      bool exitCooldown = _exitCooldown || totalWithdraw == maxWithdrawal;\n\n      // 5. Settle the withdrawal by burning the voting tokens\n      _burnRaw(_msgSender(), totalWithdraw, exitCooldown, false);\n      //      Log any redemption fee to the rewards contract\n      _notifyAdditionalReward(totalWithdraw - userWithdrawal);\n      //      Finally transfer tokens back to recipient\n      STAKED_TOKEN.safeTransfer(_recipient, userWithdrawal);\n\n      emit Withdraw(_msgSender(), _recipient, _amount);\n    }\n  }\n\n  /**\n   * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\n   * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\n   * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\n   * @param _units Units of stake to cooldown for\n   **/\n  function startCooldown(uint256 _units) external {\n    _startCooldown(_units);\n  }\n\n  /**\n   * @dev Ends the cooldown of the sender and give them back their full voting power. This can be used to signal that\n   * the user no longer wishes to exit the system. Note, the cooldown can also be reset, more smoothly, as part of a stake or\n   * withdraw transaction.\n   **/\n  function endCooldown() external {\n    require(_balances[_msgSender()].cooldownTimestamp != 0, \"No cooldown\");\n\n    _exitCooldownPeriod(_msgSender());\n\n    emit CooldownExited(_msgSender());\n  }\n\n  /**\n   * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\n   * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\n   * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\n   * @param _units Units of stake to cooldown for\n   **/\n  function _startCooldown(uint256 _units) internal {\n    require(balanceOf(_msgSender()) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n\n    _enterCooldownPeriod(_msgSender(), _units);\n\n    emit Cooldown(_msgSender(), _units);\n  }\n\n  /***************************************\n                    ADMIN\n    ****************************************/\n\n  /**\n   * @dev This is a write function allowing the whitelisted recollateralisation module to slash stakers here and take\n   * the capital to use to recollateralise any lost value in the system. Trusting that the recollateralisation module has\n   * sufficient protections put in place. Note, once this has been executed, the contract is now finished, and undercollateralised,\n   * meaning that all users must withdraw, and will only receive a proportionate amount back relative to the colRatio.\n   **/\n  function emergencyRecollateralisation()\n    external\n    onlyRecollateralisationModule\n    onlyBeforeRecollateralisation\n  {\n    // 1. Change collateralisation rate\n    safetyData.collateralisationRatio = 1e18 - safetyData.slashingPercentage;\n    // 2. Take slashing percentage\n    uint256 balance = STAKED_TOKEN.balanceOf(address(this));\n    STAKED_TOKEN.safeTransfer(\n      _recollateraliser(),\n      (balance * safetyData.slashingPercentage) / 1e18\n    );\n    // 3. No functions should work anymore because the colRatio has changed\n    emit Recollateralised();\n  }\n\n  /**\n   * @dev Governance can change the slashing percentage here (initially 0). This is the amount of a stakers capital that is at\n   * risk in the recollateralisation process.\n   * @param _newRate Rate, where 50% == 5e17\n   **/\n  function changeSlashingPercentage(uint256 _newRate)\n    external\n    onlyGovernor\n    onlyBeforeRecollateralisation\n  {\n    require(_newRate <= 5e17, \"Cannot exceed 50%\");\n\n    safetyData.slashingPercentage = SafeCast.toUint128(_newRate);\n\n    emit SlashRateChanged(_newRate);\n  }\n\n  /**\n   * @dev Allows governance to whitelist a smart contract to interact with the StakedToken (for example a yield aggregator or simply\n   * a Gnosis SAFE or other)\n   * @param _wrapper Address of the smart contract to list\n   **/\n  function whitelistWrapper(address _wrapper) external onlyGovernor {\n    whitelistedWrappers[_wrapper] = true;\n\n    emit WrapperWhitelisted(_wrapper);\n  }\n\n  /**\n   * @dev Allows governance to blacklist a smart contract to end it's interaction with the StakedToken\n   * @param _wrapper Address of the smart contract to blacklist\n   **/\n  function blackListWrapper(address _wrapper) external onlyGovernor {\n    whitelistedWrappers[_wrapper] = false;\n\n    emit WrapperBlacklisted(_wrapper);\n  }\n\n  /***************************************\n            BACKWARDS COMPATIBILITY\n    ****************************************/\n\n  /**\n   * @dev Allows for backwards compatibility with createLock fn, giving basic args to stake\n   * @param _value Units to stake\n   **/\n  function createLock(\n    uint256 _value,\n    uint256 /* _unlockTime */\n  ) external {\n    _transferAndStake(_value, address(0), false);\n  }\n\n  /**\n   * @dev Allows for backwards compatibility with increaseLockAmount fn by simply staking more\n   * @param _value Units to stake\n   **/\n  function increaseLockAmount(uint256 _value) external {\n    require(balanceOf(_msgSender()) != 0, \"Nothing to increase\");\n    _transferAndStake(_value, address(0), false);\n  }\n\n  /**\n   * @dev Backwards compatibility. Previously a lock would run out and a user would call this. Now, it will take 2 calls\n   * to exit in order to leave. The first will initiate the cooldown period, and the second will execute a full withdrawal.\n   **/\n  function exit() external virtual {\n    // Since there is no immediate exit here, this can be called twice\n    // If there is no cooldown, or the cooldown has passed the unstake window, enter cooldown\n    uint128 ts = _balances[_msgSender()].cooldownTimestamp;\n    if (ts == 0 || block.timestamp > ts + COOLDOWN_SECONDS + UNSTAKE_WINDOW) {\n      (uint256 raw, uint256 cooldownUnits) = rawBalanceOf(_msgSender());\n      _startCooldown(raw + cooldownUnits);\n    }\n    // Else withdraw all available\n    else {\n      _withdraw(\n        _balances[_msgSender()].cooldownUnits,\n        _msgSender(),\n        true,\n        false\n      );\n    }\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev fee = sqrt(300/x)-2.5, where x = weeks since user has staked\n   * @param _weightedTimestamp The users weightedTimestamp\n   * @return _feeRate where 1% == 1e16\n   */\n  function calcRedemptionFeeRate(uint32 _weightedTimestamp)\n    public\n    view\n    returns (uint256 _feeRate)\n  {\n    uint256 weeksStaked = ((block.timestamp - _weightedTimestamp) * 1e18) /\n      ONE_WEEK;\n    if (weeksStaked > 3e18) {\n      // e.g. weeks = 1  = sqrt(300e18) = 17320508075\n      // e.g. weeks = 10 = sqrt(30e18) =   5477225575\n      // e.g. weeks = 26 = sqrt(11.5) =    3391164991\n      _feeRate = Root.sqrt(300e36 / weeksStaked) * 1e7;\n      // e.g. weeks = 1  = 173e15 - 25e15 = 148e15 or 14.8%\n      // e.g. weeks = 10 =  55e15 - 25e15 = 30e15 or 3%\n      // e.g. weeks = 26 =  34e15 - 25e15 = 9e15 or 0.9%\n      _feeRate = _feeRate < 25e15 ? 0 : _feeRate - 25e15;\n    } else {\n      _feeRate = 75e15;\n    }\n  }\n\n  uint256[48] private __gap;\n}\n"
    },
    "contracts/ppo-staking/governance/staking/GamifiedVotingToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {MathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {GamifiedToken} from \"./GamifiedToken.sol\";\nimport {IGovernanceHook} from \"./interfaces/IGovernanceHook.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title GamifiedVotingToken\n * @notice GamifiedToken is a checkpointed Voting Token derived from OpenZeppelin \"ERC20VotesUpgradable\"\n * @author mStable\n * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9cdbd7d82d45a614ee98a5dc8c08fb4347d0fea/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\n * Changes:\n *   - Inherits custom GamifiedToken rather than basic ERC20\n *     - Removal of `Permit` functionality & `delegatebySig`\n *   - Override `delegates` fn as described in their docs\n *   - Prettier formatting\n *   - Addition of `totalSupply` method to get latest totalSupply\n *   - Move totalSupply checkpoints to `afterTokenTransfer`\n *   - Add _governanceHook hook\n */\nabstract contract GamifiedVotingToken is Initializable, GamifiedToken {\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint224 votes;\n  }\n\n  mapping(address => address) private _delegates;\n  mapping(address => Checkpoint[]) private _checkpoints;\n  Checkpoint[] private _totalSupplyCheckpoints;\n\n  IGovernanceHook private _governanceHook;\n\n  event GovernanceHookChanged(address indexed hook);\n\n  /**\n   * @dev Emitted when an account changes their delegate.\n   */\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n\n  /**\n   * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n   */\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _questManager,\n    bool _hasPriceCoeff\n  ) GamifiedToken(_nexus, _rewardsToken, _questManager, _hasPriceCoeff) {}\n\n  function __GamifiedVotingToken_init() internal initializer {}\n\n  /**\n   * @dev\n   */\n  function setGovernanceHook(address _newHook) external onlyGovernor {\n    _governanceHook = IGovernanceHook(_newHook);\n\n    emit GovernanceHookChanged(_newHook);\n  }\n\n  /**\n   * @dev Get the `pos`-th checkpoint for `account`.\n   */\n  function checkpoints(address account, uint32 pos)\n    public\n    view\n    virtual\n    returns (Checkpoint memory)\n  {\n    return _checkpoints[account][pos];\n  }\n\n  /**\n   * @dev Get number of checkpoints for `account`.\n   */\n  function numCheckpoints(address account)\n    public\n    view\n    virtual\n    returns (uint32)\n  {\n    return SafeCast.toUint32(_checkpoints[account].length);\n  }\n\n  /**\n   * @dev Get the address the `delegator` is currently delegating to.\n   * Return the `delegator` account if not delegating to anyone.\n   * @param delegator the account that is delegating the votes from\n   * @return delegatee that is receiving the delegated votes\n   */\n  function delegates(address delegator) public view virtual returns (address) {\n    // Override as per https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L23\n    // return _delegates[account];\n    address delegatee = _delegates[delegator];\n    return delegatee == address(0) ? delegator : delegatee;\n  }\n\n  /**\n   * @dev Gets the current votes balance for `account`\n   */\n  function getVotes(address account) public view returns (uint256) {\n    uint256 pos = _checkpoints[account].length;\n    return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n  }\n\n  /**\n   * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n   *\n   * Requirements:\n   *\n   * - `blockNumber` must have been already mined\n   */\n  function getPastVotes(address account, uint256 blockNumber)\n    public\n    view\n    returns (uint256)\n  {\n    require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n    return _checkpointsLookup(_checkpoints[account], blockNumber);\n  }\n\n  /**\n   * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n   * It is but NOT the sum of all the delegated votes!\n   *\n   * Requirements:\n   *\n   * - `blockNumber` must have been already mined\n   */\n  function getPastTotalSupply(uint256 blockNumber)\n    public\n    view\n    returns (uint256)\n  {\n    require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n    return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n  }\n\n  /**\n   * @dev Total sum of all scaled balances\n   */\n  function totalSupply() public view override returns (uint256) {\n    uint256 len = _totalSupplyCheckpoints.length;\n    if (len == 0) return 0;\n    return _totalSupplyCheckpoints[len - 1].votes;\n  }\n\n  /**\n   * @dev Lookup a value in a list of (sorted) checkpoints.\n   */\n  function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n  {\n    // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n    //\n    // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n    // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n    // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n    // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n    // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n    // out of bounds (in which case we're looking too far in the past and the result is 0).\n    // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n    // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n    // the same.\n    uint256 high = ckpts.length;\n    uint256 low = 0;\n    while (low < high) {\n      uint256 mid = MathUpgradeable.average(low, high);\n      if (ckpts[mid].fromBlock > blockNumber) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return high == 0 ? 0 : ckpts[high - 1].votes;\n  }\n\n  /**\n   * @dev Delegate votes from the sender to `delegatee`.\n   * If `delegatee` is zero, the sender gets the voting power.\n   * @param delegatee account that gets the voting power.\n   */\n  function delegate(address delegatee) public virtual {\n    return _delegate(_msgSender(), delegatee);\n  }\n\n  /**\n   * @dev Move voting power when tokens are transferred.\n   *\n   * Emits a {DelegateVotesChanged} event.\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._afterTokenTransfer(from, to, amount);\n\n    // mint or burn, update total supply\n    if (from == address(0) || to == address(0)) {\n      _writeCheckpoint(\n        _totalSupplyCheckpoints,\n        to == address(0) ? _subtract : _add,\n        amount\n      );\n    }\n\n    _moveVotingPower(delegates(from), delegates(to), amount);\n  }\n\n  /**\n   * @dev Change delegation for `delegator` to `delegatee`.\n   *\n   * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n   */\n  function _delegate(address delegator, address delegatee) internal virtual {\n    address currentDelegatee = delegates(delegator);\n    uint256 delegatorBalance = balanceOf(delegator);\n\n    _delegates[delegator] = delegatee;\n    delegatee = delegates(delegator);\n\n    emit DelegateChanged(delegator, currentDelegatee, delegatee);\n\n    _moveVotingPower(currentDelegatee, delegatee, delegatorBalance);\n  }\n\n  function _moveVotingPower(\n    address src,\n    address dst,\n    uint256 amount\n  ) private {\n    if (src != dst && amount > 0) {\n      if (src != address(0)) {\n        (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\n          _checkpoints[src],\n          _subtract,\n          amount\n        );\n        emit DelegateVotesChanged(src, oldWeight, newWeight);\n      }\n\n      if (dst != address(0)) {\n        (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\n          _checkpoints[dst],\n          _add,\n          amount\n        );\n        emit DelegateVotesChanged(dst, oldWeight, newWeight);\n      }\n\n      if (address(_governanceHook) != address(0)) {\n        _governanceHook.moveVotingPowerHook(src, dst, amount);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    Checkpoint[] storage ckpts,\n    function(uint256, uint256) view returns (uint256) op,\n    uint256 delta\n  ) private returns (uint256 oldWeight, uint256 newWeight) {\n    uint256 pos = ckpts.length;\n    oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n    newWeight = op(oldWeight, delta);\n\n    if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n      ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n    } else {\n      ckpts.push(\n        Checkpoint({\n          fromBlock: SafeCast.toUint32(block.number),\n          votes: SafeCast.toUint224(newWeight)\n        })\n      );\n    }\n  }\n\n  function _add(uint256 a, uint256 b) private pure returns (uint256) {\n    return a + b;\n  }\n\n  function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n    return a - b;\n  }\n\n  uint256[46] private __gap;\n}\n"
    },
    "contracts/ppo-staking/governance/staking/GamifiedToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {SafeCastExtended} from \"../../shared/SafeCastExtended.sol\";\nimport {ILockedERC20} from \"./interfaces/ILockedERC20.sol\";\nimport {HeadlessStakingRewards} from \"../../rewards/staking/HeadlessStakingRewards.sol\";\nimport {IQuestManager} from \"./interfaces/IQuestManager.sol\";\nimport \"./deps/GamifiedTokenStructs.sol\";\n\n/**\n * @title GamifiedToken\n * @notice GamifiedToken is a non-transferrable ERC20 token that has both a raw balance and a scaled balance.\n * Scaled balance is determined by quests a user completes, and the length of time they keep the raw balance wrapped.\n * QuestMasters can add new quests for stakers to complete, for which they are rewarded with permanent or seasonal multipliers.\n * @author mStable\n * @dev Originally forked from openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\n * Changes:\n *   - Removed the transfer, transferFrom, approve fns to make non-transferrable\n *   - Removed `_allowances` storage\n *   - Removed `_beforeTokenTransfer` hook\n *   - Replaced standard uint256 balance with a single struct containing all data from which the scaledBalance can be derived\n *   - Quest system implemented that tracks a users quest status and applies multipliers for them\n **/\nabstract contract GamifiedToken is\n  ILockedERC20,\n  Initializable,\n  ContextUpgradeable,\n  HeadlessStakingRewards\n{\n  /// @notice name of this token (ERC20)\n  bytes32 private _name;\n  /// @notice symbol of this token (ERC20)\n  bytes32 private _symbol;\n  /// @notice number of decimals of this token (ERC20)\n  uint8 public constant override decimals = 18;\n\n  /// @notice User balance structs containing all data needed to scale balance\n  mapping(address => Balance) internal _balances;\n  /// @notice Most recent price coefficients per user\n  mapping(address => uint256) internal _userPriceCoeff;\n  /// @notice Quest Manager\n  IQuestManager public immutable questManager;\n  /// @notice Has variable price\n  bool public immutable hasPriceCoeff;\n\n  /***************************************\n                    INIT\n    ****************************************/\n\n  /**\n   * @param _nexus System nexus\n   * @param _rewardsToken Token that is being distributed as a reward. eg MTA\n   * @param _questManager Centralised manager of quests\n   * @param _hasPriceCoeff true if raw staked amount is multiplied by price coeff to get staked amount. eg BPT Staked Token\n   */\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _questManager,\n    bool _hasPriceCoeff\n  ) HeadlessStakingRewards(_nexus, _rewardsToken) {\n    questManager = IQuestManager(_questManager);\n    hasPriceCoeff = _hasPriceCoeff;\n  }\n\n  /**\n   * @param _nameArg Token name\n   * @param _symbolArg Token symbol\n   * @param _rewardsDistributorArg mStable Rewards Distributor\n   */\n  function __GamifiedToken_init(\n    bytes32 _nameArg,\n    bytes32 _symbolArg,\n    address _rewardsDistributorArg\n  ) internal initializer {\n    __Context_init_unchained();\n    _name = _nameArg;\n    _symbol = _symbolArg;\n    HeadlessStakingRewards._initialize(_rewardsDistributorArg);\n  }\n\n  /**\n   * @dev Checks that _msgSender is the quest Manager\n   */\n  modifier onlyQuestManager() {\n    require(_msgSender() == address(questManager), \"Not verified\");\n    _;\n  }\n\n  /***************************************\n                    VIEWS\n    ****************************************/\n\n  function name() public view override returns (string memory) {\n    return bytes32ToString(_name);\n  }\n\n  function symbol() public view override returns (string memory) {\n    return bytes32ToString(_symbol);\n  }\n\n  /**\n   * @dev Total sum of all scaled balances\n   * In this instance, leave to the child token.\n   */\n  function totalSupply()\n    public\n    view\n    virtual\n    override(HeadlessStakingRewards, ILockedERC20)\n    returns (uint256);\n\n  /**\n   * @dev Simply gets scaled balance\n   * @return scaled balance for user\n   */\n  function balanceOf(address _account)\n    public\n    view\n    virtual\n    override(HeadlessStakingRewards, ILockedERC20)\n    returns (uint256)\n  {\n    return _getBalance(_account, _balances[_account]);\n  }\n\n  /**\n   * @dev Simply gets raw balance\n   * @return raw balance for user\n   */\n  function rawBalanceOf(address _account)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    return (_balances[_account].raw, _balances[_account].cooldownUnits);\n  }\n\n  /**\n   * @dev Scales the balance of a given user by applying multipliers\n   */\n  function _getBalance(address _account, Balance memory _balance)\n    internal\n    view\n    returns (uint256 balance)\n  {\n    // e.g. raw = 1000, questMultiplier = 40, timeMultiplier = 30. Cooldown of 60%\n    // e.g. 1000 * (100 + 40) / 100 = 1400\n    balance = (_balance.raw * (100 + _balance.questMultiplier)) / 100;\n    // e.g. 1400 * (100 + 30) / 100 = 1820\n    balance = (balance * (100 + _balance.timeMultiplier)) / 100;\n\n    if (hasPriceCoeff) {\n      // e.g. 1820 * 16000 / 10000 = 2912\n      balance = (balance * _userPriceCoeff[_account]) / 10000;\n    }\n  }\n\n  /**\n   * @notice Raw staked balance without any multipliers\n   */\n  function balanceData(address _account)\n    external\n    view\n    returns (Balance memory)\n  {\n    return _balances[_account];\n  }\n\n  /**\n   * @notice Raw staked balance without any multipliers\n   */\n  function userPriceCoeff(address _account) external view returns (uint256) {\n    return _userPriceCoeff[_account];\n  }\n\n  /***************************************\n                    QUESTS\n    ****************************************/\n\n  /**\n   * @dev Called by anyone to poke the timestamp of a given account. This allows users to\n   * effectively 'claim' any new timeMultiplier, but will revert if there is no change there.\n   */\n  function reviewTimestamp(address _account) external {\n    _reviewWeightedTimestamp(_account);\n  }\n\n  /**\n   * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\n   * to check time multipliers etc.\n   * @param _account Address of user that should be updated\n   * @param _newMultiplier New Quest Multiplier\n   */\n  function applyQuestMultiplier(address _account, uint8 _newMultiplier)\n    external\n    onlyQuestManager\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance & update questMultiplier, only if user has a balance\n    Balance memory oldBalance = _balances[_account];\n    uint256 oldScaledBalance = _getBalance(_account, oldBalance);\n    if (oldScaledBalance > 0) {\n      _applyQuestMultiplier(\n        _account,\n        oldBalance,\n        oldScaledBalance,\n        _newMultiplier\n      );\n    }\n  }\n\n  /**\n   * @dev Gets the multiplier awarded for a given weightedTimestamp\n   * @param _ts WeightedTimestamp of a user\n   * @return timeMultiplier Ranging from 20 (0.2x) to 60 (0.6x)\n   */\n  function _timeMultiplier(uint32 _ts)\n    internal\n    view\n    returns (uint8 timeMultiplier)\n  {\n    // If the user has no ts yet, they are not in the system\n    if (_ts == 0) return 0;\n\n    uint256 hodlLength = block.timestamp - _ts;\n    if (hodlLength < 13 weeks) {\n      // 0-3 months = 1x\n      return 0;\n    } else if (hodlLength < 26 weeks) {\n      // 3 months = 1.2x\n      return 20;\n    } else if (hodlLength < 52 weeks) {\n      // 6 months = 1.3x\n      return 30;\n    } else if (hodlLength < 78 weeks) {\n      // 12 months = 1.4x\n      return 40;\n    } else if (hodlLength < 104 weeks) {\n      // 18 months = 1.5x\n      return 50;\n    } else {\n      // > 24 months = 1.6x\n      return 60;\n    }\n  }\n\n  function _getPriceCoeff() internal virtual returns (uint256) {\n    return 10000;\n  }\n\n  /***************************************\n                BALANCE CHANGES\n    ****************************************/\n\n  /**\n   * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\n   * to check time multiplier.\n   * @param _account Address of user that should be updated\n   * @param _newMultiplier New Quest Multiplier\n   */\n  function _applyQuestMultiplier(\n    address _account,\n    Balance memory _oldBalance,\n    uint256 _oldScaledBalance,\n    uint8 _newMultiplier\n  ) private updateReward(_account) {\n    // 1. Set the questMultiplier\n    _balances[_account].questMultiplier = _newMultiplier;\n\n    // 2. Take the opportunity to set weighted timestamp, if it changes\n    _balances[_account].timeMultiplier = _timeMultiplier(\n      _oldBalance.weightedTimestamp\n    );\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, _oldScaledBalance);\n  }\n\n  /**\n   * @dev Entering a cooldown period means a user wishes to withdraw. With this in mind, their balance\n   * should be reduced until they have shown more commitment to the system\n   * @param _account Address of user that should be cooled\n   * @param _units Units to cooldown for\n   */\n  function _enterCooldownPeriod(address _account, uint256 _units)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint88 totalUnits = oldBalance.raw + oldBalance.cooldownUnits;\n    require(\n      _units > 0 && _units <= totalUnits,\n      \"Must choose between 0 and 100%\"\n    );\n\n    // 2. Set weighted timestamp and enter cooldown\n    _balances[_account].timeMultiplier = _timeMultiplier(\n      oldBalance.weightedTimestamp\n    );\n    // e.g. 1e18 / 1e16 = 100, 2e16 / 1e16 = 2, 1e15/1e16 = 0\n    _balances[_account].raw = totalUnits - SafeCastExtended.toUint88(_units);\n\n    // 3. Set cooldown data\n    _balances[_account].cooldownTimestamp = SafeCastExtended.toUint32(\n      block.timestamp\n    );\n    _balances[_account].cooldownUnits = SafeCastExtended.toUint88(_units);\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Exiting the cooldown period explicitly resets the users cooldown window and their balance\n   * @param _account Address of user that should be exited\n   */\n  function _exitCooldownPeriod(address _account)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n\n    // 2. Set weighted timestamp and exit cooldown\n    _balances[_account].timeMultiplier = _timeMultiplier(\n      oldBalance.weightedTimestamp\n    );\n    _balances[_account].raw += oldBalance.cooldownUnits;\n\n    // 3. Set cooldown data\n    _balances[_account].cooldownTimestamp = 0;\n    _balances[_account].cooldownUnits = 0;\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Pokes the weightedTimestamp of a given user and checks if it entitles them\n   * to a better timeMultiplier. If not, it simply reverts as there is nothing to update.\n   * @param _account Address of user that should be updated\n   */\n  function _reviewWeightedTimestamp(address _account)\n    internal\n    updateReward(_account)\n  {\n    require(_account != address(0), \"Invalid address\");\n\n    // 1. Get current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n\n    // 2. Set weighted timestamp, if it changes\n    uint8 newTimeMultiplier = _timeMultiplier(oldBalance.weightedTimestamp);\n    require(\n      newTimeMultiplier != oldBalance.timeMultiplier,\n      \"Nothing worth poking here\"\n    );\n    _balances[_account].timeMultiplier = newTimeMultiplier;\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Called to mint from raw tokens. Adds raw to a users balance, and then propagates the scaledBalance.\n   * Importantly, when a user stakes more, their weightedTimestamp is reduced proportionate to their stake.\n   * @param _account Address of user to credit\n   * @param _rawAmount Raw amount of tokens staked\n   * @param _exitCooldown Should we end any cooldown?\n   */\n  function _mintRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown\n  ) internal updateReward(_account) {\n    require(_account != address(0), \"ERC20: mint to the zero address\");\n\n    // 1. Get and update current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint88 totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\n    _balances[_account].raw =\n      oldBalance.raw +\n      SafeCastExtended.toUint88(_rawAmount);\n\n    // 2. Exit cooldown if necessary\n    if (_exitCooldown) {\n      _balances[_account].raw += oldBalance.cooldownUnits;\n      _balances[_account].cooldownTimestamp = 0;\n      _balances[_account].cooldownUnits = 0;\n    }\n\n    // 3. Set weighted timestamp\n    //  i) For new _account, set up weighted timestamp\n    if (oldBalance.weightedTimestamp == 0) {\n      _balances[_account].weightedTimestamp = SafeCastExtended.toUint32(\n        block.timestamp\n      );\n      _mintScaled(_account, _getBalance(_account, _balances[_account]));\n      return;\n    }\n    //  ii) For previous minters, recalculate time held\n    //      Calc new weighted timestamp\n    uint256 oldWeightedSecondsHeld = (block.timestamp -\n      oldBalance.weightedTimestamp) * totalRaw;\n    uint256 newSecondsHeld = oldWeightedSecondsHeld /\n      (totalRaw + (_rawAmount / 2));\n    uint32 newWeightedTs = SafeCastExtended.toUint32(\n      block.timestamp - newSecondsHeld\n    );\n    _balances[_account].weightedTimestamp = newWeightedTs;\n\n    uint8 timeMultiplier = _timeMultiplier(newWeightedTs);\n    _balances[_account].timeMultiplier = timeMultiplier;\n\n    // 3. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /**\n   * @dev Called to burn a given amount of raw tokens.\n   * @param _account Address of user\n   * @param _rawAmount Raw amount of tokens to remove\n   * @param _exitCooldown Exit the cooldown?\n   * @param _finalise Has recollateralisation happened? If so, everything is cooled down\n   */\n  function _burnRaw(\n    address _account,\n    uint256 _rawAmount,\n    bool _exitCooldown,\n    bool _finalise\n  ) internal updateReward(_account) {\n    require(_account != address(0), \"ERC20: burn from zero address\");\n\n    // 1. Get and update current balance\n    (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(\n      _account\n    );\n    uint256 totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\n    // 1.1. If _finalise, move everything to cooldown\n    if (_finalise) {\n      _balances[_account].raw = 0;\n      _balances[_account].cooldownUnits = SafeCastExtended.toUint88(totalRaw);\n      oldBalance.cooldownUnits = SafeCastExtended.toUint88(totalRaw);\n    }\n    // 1.2. Update\n    require(\n      oldBalance.cooldownUnits >= _rawAmount,\n      \"ERC20: burn amount > balance\"\n    );\n    unchecked {\n      _balances[_account].cooldownUnits -= SafeCastExtended.toUint88(\n        _rawAmount\n      );\n    }\n\n    // 2. If we are exiting cooldown, reset the balance\n    if (_exitCooldown) {\n      _balances[_account].raw += _balances[_account].cooldownUnits;\n      _balances[_account].cooldownTimestamp = 0;\n      _balances[_account].cooldownUnits = 0;\n    }\n\n    // 3. Set back scaled time\n    // e.g. stake 10 for 100 seconds, withdraw 5.\n    //      secondsHeld = (100 - 0) * (10 - 0.625) = 937.5\n    uint256 secondsHeld = (block.timestamp - oldBalance.weightedTimestamp) *\n      (totalRaw - (_rawAmount / 8));\n    //      newWeightedTs = 937.5 / 100 = 93.75\n    uint256 newSecondsHeld = secondsHeld / totalRaw;\n    uint32 newWeightedTs = SafeCastExtended.toUint32(\n      block.timestamp - newSecondsHeld\n    );\n    _balances[_account].weightedTimestamp = newWeightedTs;\n\n    uint8 timeMultiplier = _timeMultiplier(newWeightedTs);\n    _balances[_account].timeMultiplier = timeMultiplier;\n\n    // 4. Update scaled balance\n    _settleScaledBalance(_account, oldScaledBalance);\n  }\n\n  /***************************************\n                    PRIVATE\n    updateReward should already be called by now\n    ****************************************/\n\n  /**\n   * @dev Fetches the balance of a given user, scales it, and also takes the opportunity\n   * to check if the season has just finished between now and their last action.\n   * @param _account Address of user to fetch\n   * @return oldBalance struct containing all balance information\n   * @return oldScaledBalance scaled balance after applying multipliers\n   */\n  function _prepareOldBalance(address _account)\n    private\n    returns (Balance memory oldBalance, uint256 oldScaledBalance)\n  {\n    // Get the old balance\n    oldBalance = _balances[_account];\n    oldScaledBalance = _getBalance(_account, oldBalance);\n    // Take the opportunity to check for season finish\n    _balances[_account].questMultiplier = questManager.checkForSeasonFinish(\n      _account\n    );\n    if (hasPriceCoeff) {\n      _userPriceCoeff[_account] = SafeCastExtended.toUint16(_getPriceCoeff());\n    }\n  }\n\n  /**\n   * @dev Settles the scaled balance of a given account. The reason this is done here, is because\n   * in each of the write functions above, there is the chance that a users balance can go down,\n   * requiring to burn sacled tokens. This could happen at the end of a season when multipliers are slashed.\n   * This is called after updating all multipliers etc.\n   * @param _account Address of user that should be updated\n   * @param _oldScaledBalance Previous scaled balance of the user\n   */\n  function _settleScaledBalance(address _account, uint256 _oldScaledBalance)\n    private\n  {\n    uint256 newScaledBalance = _getBalance(_account, _balances[_account]);\n    if (newScaledBalance > _oldScaledBalance) {\n      _mintScaled(_account, newScaledBalance - _oldScaledBalance);\n    }\n    // This can happen if the user moves back a time class, but is unlikely to result in a negative mint\n    else {\n      _burnScaled(_account, _oldScaledBalance - newScaledBalance);\n    }\n  }\n\n  /**\n   * @dev Propagates the minting of the tokens downwards.\n   * @param _account Address of user that has minted\n   * @param _amount Amount of scaled tokens minted\n   */\n  function _mintScaled(address _account, uint256 _amount) private {\n    emit Transfer(address(0), _account, _amount);\n\n    _afterTokenTransfer(address(0), _account, _amount);\n  }\n\n  /**\n   * @dev Propagates the burning of the tokens downwards.\n   * @param _account Address of user that has burned\n   * @param _amount Amount of scaled tokens burned\n   */\n  function _burnScaled(address _account, uint256 _amount) private {\n    emit Transfer(_account, address(0), _amount);\n\n    _afterTokenTransfer(_account, address(0), _amount);\n  }\n\n  /***************************************\n                    HOOKS\n    ****************************************/\n\n  /**\n   * @dev Triggered after a user claims rewards from the HeadlessStakingRewards. Used\n   * to check for season finish. If it has not, then do not spend gas updating the other vars.\n   * @param _account Address of user that has burned\n   */\n  function _claimRewardHook(address _account) internal override {\n    uint8 newMultiplier = questManager.checkForSeasonFinish(_account);\n    bool priceCoeffChanged = hasPriceCoeff\n      ? _getPriceCoeff() != _userPriceCoeff[_account]\n      : false;\n    if (\n      newMultiplier != _balances[_account].questMultiplier || priceCoeffChanged\n    ) {\n      // 1. Get current balance & trigger season finish\n      uint256 oldScaledBalance = _getBalance(_account, _balances[_account]);\n      _balances[_account].questMultiplier = newMultiplier;\n      if (priceCoeffChanged) {\n        _userPriceCoeff[_account] = SafeCastExtended.toUint16(\n          _getPriceCoeff()\n        );\n      }\n      // 3. Update scaled balance\n      _settleScaledBalance(_account, oldScaledBalance);\n    }\n  }\n\n  /**\n   * @dev Unchanged from OpenZeppelin. Used in child contracts to react to any balance changes.\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal virtual {}\n\n  /***************************************\n                    Utils\n    ****************************************/\n\n  function bytes32ToString(bytes32 _bytes32)\n    internal\n    pure\n    returns (string memory)\n  {\n    uint256 i = 0;\n    while (i < 32 && _bytes32[i] != 0) {\n      i++;\n    }\n    bytes memory bytesArray = new bytes(i);\n    for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n      bytesArray[i] = _bytes32[i];\n    }\n    return string(bytesArray);\n  }\n\n  uint256[46] private __gap;\n}\n"
    },
    "contracts/ppo-staking/governance/staking/interfaces/IQuestManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"../deps/GamifiedTokenStructs.sol\";\n\ninterface IQuestManager {\n  event QuestAdded(\n    address questMaster,\n    uint256 id,\n    QuestType model,\n    uint16 multiplier,\n    QuestStatus status,\n    uint32 expiry\n  );\n  event QuestCompleteQuests(address indexed user, uint256[] ids);\n  event QuestCompleteUsers(uint256 indexed questId, address[] accounts);\n  event QuestExpired(uint16 indexed id);\n  event QuestMaster(address oldQuestMaster, address newQuestMaster);\n  event QuestSeasonEnded();\n  event QuestSigner(address oldQuestSigner, address newQuestSigner);\n  event StakedTokenAdded(address stakedToken);\n\n  // GETTERS\n  function balanceData(address _account)\n    external\n    view\n    returns (QuestBalance memory);\n\n  function getQuest(uint256 _id) external view returns (Quest memory);\n\n  function hasCompleted(address _account, uint256 _id)\n    external\n    view\n    returns (bool);\n\n  function questMaster() external view returns (address);\n\n  function seasonEpoch() external view returns (uint32);\n\n  // ADMIN\n  function addQuest(\n    QuestType _model,\n    uint8 _multiplier,\n    uint32 _expiry\n  ) external;\n\n  function addStakedToken(address _stakedToken) external;\n\n  function expireQuest(uint16 _id) external;\n\n  function setQuestMaster(address _newQuestMaster) external;\n\n  function setQuestSigner(address _newQuestSigner) external;\n\n  function startNewQuestSeason() external;\n\n  // USER\n  function completeUserQuests(\n    address _account,\n    uint256[] memory _ids,\n    bytes calldata _signature\n  ) external;\n\n  function completeQuestUsers(\n    uint256 _questId,\n    address[] memory _accounts,\n    bytes calldata _signature\n  ) external;\n\n  function checkForSeasonFinish(address _account)\n    external\n    returns (uint8 newQuestMultiplier);\n}\n"
    },
    "contracts/ppo-staking/z_mocks/governance/stakedTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {StakedToken} from \"../../governance/staking/StakedToken.sol\";\n\n/**\n * Used to test contract interactions with the StakedToken\n */\ncontract StakedTokenWrapper {\n  using SafeERC20 for IERC20;\n\n  IERC20 public rewardsToken;\n  StakedToken public stakedToken;\n\n  constructor(address _rewardsToken, address _stakedToken) {\n    stakedToken = StakedToken(_stakedToken);\n    rewardsToken = IERC20(_rewardsToken);\n    rewardsToken.safeApprove(_stakedToken, 2**256 - 1);\n  }\n\n  function stake(uint256 _amount) external {\n    stakedToken.stake(_amount);\n  }\n\n  function stake(uint256 _amount, address _delegatee) external {\n    stakedToken.stake(_amount, _delegatee);\n  }\n\n  function withdraw(\n    uint256 _amount,\n    address _recipient,\n    bool _amountIncludesFee,\n    bool _exitCooldown\n  ) external {\n    stakedToken.withdraw(\n      _amount,\n      _recipient,\n      _amountIncludesFee,\n      _exitCooldown\n    );\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/governance/MockStakedTokenWithPrice.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\npragma abicoder v2;\n\nimport {StakedToken} from \"../../governance/staking/StakedToken.sol\";\n\n/**\n * @title StakedTokenBPT\n * @dev Derives from StakedToken, and simply adds the ability to withdraw any unclaimed $BAL tokens\n * that are at this address\n **/\ncontract MockStakedTokenWithPrice is StakedToken {\n  /// @notice Most recent PriceCoefficient\n  uint256 public priceCoefficient;\n\n  event PriceCoefficientUpdated(uint16 newPriceCoeff);\n\n  constructor(\n    address _nexus,\n    address _rewardsToken,\n    address _questManager,\n    address _stakedToken,\n    uint256 _cooldownSeconds,\n    uint256 _unstakeWindow\n  )\n    StakedToken(\n      _nexus,\n      _rewardsToken,\n      _questManager,\n      _stakedToken,\n      _cooldownSeconds,\n      _unstakeWindow,\n      true\n    )\n  {}\n\n  function initialize(\n    bytes32 _nameArg,\n    bytes32 _symbolArg,\n    address _rewardsDistributorArg\n  ) external initializer {\n    __StakedToken_init(_nameArg, _symbolArg, _rewardsDistributorArg);\n    priceCoefficient = 10000;\n  }\n\n  /**\n   * @dev Sets the recipient for any potential $BAL earnings\n   */\n  function setPriceCoefficient(uint16 _newCoeff) external {\n    priceCoefficient = _newCoeff;\n\n    emit PriceCoefficientUpdated(_newCoeff);\n  }\n\n  /**\n   * @dev Get the current priceCoeff\n   */\n  function _getPriceCoeff() internal view override returns (uint256) {\n    return priceCoefficient;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/QuestManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {SignatureVerifier} from \"./deps/SignatureVerifier.sol\";\nimport {ImmutableModule} from \"../../shared/ImmutableModule.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IQuestManager} from \"./interfaces/IQuestManager.sol\";\nimport {IStakedToken} from \"./interfaces/IStakedToken.sol\";\nimport \"./deps/GamifiedTokenStructs.sol\";\n\n/**\n * @title   QuestManager\n * @author  mStable\n * @notice  Centralised place to track quest management and completion status\n * @dev     VERSION: 1.0\n *          DATE:    2021-08-25\n */\ncontract QuestManager is\n  IQuestManager,\n  Initializable,\n  ContextUpgradeable,\n  ImmutableModule\n{\n  /// @notice Tracks the completion of each quest (user => questId => completion)\n  mapping(address => mapping(uint256 => bool)) private _questCompletion;\n\n  /// @notice User balance structs containing all data needed to scale balance\n  mapping(address => QuestBalance) internal _balances;\n\n  /// @notice List of quests, whose ID corresponds to their position in the array (from 0)\n  Quest[] private _quests;\n  /// @notice Timestamp at which the current season started\n  uint32 public override seasonEpoch;\n  /// @notice Timestamp at which the contract was created\n  uint32 public startTime;\n\n  /// @notice A whitelisted questMaster who can administer quests including signing user quests are completed.\n  address public override questMaster;\n  /// @notice account that can sign a user's quest as being completed.\n  address internal _questSigner;\n\n  /// @notice List of all staking tokens\n  address[] internal _stakedTokens;\n\n  /**\n   * @param _nexus System nexus\n   */\n  constructor(address _nexus) ImmutableModule(_nexus) {}\n\n  /**\n   * @param _questMaster account that can sign user quests as completed\n   * @param _questSignerArg account that can sign user quests as completed\n   */\n  function initialize(address _questMaster, address _questSignerArg)\n    external\n    initializer\n  {\n    startTime = SafeCast.toUint32(block.timestamp);\n    questMaster = _questMaster;\n    _questSigner = _questSignerArg;\n  }\n\n  /**\n   * @dev Checks that _msgSender is either governor or the quest master\n   */\n  modifier questMasterOrGovernor() {\n    _questMasterOrGovernor();\n    _;\n  }\n\n  function _questMasterOrGovernor() internal view {\n    require(\n      _msgSender() == questMaster || _msgSender() == _governor(),\n      \"Not verified\"\n    );\n  }\n\n  /***************************************\n                    Getters\n    ****************************************/\n\n  /**\n   * @notice Gets raw quest data\n   */\n  function getQuest(uint256 _id)\n    external\n    view\n    override\n    returns (Quest memory)\n  {\n    return _quests[_id];\n  }\n\n  /**\n   * @dev Simply checks if a given user has already completed a given quest\n   * @param _account User address\n   * @param _id Position of quest in array\n   * @return bool with completion status\n   */\n  function hasCompleted(address _account, uint256 _id)\n    public\n    view\n    override\n    returns (bool)\n  {\n    return _questCompletion[_account][_id];\n  }\n\n  /**\n   * @notice Raw quest balance\n   */\n  function balanceData(address _account)\n    external\n    view\n    override\n    returns (QuestBalance memory)\n  {\n    return _balances[_account];\n  }\n\n  /***************************************\n                    Admin\n    ****************************************/\n\n  /**\n   * @dev Sets the quest master that can administoer quests. eg add, expire and start seasons.\n   */\n  function setQuestMaster(address _newQuestMaster)\n    external\n    override\n    questMasterOrGovernor\n  {\n    emit QuestMaster(questMaster, _newQuestMaster);\n\n    questMaster = _newQuestMaster;\n  }\n\n  /**\n   * @dev Sets the quest signer that can sign user quests as being completed.\n   */\n  function setQuestSigner(address _newQuestSigner)\n    external\n    override\n    onlyGovernor\n  {\n    emit QuestSigner(_questSigner, _newQuestSigner);\n\n    _questSigner = _newQuestSigner;\n  }\n\n  /**\n   * @dev Adds a new stakedToken\n   */\n  function addStakedToken(address _stakedToken)\n    external\n    override\n    onlyGovernor\n  {\n    require(_stakedToken != address(0), \"Invalid StakedToken\");\n\n    _stakedTokens.push(_stakedToken);\n\n    emit StakedTokenAdded(_stakedToken);\n  }\n\n  /***************************************\n                    QUESTS\n    ****************************************/\n\n  /**\n   * @dev Called by questMasters to add a new quest to the system with default 'ACTIVE' status\n   * @param _model Type of quest rewards multiplier (does it last forever or just for the season).\n   * @param _multiplier Multiplier, from 1 == 1.01x to 100 == 2.00x\n   * @param _expiry Timestamp at which quest expires. Note that permanent quests should still be given a timestamp.\n   */\n  function addQuest(\n    QuestType _model,\n    uint8 _multiplier,\n    uint32 _expiry\n  ) external override questMasterOrGovernor {\n    require(_expiry > block.timestamp + 1 days, \"Quest window too small\");\n    require(\n      _multiplier > 0 && _multiplier <= 50,\n      \"Quest multiplier too large > 1.5x\"\n    );\n\n    _quests.push(\n      Quest({\n        model: _model,\n        multiplier: _multiplier,\n        status: QuestStatus.ACTIVE,\n        expiry: _expiry\n      })\n    );\n\n    emit QuestAdded(\n      msg.sender,\n      _quests.length - 1,\n      _model,\n      _multiplier,\n      QuestStatus.ACTIVE,\n      _expiry\n    );\n  }\n\n  /**\n   * @dev Called by questMasters to expire a quest, setting it's status as EXPIRED. After which it can\n   * no longer be completed.\n   * @param _id Quest ID (its position in the array)\n   */\n  function expireQuest(uint16 _id) external override questMasterOrGovernor {\n    require(_id < _quests.length, \"Quest does not exist\");\n    require(\n      _quests[_id].status == QuestStatus.ACTIVE,\n      \"Quest already expired\"\n    );\n\n    _quests[_id].status = QuestStatus.EXPIRED;\n    if (block.timestamp < _quests[_id].expiry) {\n      _quests[_id].expiry = SafeCast.toUint32(block.timestamp);\n    }\n\n    emit QuestExpired(_id);\n  }\n\n  /**\n   * @dev Called by questMasters to start a new quest season. After this, all current\n   * seasonMultipliers will be reduced at the next user action (or triggered manually).\n   * In order to reduce cost for any keepers, it is suggested to add quests at the start\n   * of a new season to incentivise user actions.\n   * A new season can only begin after 9 months has passed.\n   */\n  function startNewQuestSeason() external override questMasterOrGovernor {\n    require(\n      block.timestamp > (startTime + 39 weeks),\n      \"First season has not elapsed\"\n    );\n    require(\n      block.timestamp > (seasonEpoch + 39 weeks),\n      \"Season has not elapsed\"\n    );\n\n    uint256 len = _quests.length;\n    for (uint256 i = 0; i < len; i++) {\n      Quest memory quest = _quests[i];\n      if (quest.model == QuestType.SEASONAL) {\n        require(\n          quest.status == QuestStatus.EXPIRED ||\n            block.timestamp > quest.expiry,\n          \"All seasonal quests must have expired\"\n        );\n      }\n    }\n\n    seasonEpoch = SafeCast.toUint32(block.timestamp);\n\n    emit QuestSeasonEnded();\n  }\n\n  /***************************************\n                    USER\n    ****************************************/\n\n  /**\n   * @dev Called by anyone to complete one or more quests for a staker. The user must first collect a signed message\n   * from the whitelisted _signer.\n   * @param _account Account that has completed the quest\n   * @param _ids Quest IDs (its position in the array)\n   * @param _signature Signature from the verified _questSigner, containing keccak hash of account & ids\n   */\n  function completeUserQuests(\n    address _account,\n    uint256[] memory _ids,\n    bytes calldata _signature\n  ) external override {\n    uint256 len = _ids.length;\n    require(len > 0, \"No quest IDs\");\n\n    uint8 questMultiplier = checkForSeasonFinish(_account);\n\n    // For each quest\n    for (uint256 i = 0; i < len; i++) {\n      require(_validQuest(_ids[i]), \"Invalid Quest ID\");\n      require(!hasCompleted(_account, _ids[i]), \"Quest already completed\");\n      require(\n        SignatureVerifier.verify(_questSigner, _account, _ids, _signature),\n        \"Invalid Quest Signer Signature\"\n      );\n\n      // Store user quest has completed\n      _questCompletion[_account][_ids[i]] = true;\n\n      // Update multiplier\n      Quest memory quest = _quests[_ids[i]];\n      if (quest.model == QuestType.PERMANENT) {\n        _balances[_account].permMultiplier += quest.multiplier;\n      } else {\n        _balances[_account].seasonMultiplier += quest.multiplier;\n      }\n      questMultiplier += quest.multiplier;\n    }\n\n    uint256 len2 = _stakedTokens.length;\n    for (uint256 i = 0; i < len2; i++) {\n      IStakedToken(_stakedTokens[i]).applyQuestMultiplier(\n        _account,\n        questMultiplier\n      );\n    }\n\n    emit QuestCompleteQuests(_account, _ids);\n  }\n\n  /**\n   * @dev Called by anyone to complete one or more accounts for a quest. The user must first collect a signed message\n   * from the whitelisted _questMaster.\n   * @param _questId Quest ID (its position in the array)\n   * @param _accounts Accounts that has completed the quest\n   * @param _signature Signature from the verified _questMaster, containing keccak hash of id and accounts\n   */\n  function completeQuestUsers(\n    uint256 _questId,\n    address[] memory _accounts,\n    bytes calldata _signature\n  ) external override {\n    require(_validQuest(_questId), \"Invalid Quest ID\");\n    uint256 len = _accounts.length;\n    require(len > 0, \"No accounts\");\n    require(\n      SignatureVerifier.verify(_questSigner, _questId, _accounts, _signature),\n      \"Invalid Quest Signer Signature\"\n    );\n\n    Quest memory quest = _quests[_questId];\n\n    // For each user account\n    for (uint256 i = 0; i < len; i++) {\n      require(\n        !hasCompleted(_accounts[i], _questId),\n        \"Quest already completed\"\n      );\n\n      // store user quest has completed\n      _questCompletion[_accounts[i]][_questId] = true;\n\n      // _applyQuestMultiplier(_accounts[i], quests);\n      uint8 questMultiplier = checkForSeasonFinish(_accounts[i]);\n\n      // Update multiplier\n      if (quest.model == QuestType.PERMANENT) {\n        _balances[_accounts[i]].permMultiplier += quest.multiplier;\n      } else {\n        _balances[_accounts[i]].seasonMultiplier += quest.multiplier;\n      }\n      questMultiplier += quest.multiplier;\n\n      uint256 len2 = _stakedTokens.length;\n      for (uint256 j = 0; j < len2; j++) {\n        IStakedToken(_stakedTokens[j]).applyQuestMultiplier(\n          _accounts[i],\n          questMultiplier\n        );\n      }\n    }\n\n    emit QuestCompleteUsers(_questId, _accounts);\n  }\n\n  /**\n   * @dev Simply checks if a quest is valid. Quests are valid if their id exists,\n   * they have an ACTIVE status and they have not yet reached their expiry timestamp.\n   * @param _id Position of quest in array\n   * @return bool with validity status\n   */\n  function _validQuest(uint256 _id) internal view returns (bool) {\n    return\n      _id < _quests.length &&\n      _quests[_id].status == QuestStatus.ACTIVE &&\n      block.timestamp < _quests[_id].expiry;\n  }\n\n  /**\n   * @dev Checks if the season has just finished between now and the users last action.\n   * If it has, we reset the seasonMultiplier. Either way, we update the lastAction for the user.\n   * NOTE - it is important that this is called as a hook before each state change operation\n   * @param _account Address of user that should be updated\n   */\n  function checkForSeasonFinish(address _account)\n    public\n    override\n    returns (uint8 newQuestMultiplier)\n  {\n    QuestBalance storage balance = _balances[_account];\n    // If the last action was before current season, then reset the season timing\n    if (_hasFinishedSeason(balance.lastAction)) {\n      // Remove 85% of the multiplier gained in this season\n      balance.seasonMultiplier = (balance.seasonMultiplier * 15) / 100;\n      balance.lastAction = SafeCast.toUint32(block.timestamp);\n    }\n    return balance.seasonMultiplier + balance.permMultiplier;\n  }\n\n  /**\n   * @dev Simple view fn to check if the users last action was before the starting of the current season\n   */\n  function _hasFinishedSeason(uint32 _lastAction)\n    internal\n    view\n    returns (bool)\n  {\n    return _lastAction < seasonEpoch;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/deps/SignatureVerifier.sol": {
      "content": "// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\n// Copyright (C) 2021 zapper\n// Copyright (c) 2018 Tasuku Nakamura\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n\n///@author Zapper\n///@notice This contract checks if a message has been signed by a verified signer via personal_sign.\n// SPDX-License-Identifier: GPLv2\n\npragma solidity ^0.8.0;\n\nlibrary SignatureVerifier {\n  function verify(\n    address signer,\n    address account,\n    uint256[] calldata ids,\n    bytes calldata signature\n  ) external pure returns (bool) {\n    bytes32 messageHash = getMessageHash(account, ids);\n    bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n    return recoverSigner(ethSignedMessageHash, signature) == signer;\n  }\n\n  function verify(\n    address signer,\n    uint256 id,\n    address[] calldata accounts,\n    bytes calldata signature\n  ) external pure returns (bool) {\n    bytes32 messageHash = getMessageHash(id, accounts);\n    bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n    return recoverSigner(ethSignedMessageHash, signature) == signer;\n  }\n\n  function getMessageHash(address account, uint256[] memory ids)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(account, ids));\n  }\n\n  function getMessageHash(uint256 id, address[] memory accounts)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(id, accounts));\n  }\n\n  function getEthSignedMessageHash(bytes32 messageHash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return\n      keccak256(\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n      );\n  }\n\n  function recoverSigner(\n    bytes32 _ethSignedMessageHash,\n    bytes memory _signature\n  ) internal pure returns (address) {\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n    return ecrecover(_ethSignedMessageHash, v, r, s);\n  }\n\n  function splitSignature(bytes memory signature)\n    internal\n    pure\n    returns (\n      bytes32 r,\n      bytes32 s,\n      uint8 v\n    )\n  {\n    require(signature.length == 65, \"invalid signature length\");\n\n    //solium-disable-next-line\n    assembly {\n      r := mload(add(signature, 32))\n      s := mload(add(signature, 64))\n      v := byte(0, mload(add(signature, 96)))\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/governance/MockEmissionController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IGovernanceHook} from \"../../governance/staking/interfaces/IGovernanceHook.sol\";\nimport {GamifiedVotingToken} from \"../../governance/staking/GamifiedVotingToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockEmissionController is IGovernanceHook {\n  struct Dial {\n    uint256 votes;\n  }\n\n  Dial[] public dials;\n\n  struct PreferenceData {\n    uint256 sum;\n    uint256 count;\n    Preference[] prefs;\n  }\n\n  struct Preference {\n    uint256 id;\n    uint256 weight;\n  }\n  // user => preferences\n  // uint256 is 256 slots to store dial information. We can store the array positions of a users preferences in a single slot\n  mapping(address => uint256) public preferenceBitmaps;\n  bool init;\n\n  mapping(address => bool) public stakingContracts;\n  address[] public stakingContractsArr;\n\n  modifier onlyStakingContract() {\n    require(\n      stakingContracts[msg.sender],\n      \"Must be whitelisted staking contract\"\n    );\n    _;\n  }\n\n  constructor() {\n    dials.push(Dial(1));\n    dials.push(Dial(1));\n    dials.push(Dial(1));\n    dials.push(Dial(1));\n  }\n\n  function addStakingContract(address _stakingContract) external {\n    require(!stakingContracts[_stakingContract], \"Already whitelisted\");\n    require(\n      IERC20(_stakingContract).totalSupply() == 0 || !init,\n      \"Cannot add existing contract while users have preferences\"\n    );\n    stakingContractsArr.push(_stakingContract);\n    stakingContracts[_stakingContract] = true;\n  }\n\n  function moveVotingPowerHook(\n    address from,\n    address to,\n    uint256 amount\n  ) external override onlyStakingContract {\n    if (amount > 0) {\n      if (from != address(0)) {\n        _moveVotingPower(_getPreferences(from), amount, _subtract);\n      }\n      if (to != address(0)) {\n        _moveVotingPower(_getPreferences(to), amount, _add);\n      }\n    }\n  }\n\n  // SITUATION 1: Stake, wait, set preferences\n  // SITUATION 2: Set preferences, stake\n  // SITUATION 3: NEW STAKING TOKEN. NOTE - this new staking token MUST be added to this contract\n  // before any users have a balance. Otherwise, they can get a balance, and have existing preferences,\n  // and it will never be added here. Require totalSupply of staking\n\n  function setPreferences(uint256 _bitmap) external {\n    if (!init) init = true;\n    // 1. Get voting power sum from stakingContracts\n    uint256 len = stakingContractsArr.length;\n    uint256 votingPower = 0;\n    for (uint256 i = 0; i < len; i++) {\n      votingPower += GamifiedVotingToken(stakingContractsArr[i]).getVotes(\n        msg.sender\n      );\n    }\n    // 2. Fetch old bitmap and reduce all based on old preference\n    _moveVotingPower(_getPreferences(msg.sender), votingPower, _subtract);\n    // 3. Set new preferences\n    preferenceBitmaps[msg.sender] = _bitmap;\n    PreferenceData memory data = _getPreferences(msg.sender);\n    require(data.count < 4, \"Max 4 preferences to reduce gas\");\n    _moveVotingPower(data, votingPower, _add);\n  }\n\n  function _moveVotingPower(\n    PreferenceData memory _preferenceData,\n    uint256 _amount,\n    function(uint256, uint256) view returns (uint256) _op\n  ) internal {\n    uint256 len = _preferenceData.count;\n    for (uint256 i = 0; i < len; i++) {\n      Preference memory pref = _preferenceData.prefs[i];\n      // e.g. 5e17 * 1e18 / 1e18 * 100e18 / 1e18\n      // = 50e18\n      uint256 amountToChange = (((pref.weight * 1e18) / _preferenceData.sum) *\n        _amount) / 1e18;\n      dials[pref.id].votes = _op(dials[pref.id].votes, amountToChange);\n    }\n  }\n\n  function _add(uint256 a, uint256 b) private pure returns (uint256) {\n    return a + b;\n  }\n\n  function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n    return a - b;\n  }\n\n  function _getPreferences(address _account)\n    internal\n    view\n    returns (PreferenceData memory preferences)\n  {\n    uint256 bitmap = preferenceBitmaps[_account];\n    uint8 weighting;\n    preferences.prefs = new Preference[](4);\n    for (uint8 i = 0; i < 32; i++) {\n      unchecked {\n        weighting = uint8(bitmap >> (i * 8));\n      }\n      if (weighting > 0) {\n        preferences.prefs[preferences.count] = Preference(i, weighting);\n        preferences.sum += weighting;\n        preferences.count++;\n      }\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/savings/MockStakingContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport {IGovernanceHook} from \"../../governance/staking/interfaces/IGovernanceHook.sol\";\n\npragma solidity =0.8.7;\n\ncontract MockStakingContract {\n  mapping(address => uint256) private _balances;\n  mapping(address => uint256) private _votes;\n  uint256 public totalSupply;\n\n  IGovernanceHook govHook;\n\n  function setBalanceOf(address account, uint256 balance) public {\n    _balances[account] = balance;\n  }\n\n  function setTotalSupply(uint256 _totalSupply) public {\n    totalSupply = _totalSupply;\n  }\n\n  function setVotes(address account, uint256 newVotes) public {\n    uint256 oldVotes = _votes[account];\n    _votes[account] = newVotes;\n\n    if (address(govHook) != address(0)) {\n      if (oldVotes <= newVotes) {\n        govHook.moveVotingPowerHook(address(0), account, newVotes - oldVotes);\n      } else if (oldVotes > newVotes) {\n        govHook.moveVotingPowerHook(account, address(0), oldVotes - newVotes);\n      }\n    }\n  }\n\n  function transferVotes(\n    address from,\n    address to,\n    uint256 votes\n  ) public {\n    _votes[from] -= votes;\n    _votes[to] += votes;\n\n    if (address(govHook) != address(0)) {\n      govHook.moveVotingPowerHook(from, to, votes);\n    }\n  }\n\n  function setGovernanceHook(address _govHook) public {\n    govHook = IGovernanceHook(_govHook);\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  function getVotes(address account) external view returns (uint256) {\n    return _votes[account];\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/ppo/interfaces/IPPO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./ITransferHook.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\n\ninterface IPPO is IERC20Upgradeable, IERC20PermitUpgradeable {\n  /**\n   * @notice Sets the external `ITransferHook` contract to be called before\n   * any PPO transfer.\n   * @dev The transfer hook's `hook()` function will be called within\n   * `_beforeTokenTransfer()`.\n   *\n   * Only callable by `owner()`.\n   * @param newTransferHook Address of the `ITransferHook` contract\n   */\n  function setTransferHook(ITransferHook newTransferHook) external;\n\n  /**\n   * @notice Mints `amount` PPO to `recipient`.\n   * @dev Only callable by `owner()`.\n   * @param recipient Address to send minted `PPO` to\n   * @param amount Amount of `PPO` to be sent\n   */\n  function mint(address recipient, uint256 amount) external;\n\n  /**\n   * @notice Burns `amount` tokens from the caller.\n   * @param amount Amount of `PPO` to be burned\n   */\n  function burn(uint256 amount) external;\n\n  /**\n   * @notice Burns `amount` tokens from `account`.\n   * @dev The caller's allowance with the `account` must be >= `amount` and\n   * will be decreased by `amount`.\n   * @param account Address to burn `PPO` from\n   * @param amount Amount of `PPO` to be burned\n   */\n  function burnFrom(address account, uint256 amount) external;\n\n  /**\n   * @notice Atomically allows and transfers `amount` from `from` to\n   * `to`, if before the `deadline`, using a signature signed by `from`.\n   * @dev `from`, `to` and `deadline` must exactly match the values used\n   * to generate `v`, `r` and `s`.\n   * @param from Address to transfer `PPO` from\n   * @param to Address to transfer `PPO` to\n   * @param amount Amount of PPO to be transferred\n   * @param deadline Future timestamp, specified in the permit signature\n   * before which the transaction must execute\n   * @param v recovery identifier of the signature\n   * @param r part of ECDSA signature output\n   * @param s part of ECDSA signature output\n   */\n  function transferFromWithPermit(\n    address from,\n    address to,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /// @return The transfer hook contract\n  function getTransferHook() external view returns (ITransferHook);\n}\n"
    },
    "contracts/ppo/interfaces/ITransferHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\n///@notice External hook to be called before or after an ERC20 token transfer.\ninterface ITransferHook {\n  /**\n   * @notice A generic hook function, to be called before or after a token\n   * transfer.\n   * @dev This function should reside in an ERC20's `_beforeTokenTransfer()`\n   * or `_afterTokenTransfer()` internal functions.\n   * @param from Address tokens are coming from\n   * @param to Address tokens are going to\n   * @param amount Token amount being transferred\n   */\n  function hook(\n    address from,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "contracts/ppo/PPO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\n/**\n                            .,;111;,.                                                                                                                                   \n                        .:;1tffffffft1;:.                                                                                                                               \n                    .:i1tfffffftttfffffft1i:,                                                                                                                           \n               .,:i1tfffffft1i:,.,:i1tfffffftti;,.                                                                                                                      \n           .,;ittfffffft1;:.         .:;1ttffffftt1;,.                                                                                                                  \n       .:;1ttfftfftt1;,.                 .,;i1tffffftt1i:                                                                                                               \n   ,:i1tttttttt1i:,.                          ,:i1ttfft;,    ..                                                                                                         \n,i1tftttttt1i:.                                   .:;:    .;1tt1:                                                                                                       \n1tttttt1;:.                   ,;i;,                     ,itttttf1.                                                                                                      \n1ttttt;                     :ittttti:                .:1tttttt1:.       .:;;iiiiiiiiii;;;;:,.         .:;;iiiiiiiiii;;;;:,.               .,:;;iiiiiiiii;;:,.           \n1ttttt;                  .;1ttttttttt1;.           ,ittttttti,          ;11111111111111111111i;,     .;11111111111111111111i;,         .:;i111111111111111111i;,        \n1ttttt;                ,itttttt1i1tttttti,      .:itttttt1:.   .,       iiiiiii,,,,,,,,:;i1iii11;.   .iiiiiii,,,,,,,,:;i1iii11;.     .:i11ii1ii;:,,,,,,:;i1iii11i,      \n1ttttt;             .:1tttttt1:. .:1tttti,    ,;1tttttti,    ,;11.      iiiiiii          .;iiiii1:   .iiiiiii          .;iiiii1:    ,i1iiiii;.           .,;1iii11;     \n1ttt1t;           ,;1tt1ttti,       ,;;.    ,ittt1tt1;.    ,ittt1.      iiiiiii           .iiiii1;   .iiiiiii           .iiiii1;   .i1iiiii,                :1iiii1;    \n1t1t1t;         ,ittt1tt1;.              .;1tt1ttti:      ,ttt1t1.      iiiiiii          .;iiiii1:   .iiiiiii          .;iiiii1:   :1iiii1:                  ;iiiiii    \n1t111t;      .;1tt11tti:               ,i1tt1tt1;,        ,1111ti.      iiiiiii,,,,,,,::;i1iii11;.   .iiiiiii,,,,,,,::;i1iii11;.   :1iiii1:                  ;1iiiii    \ni1tt1;.    ,;1t11tt1;,    ,:.       .:1tt11tti:.          ,1111ti.      iiiiiii11111111111111i;,     .iiiiiii11111111111111i;,     ,1iiiiii.                ,iiiii1i    \n1ti:.   .:itt11tti:.   .:itt1;,   ,;1t111t1;,             ,1111ti.      iiiiiii;;;;;;;;;;;:,.        .iiiiiii;;;;;;;;;;;:,.         :11iiiii,             .:iiiii1i.    \n:,    ,;1t111t1;,      ,1tt11t1i;i1t11tti:.               ,11111i.      iiiiiii                      .iiiiiii                        ,i11iii1i:,..    ..,;i1iii11;.     \n    ,i1t1111i:.          ,;1t111t111t1i,                  ,11111i.      i1iii1i                      .i1iii1i                          ,;i111111iiiiiii1111111i;.       \n .:i111111i,               .:1111111:.                    ,11111i.      :iiiii,                       :iiiii,                            .,:;iii11111111iii;:,          \n;1111111;,                    ,;i;,                    .,:i11111i.        ...                           ...                                   ..,,,,,,,,..              \n:i111i:.   .,.                                     .,;i111111111:                                                                                                       \n  .,,    ,;111i;:,.                           .,:;i11111111i;:.                                                                                                         \n        .i111111111i:,.                   .,:;i11111111i:,.                                                                                                             \n           .:;i11111111i;,.           .,;i11111111i;:,.                                                                                                                 \n               .,;i11111111i;:.   .:;i11111111i;:.                                                                                                                      \n                   .,:;i1111111iii1111111ii:,.                                                                                                                          \n                       .,:;i111111111i;:,.                                                                                                                              \n                            .:;iii;:.                                                                                                                                   \n*/\n\npragma solidity =0.8.7;\n\nimport \"./interfaces/IPPO.sol\";\n//solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n//solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnableUpgradeable.sol\";\n\ncontract PPO is\n  IPPO,\n  SafeOwnableUpgradeable,\n  ERC20BurnableUpgradeable,\n  ERC20PermitUpgradeable\n{\n  ITransferHook private _transferHook;\n\n  function initialize(string memory _name, string memory _symbol)\n    public\n    initializer\n  {\n    __Ownable_init();\n    __ERC20_init(_name, _symbol);\n    __ERC20Permit_init(_name);\n  }\n\n  function setTransferHook(ITransferHook _newTransferHook)\n    external\n    override\n    onlyOwner\n  {\n    _transferHook = _newTransferHook;\n  }\n\n  function mint(address _recipient, uint256 _amount)\n    external\n    override\n    onlyOwner\n  {\n    _mint(_recipient, _amount);\n  }\n\n  function burn(uint256 _amount)\n    public\n    override(IPPO, ERC20BurnableUpgradeable)\n  {\n    super.burn(_amount);\n  }\n\n  function burnFrom(address _account, uint256 _amount)\n    public\n    override(IPPO, ERC20BurnableUpgradeable)\n  {\n    super.burnFrom(_account, _amount);\n  }\n\n  function transferFromWithPermit(\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external override {\n    permit(_from, _msgSender(), _amount, _deadline, _v, _r, _s);\n    transferFrom(_from, _to, _amount);\n  }\n\n  function getTransferHook() external view override returns (ITransferHook) {\n    return _transferHook;\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal override {\n    require(address(_transferHook) != address(0), \"Transfer hook not set\");\n    _transferHook.hook(_from, _to, _amount);\n    super._beforeTokenTransfer(_from, _to, _amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "prepo-shared-contracts/contracts/SafeOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./interfaces/ISafeOwnable.sol\";\n\nabstract contract SafeOwnableUpgradeable is ISafeOwnable, OwnableUpgradeable {\n  address private _nominee;\n\n  modifier onlyNominee() {\n    require(_msgSender() == _nominee, \"msg.sender != nominee\");\n    _;\n  }\n\n  function transferOwnership(address _newNominee)\n    public\n    virtual\n    override(ISafeOwnable, OwnableUpgradeable)\n    onlyOwner\n  {\n    _setNominee(_newNominee);\n  }\n\n  function acceptOwnership() public virtual override onlyNominee {\n    _transferOwnership(_nominee);\n    _setNominee(address(0));\n  }\n\n  function renounceOwnership()\n    public\n    virtual\n    override(ISafeOwnable, OwnableUpgradeable)\n    onlyOwner\n  {\n    super.renounceOwnership();\n    _setNominee(address(0));\n  }\n\n  function getNominee() public view virtual override returns (address) {\n    return _nominee;\n  }\n\n  function _setNominee(address _newNominee) internal virtual {\n    emit NomineeUpdate(_nominee, _newNominee);\n    _nominee = _newNominee;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/ppo/interfaces/IBlocklistTransferHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./ITransferHook.sol\";\nimport \"./IAccountList.sol\";\n\n/**\n * @notice Hook that provides blocklist functionality for token transfers.\n * A blocked address cannot send or receive the specified ERC20 token.\n */\ninterface IBlocklistTransferHook is ITransferHook {\n  /**\n   * @dev Emitted via `setBlocklist()`.\n   * @param newBlocklist Address of the `IAccountList` contract\n   */\n  event BlocklistChange(IAccountList newBlocklist);\n\n  /**\n   * @notice Sets the `IAccountList` contract that specifies the addresses to\n   * block.\n   * @param newBlocklist Address of the `IAccountList` contract\n   */\n  function setBlocklist(IAccountList newBlocklist) external;\n\n  ///@return The blocklist contract\n  function getBlocklist() external view returns (IAccountList);\n}\n"
    },
    "contracts/ppo/interfaces/IRestrictedTransferHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./IBlocklistTransferHook.sol\";\nimport \"./IAccountList.sol\";\n\n/**\n * @notice Hook for restricting transfers of an ERC20 token.\n * @dev Transfers of the specified token are restricted by default.\n *\n * Any address can send to an allowlisted destination address.\n *\n * Allowlisted source addresses are able to send to any other address\n * (including addresses not on the destination allowlist).\n *\n * Blocklisted addresses cannot send or receive tokens, even if allowlisted.\n */\ninterface IRestrictedTransferHook is IBlocklistTransferHook {\n  /**\n   * @dev Emitted via `setSourceAllowlist()`.\n   * @param newSourceAllowlist Address of the `IAccountList` contract\n   */\n  event SourceAllowlistChange(IAccountList newSourceAllowlist);\n\n  /**\n   * @dev Emitted via `setDestinationAllowlist()`.\n   * @param newDestinationAllowlist Address of the `IAccountList` contract\n   */\n  event DestinationAllowlistChange(IAccountList newDestinationAllowlist);\n\n  /**\n   * @notice Sets the external `IAccountList` contract that specifies the\n   * allowlisted source addresses.\n   * @param newSourceAllowlist Address of the `IAccountList` contract\n   */\n  function setSourceAllowlist(IAccountList newSourceAllowlist) external;\n\n  /**\n   * @notice Sets the external `IAccountList` contract that specifies the\n   * allowlisted destination addresses.\n   * @param newDestinationAllowlist Address of the `IAccountList` contract\n   */\n  function setDestinationAllowlist(IAccountList newDestinationAllowlist)\n    external;\n\n  ///@return The source allowlist contract\n  function getSourceAllowlist() external view returns (IAccountList);\n\n  ///@return The destination allowlist contract\n  function getDestinationAllowlist() external view returns (IAccountList);\n}\n"
    },
    "contracts/ppo/RestrictedTransferHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IRestrictedTransferHook.sol\";\nimport \"./interfaces/IAccountList.sol\";\nimport \"./BlocklistTransferHook.sol\";\n\ncontract RestrictedTransferHook is\n  IRestrictedTransferHook,\n  BlocklistTransferHook\n{\n  IAccountList private _sourceAllowlist;\n  IAccountList private _destinationAllowlist;\n\n  constructor() {}\n\n  function hook(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) public virtual override(BlocklistTransferHook, ITransferHook) {\n    super.hook(_from, _to, _amount);\n    if (_sourceAllowlist.isIncluded(_from)) return;\n    require(_destinationAllowlist.isIncluded(_to), \"Destination not allowed\");\n  }\n\n  function setSourceAllowlist(IAccountList _newSourceAllowlist)\n    external\n    override\n    onlyOwner\n  {\n    _sourceAllowlist = _newSourceAllowlist;\n    emit SourceAllowlistChange(_newSourceAllowlist);\n  }\n\n  function setDestinationAllowlist(IAccountList _newDestinationAllowlist)\n    external\n    override\n    onlyOwner\n  {\n    _destinationAllowlist = _newDestinationAllowlist;\n    emit DestinationAllowlistChange(_newDestinationAllowlist);\n  }\n\n  function getSourceAllowlist() external view override returns (IAccountList) {\n    return _sourceAllowlist;\n  }\n\n  function getDestinationAllowlist()\n    external\n    view\n    override\n    returns (IAccountList)\n  {\n    return _destinationAllowlist;\n  }\n}\n"
    },
    "contracts/ppo/BlocklistTransferHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IBlocklistTransferHook.sol\";\nimport \"./interfaces/IAccountList.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract BlocklistTransferHook is IBlocklistTransferHook, SafeOwnable {\n  IAccountList private _blocklist;\n\n  constructor() {}\n\n  function hook(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) public virtual override {\n    IAccountList _list = _blocklist;\n    require(!_list.isIncluded(_from), \"Sender blocked\");\n    require(!_list.isIncluded(_to), \"Recipient blocked\");\n  }\n\n  function setBlocklist(IAccountList _newBlocklist)\n    external\n    override\n    onlyOwner\n  {\n    _blocklist = _newBlocklist;\n    emit BlocklistChange(_newBlocklist);\n  }\n\n  function getBlocklist() external view override returns (IAccountList) {\n    return _blocklist;\n  }\n}\n"
    },
    "contracts/ppo/AccountList.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IAccountList.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract AccountList is IAccountList, SafeOwnable {\n  uint256 private _resetIndex;\n  mapping(uint256 => mapping(address => bool))\n    private _resetIndexToAccountToIncluded;\n\n  constructor() {}\n\n  function set(address[] calldata _accounts, bool[] calldata _included)\n    external\n    override\n    onlyOwner\n  {\n    require(_accounts.length == _included.length, \"Array length mismatch\");\n    uint256 _arrayLength = _accounts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      _resetIndexToAccountToIncluded[_resetIndex][_accounts[i]] = _included[i];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function reset(address[] calldata _newIncludedAccounts)\n    external\n    override\n    onlyOwner\n  {\n    _resetIndex++;\n    uint256 _arrayLength = _newIncludedAccounts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      _resetIndexToAccountToIncluded[_resetIndex][\n        _newIncludedAccounts[i]\n      ] = true;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function isIncluded(address _account) external view override returns (bool) {\n    return _resetIndexToAccountToIncluded[_resetIndex][_account];\n  }\n}\n"
    },
    "contracts/mini-sales/interfaces/IMiniSales.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./IPurchaseHook.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @notice Accepts a payment token in a one-way immediate exchange for a sale\n * token at a fixed price.\n * @dev Sales are unpermissioned by default, but can be made permissioned by\n * setting a purchase hook with participation restriction logic.\n *\n * Sale tokens sent to the contract are automatically allocated to the sale\n * and attributed to the contract owner. Sale tokens and payment tokens can\n * both be withdrawn from the sale by the owner at any time. Sales can be\n * implicitly paused/ended by the owner by withdrawing the sale token balance\n * in full.\n *\n * During initialization, the contract will automatically get `decimals` for\n * the Sale Token and generate a denominator based on it. This value is\n * immutable and assumes the `decimals` of the Sale Token will not change.\n *\n * This contract can be reused for multiple sequential sales.\n */\ninterface IMiniSales {\n  /**\n   * @dev Emitted via `purchase()`.\n   * @param purchaser Address that payment token was taken from\n   * @param recipient Address that sale token was delivered to\n   * @param amount Amount of sale token purchased\n   * @param price Sale token price in terms of payment token\n   */\n  event Purchase(\n    address indexed purchaser,\n    address indexed recipient,\n    uint256 amount,\n    uint256 price\n  );\n\n  /**\n   * @dev Emitted via `setPrice()`.\n   * @param newPrice New sale token price in terms of payment token\n   */\n  event PriceChange(uint256 newPrice);\n\n  /**\n   * @dev Emitted via `setPurchaseHook()`.\n   * @param newPurchaseHook Address of the new purchase hook\n   */\n  event PurchaseHookChange(IPurchaseHook newPurchaseHook);\n\n  /**\n   * @notice Purchases sale token in exchange for payment token at a fixed\n   * price.\n   * @dev msg.sender must have approved this contract to spend at least the\n   * required amount of their payment token balance.\n   *\n   * `price` must match contract's current price.\n   *\n   * If a purchase hook is set, the hook will be called within this function.\n   * @param recipient Address that sale token will be delivered to\n   * @param amount Amount of sale token to be purchased\n   * @param price Sale token price in terms of payment token\n   * @param data Data payload passed on to the hook for added functionality\n   */\n  function purchase(\n    address recipient,\n    uint256 amount,\n    uint256 price,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @notice Sets the fixed price of sale token in terms of payment token.\n   * @dev Price must be set in terms of how much payment token (using the\n   * payment token's decimal precision) would buy 1 sale token. E.g. a\n   * price of 1.234 USDC would be set as 1.234e6 since USDC has 6 decimals.\n   *\n   * Only callable by `owner()`.\n   * @param newPrice New fixed price of sale token\n   */\n  function setPrice(uint256 newPrice) external;\n\n  /**\n   * @notice Sets the `IPurchaseHook` contract to be called during a purchase.\n   * @dev Can be set to zero address to make the sale unpermissioned.\n   *\n   * Only callable by `owner()`.\n   * @param newPurchaseHook Address of the new purchase hook\n   */\n  function setPurchaseHook(IPurchaseHook newPurchaseHook) external;\n\n  /// @return The ERC20 token being sold\n  function getSaleToken() external view returns (IERC20Metadata);\n\n  /// @return The ERC20 token used for payment\n  function getPaymentToken() external view returns (IERC20Metadata);\n\n  /// @return The fixed price of sale token in terms of payment token\n  function getPrice() external view returns (uint256);\n\n  /// @return The purchase hook contract\n  function getPurchaseHook() external view returns (IPurchaseHook);\n}\n"
    },
    "contracts/mini-sales/MiniSales.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IMiniSales.sol\";\nimport \"prepo-shared-contracts/contracts/WithdrawERC20.sol\";\n\ncontract MiniSales is IMiniSales, WithdrawERC20 {\n  IERC20Metadata private immutable _saleToken;\n  IERC20Metadata private immutable _paymentToken;\n  uint256 private immutable _saleTokenDecimals;\n  uint256 private _price;\n  IPurchaseHook private _purchaseHook;\n\n  constructor(\n    address _newSaleToken,\n    address _newPaymentToken,\n    uint256 _newSaleTokenDecimals\n  ) {\n    _saleToken = IERC20Metadata(_newSaleToken);\n    _paymentToken = IERC20Metadata(_newPaymentToken);\n    _saleTokenDecimals = 10**_newSaleTokenDecimals;\n  }\n\n  function purchase(\n    address _recipient,\n    uint256 _saleTokenAmount,\n    uint256 _purchasePrice,\n    bytes calldata _data\n  ) external override nonReentrant {\n    require(_purchasePrice == _price, \"Price mismatch\");\n    IPurchaseHook _hook = _purchaseHook;\n    if (address(_hook) != address(0)) {\n      _hook.hook(\n        _msgSender(),\n        _recipient,\n        _saleTokenAmount,\n        _purchasePrice,\n        _data\n      );\n    }\n    uint256 _paymentTokenAmount = (_saleTokenAmount * _purchasePrice) /\n      _saleTokenDecimals;\n    _paymentToken.transferFrom(\n      _msgSender(),\n      address(this),\n      _paymentTokenAmount\n    );\n    _saleToken.transfer(_recipient, _saleTokenAmount);\n    emit Purchase(_msgSender(), _recipient, _saleTokenAmount, _purchasePrice);\n  }\n\n  function setPrice(uint256 _newPrice) external override onlyOwner {\n    _price = _newPrice;\n    emit PriceChange(_newPrice);\n  }\n\n  function setPurchaseHook(IPurchaseHook _newPurchaseHook)\n    external\n    override\n    onlyOwner\n  {\n    _purchaseHook = _newPurchaseHook;\n    emit PurchaseHookChange(_newPurchaseHook);\n  }\n\n  function getSaleToken() external view override returns (IERC20Metadata) {\n    return _saleToken;\n  }\n\n  function getPaymentToken() external view override returns (IERC20Metadata) {\n    return _paymentToken;\n  }\n\n  function getPrice() external view override returns (uint256) {\n    return _price;\n  }\n\n  function getPurchaseHook() external view override returns (IPurchaseHook) {\n    return _purchaseHook;\n  }\n}\n"
    },
    "contracts/ppo-staking/governance/staking/SteppedTimeMultiplierV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/ITimeMultiplierCalculator.sol\";\n\ncontract SteppedTimeMultiplierV1 is ITimeMultiplierCalculator {\n  function calculate(uint256 _timestamp)\n    external\n    view\n    override\n    returns (uint256 timeMultiplier)\n  {\n    // If user has no timestamp, it means they haven't staked\n    if (_timestamp == 0) return 1000000000000;\n\n    uint256 hodlLength = block.timestamp - _timestamp;\n    if (hodlLength < 13 weeks) {\n      // 0-3 months = 1x\n      return 1000000000000;\n    } else if (hodlLength < 26 weeks) {\n      // 3 months = 1.2x\n      return 1200000000000;\n    } else if (hodlLength < 52 weeks) {\n      // 6 months = 1.3x\n      return 1300000000000;\n    } else if (hodlLength < 78 weeks) {\n      // 12 months = 1.4x\n      return 1400000000000;\n    } else if (hodlLength < 104 weeks) {\n      // 18 months = 1.5x\n      return 1500000000000;\n    }\n    // >24 months = 1.6x\n    return 1600000000000;\n  }\n}\n"
    },
    "contracts/ppo-staking/mocks/MockAchievementsManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport \"../governance/staking/interfaces/IAchievementsManager.sol\";\n\ncontract MockAchievementsManager is IAchievementsManager {\n  constructor() {}\n\n  function checkForSeasonFinish(address _account)\n    external\n    override\n    returns (int64)\n  {\n    return 1e12;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/nexus/MockNexus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {ModuleKeys} from \"../../shared/ModuleKeys.sol\";\n\ncontract MockNexus is ModuleKeys {\n  address public governor;\n  bool private _initialized;\n\n  mapping(bytes32 => address) public modules;\n\n  constructor(\n    address _governorAddr,\n    address _savingsManager,\n    address _interestValidator\n  ) {\n    governor = _governorAddr;\n    modules[KEY_SAVINGS_MANAGER] = _savingsManager;\n    modules[KEY_INTEREST_VALIDATOR] = _interestValidator;\n    _initialized = true;\n  }\n\n  function initialized() external view returns (bool) {\n    return _initialized;\n  }\n\n  function getModule(bytes32 _key) external view returns (address) {\n    return modules[_key];\n  }\n\n  function setSavingsManager(address _savingsManager) external {\n    modules[KEY_SAVINGS_MANAGER] = _savingsManager;\n  }\n\n  function setInterestValidator(address _interestValidator) external {\n    modules[KEY_INTEREST_VALIDATOR] = _interestValidator;\n  }\n\n  function setLiquidator(address _liquidator) external {\n    modules[KEY_LIQUIDATOR] = _liquidator;\n  }\n\n  function setRecollateraliser(address _recollateraliser) external {\n    modules[KEY_RECOLLATERALISER] = _recollateraliser;\n  }\n\n  function setKeeper(address _keeper) external {\n    modules[KEY_KEEPER] = _keeper;\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/masset/MockAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IAaveATokenV2, IAaveLendingPoolV2, ILendingPoolAddressesProviderV2} from \"../../peripheral/Aave/IAave.sol\";\n\nimport {MassetHelpers, SafeERC20} from \"../../shared/MassetHelpers.sol\";\nimport {IERC20, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockATokenV2 is ERC20 {\n  address public lendingPool;\n  IERC20 public underlyingToken;\n  using SafeERC20 for IERC20;\n\n  constructor(address _lendingPool, IERC20 _underlyingToken)\n    ERC20(\"MockAToken\", \"MAT\")\n  {\n    lendingPool = _lendingPool;\n    underlyingToken = _underlyingToken;\n  }\n\n  function burn(address user, uint256 amount) public {\n    _burn(user, amount);\n  }\n\n  function mint(address user, uint256 amount) public {\n    _mint(user, amount);\n  }\n}\n\ncontract MockAaveV2 is IAaveLendingPoolV2, ILendingPoolAddressesProviderV2 {\n  using SafeERC20 for IERC20;\n\n  mapping(address => address) reserveToAToken;\n  address pool = address(this);\n  address payable core = payable(address(this));\n\n  function addAToken(address _aToken, address _underlying) public {\n    MassetHelpers.safeInfiniteApprove(_underlying, _aToken);\n    reserveToAToken[_underlying] = _aToken;\n  }\n\n  function deposit(\n    address _reserve,\n    uint256 _amount,\n    address, /* _onBehalfOf */\n    uint16 /*_referralCode*/\n  ) external override {\n    uint256 previousBal = IERC20(reserveToAToken[_reserve]).balanceOf(\n      msg.sender\n    );\n    uint256 factor = 2 * (10**13); // 0.002%\n    uint256 interest = (previousBal * factor) / 1e18;\n    MockATokenV2(reserveToAToken[_reserve]).mint(msg.sender, interest);\n    // Take their reserve\n    transferTokens(msg.sender, address(this), _reserve, true, _amount);\n    // Credit them with aToken\n    MockATokenV2(reserveToAToken[_reserve]).mint(msg.sender, _amount);\n  }\n\n  function withdraw(\n    address reserve,\n    uint256 amount,\n    address to\n  ) external override {\n    MockATokenV2(reserveToAToken[reserve]).burn(msg.sender, amount);\n    IERC20(reserve).transfer(to, amount);\n  }\n\n  function getLendingPool() external view override returns (address) {\n    return pool;\n  }\n\n  function breakLendingPools() external {\n    pool = address(0);\n    core = payable(address(0));\n  }\n\n  function transferTokens(\n    address _sender,\n    address _recipient,\n    address _basset,\n    bool _hasTxFee,\n    uint256 _qty\n  ) internal returns (uint256 receivedQty) {\n    receivedQty = _qty;\n    if (_hasTxFee) {\n      uint256 balBefore = IERC20(_basset).balanceOf(_recipient);\n      IERC20(_basset).safeTransferFrom(_sender, _recipient, _qty);\n      uint256 balAfter = IERC20(_basset).balanceOf(_recipient);\n      receivedQty = _qty > balAfter - balBefore ? balAfter - balBefore : _qty;\n    } else {\n      IERC20(_basset).safeTransferFrom(_sender, _recipient, _qty);\n    }\n  }\n}\n"
    },
    "contracts/ppo-staking/z_mocks/rewards/MockRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IRootChainManager} from \"../../interfaces/IRootChainManager.sol\";\n\ncontract MockRootChainManager is IRootChainManager {\n  address public constant ETHER_ADDRESS =\n    0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  event DepositFor(\n    address indexed userAddress,\n    address indexed rootToken,\n    bytes data\n  );\n\n  function depositFor(\n    address userAddress,\n    address rootToken,\n    bytes memory data\n  ) external override {\n    require(\n      rootToken != ETHER_ADDRESS,\n      \"RootChainManager: INVALID_ROOT_TOKEN\"\n    );\n    require(userAddress != address(0), \"RootChainManager: INVALID_USER\");\n\n    uint256 amount = abi.decode(data, (uint256));\n    require(amount > 0, \"RootChainManager: INVALID_AMOUNT\");\n    IERC20(rootToken).transferFrom(msg.sender, address(this), amount);\n\n    emit DepositFor(userAddress, rootToken, data);\n  }\n}\n"
    },
    "contracts/ppo-staking/interfaces/IRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\ninterface IRootChainManager {\n  function depositFor(\n    address userAddress,\n    address rootToken,\n    bytes memory data\n  ) external;\n}\n\ninterface IStateReceiver {\n  function onStateReceive(uint256 id, bytes calldata data) external;\n}\n\ninterface IChildToken {\n  function deposit(address user, bytes calldata depositData) external;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/ppo-staking/interfaces/IStakingRewardsWithPlatformToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingRewardsWithPlatformToken {\n  /**\n   * @notice Stakes a given amount of the StakingToken for the sender\n   * @param _amount Units of StakingToken\n   */\n  function stake(uint256 _amount) external;\n\n  /**\n   * @notice Stakes a given amount of the StakingToken for a given beneficiary\n   * @param _beneficiary Staked tokens are credited to this address\n   * @param _amount      Units of StakingToken\n   */\n  function stake(address _beneficiary, uint256 _amount) external;\n\n  /**\n   * @notice Withdraws stake from pool and claims any unlocked rewards.\n   */\n  function exit() external;\n\n  /**\n   * @notice Withdraws given stake amount from the pool\n   * @param _amount Units of the staked token to withdraw\n   */\n  function withdraw(uint256 _amount) external;\n\n  /**\n     * @notice Redeems staked interest-bearing asset tokens for either bAsset or fAsset tokens.\n     * Withdraws a given staked amount of interest-bearing assets from the vault,\n     * redeems the interest-bearing asset for the underlying mAsset and either\n     * 1. Redeems the underlying mAsset tokens for bAsset tokens.\n     * 2. Swaps the underlying mAsset tokens for fAsset tokens in a Feeder Pool.\n     * @param _amount        Units of the staked interest-bearing asset tokens to withdraw. eg imUSD or imBTC.\n     * @param _minAmountOut  Minimum units of `output` tokens to be received by the beneficiary. This is to the same decimal places as the `output` token.\n     * @param _output        Asset to receive in exchange for the redeemed mAssets. This can be a bAsset or a fAsset. For example:\n        - bAssets (USDC, DAI, sUSD or USDT) or fAssets (GUSD, BUSD, alUSD, FEI or RAI) for mainnet imUSD Vault.\n        - bAssets (USDC, DAI or USDT) or fAsset FRAX for Polygon imUSD Vault.\n        - bAssets (WBTC, sBTC or renBTC) or fAssets (HBTC or TBTCV2) for mainnet imBTC Vault.\n     * @param _beneficiary   Address to send `output` tokens to.\n     * @param _router        mAsset address if the `output` is a bAsset. Feeder Pool address if the `output` is a fAsset.\n     * @param _isBassetOut   `true` if `output` is a bAsset. `false` if `output` is a fAsset.\n     * @return outputQuantity Units of `output` tokens sent to the beneficiary. This is to the same decimal places as the `output` token.\n     */\n  function withdrawAndUnwrap(\n    uint256 _amount,\n    uint256 _minAmountOut,\n    address _output,\n    address _beneficiary,\n    address _router,\n    bool _isBassetOut\n  ) external returns (uint256 outputQuantity);\n\n  /**\n   * @notice Claims outstanding rewards (both platform and native) for the sender.\n   * First updates outstanding reward allocation and then transfers.\n   */\n  function claimReward() external;\n\n  /**\n   * @notice Claims outstanding rewards for the sender. Only the native\n   * rewards token, and not the platform rewards\n   */\n  function claimRewardOnly() external;\n\n  /**\n   * @notice Gets the last applicable timestamp for this reward period\n   */\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  /**\n   * @notice Calculates the amount of unclaimed rewards a user has earned\n   * @return 'Reward' per staked token\n   */\n  function rewardPerToken() external view returns (uint256, uint256);\n\n  /**\n   * @notice Calculates the amount of unclaimed rewards a user has earned\n   * @param _account User address\n   * @return Total reward amount earned\n   */\n  function earned(address _account) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/ppo-staking/interfaces/IVotiumBribe.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IVotiumBribe {\n  function depositBribe(\n    address _token,\n    uint256 _amount,\n    bytes32 _proposal,\n    uint256 _choiceIndex\n  ) external;\n}\n"
    },
    "contracts/ppo-staking/interfaces/IDisperse.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IDisperse {\n  function disperseTokenSimple(\n    IERC20 token,\n    address[] memory recipients,\n    uint256[] memory values\n  ) external;\n}\n"
    },
    "contracts/vesting/mocks/MockVestingClaimer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"../Vesting.sol\";\n\ncontract MockVestingClaimer {\n  Vesting private _vesting;\n\n  constructor(address _newVesting) {\n    _vesting = Vesting(_newVesting);\n  }\n\n  function claimFunds() external {\n    _vesting.claim();\n  }\n}\n"
    },
    "contracts/token-shop/PurchaseHook.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IPurchaseHook.sol\";\nimport \"./interfaces/ITokenShop.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract PurchaseHook is IPurchaseHook, SafeOwnable {\n  mapping(address => uint256) private _erc721ToMaxPurchasesPerUser;\n  mapping(address => mapping(uint256 => uint256))\n    private _erc1155ToIdToMaxPurchasesPerUser;\n  ITokenShop private _tokenShop;\n\n  //TODO: EOA validation check in hookERC721 and hookERC1155 implementation\n  function hookERC721(\n    address _user,\n    address _tokenContract,\n    uint256 _tokenId\n  ) external view override {\n    ITokenShop _shop = _tokenShop;\n    require(address(_shop) != address(0), \"Token shop not set in hook\");\n    uint256 _maxPurchaseAmount = _erc721ToMaxPurchasesPerUser[_tokenContract];\n    if (_maxPurchaseAmount != 0) {\n      require(\n        _shop.getERC721PurchaseCount(_user, _tokenContract) <\n          _maxPurchaseAmount,\n        \"ERC721 purchase limit reached\"\n      );\n    }\n  }\n\n  function hookERC1155(\n    address _user,\n    address _tokenContract,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external override {\n    ITokenShop _shop = _tokenShop;\n    require(address(_shop) != address(0), \"Token shop not set in hook\");\n    uint256 _maxPurchaseAmount = _erc1155ToIdToMaxPurchasesPerUser[\n      _tokenContract\n    ][_tokenId];\n    if (_maxPurchaseAmount != 0) {\n      require(\n        _shop.getERC1155PurchaseCount(_user, _tokenContract, _tokenId) +\n          _amount <=\n          _maxPurchaseAmount,\n        \"ERC1155 purchase limit reached\"\n      );\n    }\n  }\n\n  function setTokenShop(address _newTokenShop) external override onlyOwner {\n    _tokenShop = ITokenShop(_newTokenShop);\n  }\n\n  function setMaxERC721PurchasesPerUser(\n    address[] memory _contracts,\n    uint256[] memory _amounts\n  ) external override onlyOwner {\n    require(_contracts.length == _amounts.length, \"Array length mismatch\");\n    uint256 _arrayLength = _contracts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      _erc721ToMaxPurchasesPerUser[_contracts[i]] = _amounts[i];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setMaxERC1155PurchasesPerUser(\n    address[] memory _contracts,\n    uint256[] memory _ids,\n    uint256[] memory _amounts\n  ) external override onlyOwner {\n    require(\n      _contracts.length == _amounts.length && _ids.length == _amounts.length,\n      \"Array length mismatch\"\n    );\n    uint256 _arrayLength = _contracts.length;\n    for (uint256 i; i < _arrayLength; ) {\n      _erc1155ToIdToMaxPurchasesPerUser[_contracts[i]][_ids[i]] = _amounts[i];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function getMaxERC721PurchasesPerUser(address _tokenContract)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _erc721ToMaxPurchasesPerUser[_tokenContract];\n  }\n\n  function getMaxERC1155PurchasesPerUser(address _tokenContract, uint256 _id)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _erc1155ToIdToMaxPurchasesPerUser[_tokenContract][_id];\n  }\n\n  function getTokenShop() external view override returns (ITokenShop) {\n    return _tokenShop;\n  }\n}\n"
    },
    "contracts/mini-sales/MiniSalesFlag.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\nimport \"./interfaces/IMiniSalesFlag.sol\";\nimport \"prepo-shared-contracts/contracts/SafeOwnable.sol\";\n\ncontract MiniSalesFlag is IMiniSalesFlag, SafeOwnable {\n  bool private _saleStarted;\n\n  function setSaleStarted(bool _newSaleStarted) external override onlyOwner {\n    _saleStarted = _newSaleStarted;\n  }\n\n  function hasSaleStarted() external view override returns (bool) {\n    return _saleStarted;\n  }\n}\n"
    },
    "contracts/mini-sales/interfaces/IMiniSalesFlag.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity =0.8.7;\n\ninterface IMiniSalesFlag {\n  function setSaleStarted(bool newSaleStarted) external;\n\n  function hasSaleStarted() external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 25000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
