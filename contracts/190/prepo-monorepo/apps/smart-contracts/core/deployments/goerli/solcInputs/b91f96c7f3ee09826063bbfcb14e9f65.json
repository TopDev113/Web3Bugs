{
  "language": "Solidity",
  "sources": {
    "contracts/core/AccountAccessController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IAccountAccessController.sol\";\n\ncontract AccountAccessController is Ownable, IAccountAccessController {\n    bytes32 private _root;\n    uint16 internal _allowedAccountsIndex;\n    uint16 internal _blockedAccountsIndex;\n    mapping(uint16 => mapping(address => bool)) private _allowedAccounts;\n    mapping(uint16 => mapping(address => bool)) private _blockedAccounts;\n\n    constructor() {}\n\n    function setRoot(bytes32 _newRoot) external override onlyOwner {\n        _setRoot(_newRoot);\n    }\n\n    function clearAllowedAccounts() external override onlyOwner {\n        _clearAllowedAccounts();\n    }\n\n    function setRootAndClearAllowedAccounts(bytes32 _newRoot)\n        external\n        override\n        onlyOwner\n    {\n        _setRoot(_newRoot);\n        _clearAllowedAccounts();\n    }\n\n    function clearBlockedAccounts() external override onlyOwner {\n        _blockedAccountsIndex++;\n        emit BlockedAccountsCleared(_blockedAccountsIndex);\n    }\n\n    function allowAccounts(address[] calldata _accounts)\n        external\n        override\n        onlyOwner\n    {\n        for (uint256 _i = 0; _i < _accounts.length; _i++) {\n            _allowedAccounts[_allowedAccountsIndex][_accounts[_i]] = true;\n            emit AccountAllowed(_accounts[_i]);\n        }\n    }\n\n    function blockAccounts(address[] calldata _accounts)\n        external\n        override\n        onlyOwner\n    {\n        for (uint256 _i = 0; _i < _accounts.length; _i++) {\n            _blockedAccounts[_blockedAccountsIndex][_accounts[_i]] = true;\n            emit AccountBlocked(_accounts[_i]);\n        }\n    }\n\n    function allowSelf(bytes32[] calldata _proof) external override {\n        require(\n            _allowedAccounts[_allowedAccountsIndex][msg.sender] == false,\n            \"Account already registered\"\n        );\n        bytes32 _leaf = keccak256(abi.encodePacked(msg.sender));\n\n        require(MerkleProof.verify(_proof, _root, _leaf), \"Invalid proof\");\n        _allowedAccounts[_allowedAccountsIndex][msg.sender] = true;\n        emit AccountAllowed(msg.sender);\n    }\n\n    function getRoot() external view override returns (bytes32) {\n        return _root;\n    }\n\n    function isAccountAllowed(address _account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _allowedAccounts[_allowedAccountsIndex][_account];\n    }\n\n    function isAccountBlocked(address _account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _blockedAccounts[_blockedAccountsIndex][_account];\n    }\n\n    function _setRoot(bytes32 _newRoot) internal {\n        _root = _newRoot;\n        emit RootChanged(_root);\n    }\n\n    function _clearAllowedAccounts() internal {\n        _allowedAccountsIndex++;\n        emit AllowedAccountsCleared(_allowedAccountsIndex);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/core/interfaces/IAccountAccessController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity =0.8.7;\n\n/**\n * @notice The Access Controller is used for allowing/blocking access to\n * contract functions.\n */\ninterface IAccountAccessController {\n    /**\n     * @dev Emitted via `setRoot()`.\n     * @param root The new merkle root\n     */\n    event RootChanged(bytes32 root);\n\n    /**\n     * @dev Emitted via `allowAccounts()` and `allowSelf`.\n     * @param account The account that was allowed\n     */\n    event AccountAllowed(address indexed account);\n\n    /**\n     * @dev Emitted via `blockAccounts()`.\n     * @param account The account that was blocked\n     */\n    event AccountBlocked(address indexed account);\n\n    /**\n     * @dev Emitted via `setRoot()` and `clearAllowedAccounts`,\n     * and `setRootAndClearAllowedAccounts`.\n     * @param index The index for the new allowlist\n     */\n    event AllowedAccountsCleared(uint32 index);\n\n    /**\n     * @dev Emitted via `clearBlockedAccounts`.\n     * @param index The index for the new blocklist\n     */\n    event BlockedAccountsCleared(uint32 index);\n\n    /**\n     * @notice Sets the merkle root used to determine which accounts\n     * to allow.\n     * @dev Only callable by `owner()`.\n     * @param newRoot The new merkle root\n     */\n    function setRoot(bytes32 newRoot) external;\n\n    /**\n     * @notice Clears the allowlist for all accounts.\n     * @dev This does not actually modify any existing allowlists, the\n     * the function will increment an index pointing to a new mapping\n     * that will be referenced.\n     *\n     * Only callable by `owner()`.\n     */\n    function clearAllowedAccounts() external;\n\n    /**\n     * @notice Sets the merkle root used to determine which accounts\n     * to allow and resets the allowlist.\n     * @dev Only callable by `owner()`.\n     * @param newRoot The new merkle root\n     */\n    function setRootAndClearAllowedAccounts(bytes32 newRoot) external;\n\n    /**\n     * @notice Clears the blocklist for all accounts.\n     * @dev This does not actually modify any existing blocklists, the\n     * the function will increment an index pointing to a new mapping\n     * that will be referenced.\n     *\n     * Only callable by `owner()`.\n     */\n    function clearBlockedAccounts() external;\n\n    /**\n     * @notice Allows one or more accounts, regardless of existing access.\n     * @dev Only callable by `owner()`.\n     * @param accounts Accounts to allow\n     */\n    function allowAccounts(address[] calldata accounts) external;\n\n    /**\n     * @notice Blocks one or more accounts, regardless of existing access.\n     * @dev Only callable by `owner()`.\n     * @param accounts Accounts to block\n     */\n    function blockAccounts(address[] calldata accounts) external;\n\n    /**\n     * @notice Allows the caller if the provided signature is valid.\n     * @dev An account cannot call this function if it is already\n     * allowed/blocked.\n     * @param proof Proof of the caller's inclusion in the merkle root\n     */\n    function allowSelf(bytes32[] calldata proof) external;\n\n    /**\n     * @notice Returns the merkle root used to determine which accounts\n     * to allow.\n     * @return The current merkle root\n     */\n    function getRoot() external view returns (bytes32);\n\n    /**\n     * @return Whether the account is allowed\n     */\n    function isAccountAllowed(address account) external view returns (bool);\n\n    /**\n     * @return Whether the account is blocked\n     */\n    function isAccountBlocked(address account) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/core/mocks/MockAccountAccessController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"../AccountAccessController.sol\";\n\ncontract MockAccountAccessController is AccountAccessController {\n    constructor() {}\n\n    function getAllowedAccountsIndex() external view returns (uint16) {\n        return _allowedAccountsIndex;\n    }\n\n    function getBlockedAccountsIndex() external view returns (uint16) {\n        return _blockedAccountsIndex;\n    }\n}\n"
    },
    "contracts/core/DepositHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\nimport \"./interfaces/IHook.sol\";\nimport \"./interfaces/IAccountAccessController.sol\";\nimport \"./interfaces/ICollateralDepositRecord.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\npragma solidity =0.8.7;\n\ncontract DepositHook is IHook, Ownable {\n    address private _vault;\n    ICollateralDepositRecord private _depositRecord;\n\n    constructor(address _newDepositRecord) {\n        _depositRecord = ICollateralDepositRecord(_newDepositRecord);\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    function hook(\n        address _sender,\n        uint256 _initialAmount,\n        uint256 _finalAmount\n    ) external override onlyVault {\n        _depositRecord.recordDeposit(_sender, _finalAmount);\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function getVault() external view returns (address) {\n        return _vault;\n    }\n\n    function getDepositRecord()\n        external\n        view\n        returns (ICollateralDepositRecord)\n    {\n        return _depositRecord;\n    }\n}\n"
    },
    "contracts/core/interfaces/IHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\n/// @notice Used for adding additional checks and/or data recording when\n/// interacting with the Collateral vault.\ninterface IHook {\n    /**\n     * @dev Emitted via `setVault()`.\n     * @param vault The new vault address\n     */\n    event VaultChanged(address vault);\n\n    /**\n     * @dev This hook should only contain calls to external contracts, where\n     * the actual implementation and state of a feature will reside.\n     *\n     * `initialAmount` for `deposit()` and `withdraw()` is the `amount`\n     * parameter passed in by the caller.\n     *\n     * `finalAmount` for `deposit()` is the Base Token amount provided by\n     * the user and any latent contract balance that is included in the\n     * deposit.\n     *\n     * `finalAmount` for `withdraw()` is the Base Token amount returned\n     * by the configured Strategy.\n     *\n     * Only callable by the vault.\n     * @param sender The account calling the Collateral vault\n     * @param initialAmount The amount passed to the Collateral vault\n     * @param finalAmount The amount actually involved in the transaction\n     */\n    function hook(\n        address sender,\n        uint256 initialAmount,\n        uint256 finalAmount\n    ) external;\n\n    /**\n     * @notice Sets the vault that will be allowed to call this hook.\n     * @dev Only callable by owner().\n     * @param newVault The vault address\n     */\n    function setVault(address newVault) external;\n}\n"
    },
    "contracts/core/interfaces/ICollateralDepositRecord.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity =0.8.7;\n\n/// @notice Enforces Collateral deposit caps.\ninterface ICollateralDepositRecord {\n    /// @dev Emitted via `setGlobalDepositCap()`.\n    /// @param amount New global deposit cap\n    event GlobalDepositCapChanged(uint256 amount);\n\n    /// @dev Emitted via `setAccountDepositCap()`.\n    /// @param amount New account deposit cap\n    event AccountDepositCapChanged(uint256 amount);\n\n    /// @dev Emitted via `setAllowedHook()`.\n    /// @param hook Hook with changed permissions\n    /// @param allowed Whether the hook is allowed\n    event AllowedHooksChanged(address hook, bool allowed);\n\n    /**\n     * @dev This function will be called by a Collateral hook before the fee\n     * is subtracted from the initial `amount` passed in.\n     *\n     * Only callable by allowed hooks.\n     *\n     * Reverts if the incoming deposit brings either total over their\n     * respective caps.\n     *\n     * `finalAmount` is added to both the global and account-specific\n     * deposit totals.\n     * @param sender The account making the Collateral deposit\n     * @param finalAmount The amount actually deposited by the user\n     */\n    function recordDeposit(address sender, uint256 finalAmount) external;\n\n    /**\n     * @notice Called by a Collateral hook before the fee is subtracted from\n     * the amount withdrawn from the Strategy.\n     * @dev `finalAmount` is subtracted from both the global and\n     * account-specific deposit totals.\n     *\n     * Only callable by allowed hooks.\n     * @param sender The account making the Collateral withdrawal\n     * @param finalAmount The amount actually withdrawn by the user\n     */\n    function recordWithdrawal(address sender, uint256 finalAmount) external;\n\n    /**\n     * @notice Sets the global cap on assets backing Collateral in circulation.\n     * @dev Only callable by owner().\n     * @param newGlobalDepositCap The new global deposit cap\n     */\n    function setGlobalDepositCap(uint256 newGlobalDepositCap) external;\n\n    /**\n     * @notice Sets the cap on net Base Token deposits per user.\n     * @dev Only callable by owner().\n     * @param newAccountDepositCap The new account deposit cap\n     */\n    function setAccountDepositCap(uint256 newAccountDepositCap) external;\n\n    /**\n     * @notice Sets if a contract is allowed to record deposits\n     * and withdrawals.\n     * @dev Only callable by owner().\n     * @param hook The contract address\n     * @param allowed Whether or not the contract will be allowed\n     */\n    function setAllowedHook(address hook, bool allowed) external;\n\n    /**\n     * @notice Gets the maximum Base Token amount that is allowed to be\n     * deposited (net of withdrawals).\n     * @dev Deposits are not allowed if `globalDepositAmount` exceeds\n     * the `globalDepositCap`.\n     * @return Base Token amount\n     */\n    function getGlobalDepositCap() external view returns (uint256);\n\n    /// @return Net total of Base Token deposited.\n    function getGlobalDepositAmount() external view returns (uint256);\n\n    /**\n     * @dev An account will not be allowed to deposit if their net deposits\n     * exceed `accountDepositCap`.\n     * @return The cap on net Base Token deposits per user\n     */\n    function getAccountDepositCap() external view returns (uint256);\n\n    /**\n     * @param account The account to retrieve net deposits for\n     * @return The net total amount of Base Token deposited by a user\n     */\n    function getNetDeposit(address account) external view returns (uint256);\n\n    /**\n     * @notice Returns whether the contract is allowed to record deposits and\n     * withdrawals.\n     * @param hook The contract to retrieve allowed status for\n     * @return Whether the contract is allowed\n     */\n    function isHookAllowed(address hook) external view returns (bool);\n}\n"
    },
    "contracts/core/WithdrawHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\nimport \"./interfaces/IHook.sol\";\nimport \"./interfaces/ICollateralDepositRecord.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\npragma solidity =0.8.7;\n\ncontract WithdrawHook is IHook, Ownable {\n    address private _vault;\n    ICollateralDepositRecord private _depositRecord;\n\n    constructor(address _newDepositRecord) {\n        _depositRecord = ICollateralDepositRecord(_newDepositRecord);\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    function hook(\n        address _sender,\n        uint256 _initialAmount,\n        uint256 _finalAmount\n    ) external override onlyVault {\n        _depositRecord.recordWithdrawal(_sender, _finalAmount);\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function getVault() external view returns (address) {\n        return _vault;\n    }\n\n    function getDepositRecord()\n        external\n        view\n        returns (ICollateralDepositRecord)\n    {\n        return _depositRecord;\n    }\n}\n"
    },
    "contracts/core/CollateralDepositRecord.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\nimport \"./interfaces/ICollateralDepositRecord.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\npragma solidity =0.8.7;\n\ncontract CollateralDepositRecord is ICollateralDepositRecord, Ownable {\n    uint256 private _globalDepositCap;\n    uint256 private _globalDepositAmount;\n    uint256 private _accountDepositCap;\n    mapping(address => uint256) private _accountToNetDeposit;\n    mapping(address => bool) private _allowedHooks;\n    mapping(address => bool) private _devAccounts; // Testnet purposes only\n\n    modifier onlyAllowedHooks() {\n        require(_allowedHooks[msg.sender], \"Caller not allowed\");\n        _;\n    }\n\n    constructor(uint256 _newGlobalDepositCap, uint256 _newAccountDepositCap) {\n        _globalDepositCap = _newGlobalDepositCap;\n        _accountDepositCap = _newAccountDepositCap;\n    }\n\n    function recordDeposit(address _sender, uint256 _amount)\n        external\n        override\n        onlyAllowedHooks\n    {\n        require(\n            _amount + _globalDepositAmount <= _globalDepositCap,\n            \"Global deposit cap exceeded\"\n        );\n        // Ignore account deposit cap for devs\n        if (!_devAccounts[_sender]) {\n            require(\n                _amount + _accountToNetDeposit[_sender] <= _accountDepositCap,\n                \"Account deposit cap exceeded\"\n            );\n            _accountToNetDeposit[_sender] += _amount;\n        }\n        _globalDepositAmount += _amount;\n    }\n\n    function recordWithdrawal(address _sender, uint256 _amount)\n        external\n        override\n        onlyAllowedHooks\n    {\n        if (_globalDepositAmount > _amount) {\n            _globalDepositAmount -= _amount;\n        } else {\n            _globalDepositAmount = 0;\n        }\n        if (_accountToNetDeposit[_sender] > _amount) {\n            _accountToNetDeposit[_sender] -= _amount;\n        } else {\n            _accountToNetDeposit[_sender] = 0;\n        }\n    }\n\n    // Testnet purposes only\n    function setGlobalDepositAmount(uint256 _newGlobalDepositAmount)\n        external\n        onlyOwner\n    {\n        _globalDepositAmount = _newGlobalDepositAmount;\n    }\n\n    function setGlobalDepositCap(uint256 _newGlobalDepositCap)\n        external\n        override\n        onlyOwner\n    {\n        _globalDepositCap = _newGlobalDepositCap;\n        emit GlobalDepositCapChanged(_globalDepositCap);\n    }\n\n    function setAccountDepositCap(uint256 _newAccountDepositCap)\n        external\n        override\n        onlyOwner\n    {\n        _accountDepositCap = _newAccountDepositCap;\n        emit AccountDepositCapChanged(_newAccountDepositCap);\n    }\n\n    function setAllowedHook(address _hook, bool _allowed)\n        external\n        override\n        onlyOwner\n    {\n        _allowedHooks[_hook] = _allowed;\n        emit AllowedHooksChanged(_hook, _allowed);\n    }\n\n    // Testnet purposes only\n    function setDevAccount(address _account, bool _dev) external onlyOwner {\n        _devAccounts[_account] = _dev;\n    }\n\n    function getGlobalDepositCap() external view override returns (uint256) {\n        return _globalDepositCap;\n    }\n\n    function getGlobalDepositAmount()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _globalDepositAmount;\n    }\n\n    function getAccountDepositCap() external view override returns (uint256) {\n        return _accountDepositCap;\n    }\n\n    function getNetDeposit(address _account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _accountToNetDeposit[_account];\n    }\n\n    function isHookAllowed(address _hook)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _allowedHooks[_hook];\n    }\n}\n"
    },
    "contracts/core/interfaces/ICollateral.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./IHook.sol\";\nimport \"./IStrategyController.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @notice Used for minting and redeeming prePO Collateral tokens. A\n * Collateral token is a share of a yield-bearing vault, its Base Token value\n * varying based on the current value of the vault's assets.\n */\ninterface ICollateral is IERC20Upgradeable {\n    /**\n     * @notice Used to keep track of whether or not a user has initiated a\n     * withdrawal in a block prior to calling withdraw().\n     * @member amount The requested amount of Collateral to withdraw.\n     * @member blockNumber The block in which the request was made.\n     */\n    struct WithdrawalRequest {\n        uint256 amount;\n        uint256 blockNumber;\n    }\n\n    /// @dev Emitted via `setName()`.\n    /// @param name Token name\n    event NameChanged(string name);\n\n    /// @dev Emitted via `setSymbol()`.\n    /// @param symbol Token symbol\n    event SymbolChanged(string symbol);\n\n    /// @dev Emitted via `setDepositsAllowed()`.\n    /// @param allowed Whether deposits are allowed\n    event DepositsAllowedChanged(bool allowed);\n\n    /// @dev Emitted via `setWithdrawalsAllowed()`.\n    /// @param allowed Whether withdrawals are allowed\n    event WithdrawalsAllowedChanged(bool allowed);\n\n    /// @dev Emitted via `setStrategyController()`.\n    /// @param controller The address of the new Strategy Controller\n    event StrategyControllerChanged(address controller);\n\n    /// @dev Emitted via `setMintingFee()`.\n    /// @param fee The new fee\n    event MintingFeeChanged(uint256 fee);\n\n    /// @dev Emitted via `setRedemptionFee()`.\n    /// @param fee The new fee\n    event RedemptionFeeChanged(uint256 fee);\n\n    /// @dev Emitted via `setDelayedWithdrawal()`.\n    /// @param enabled Whether or not delayed withdrawals are enabled\n    event DelayedWithdrawalChanged(bool enabled);\n\n    /// @dev Emitted via `setDelayedWithdrawalExpiry()`.\n    /// @param expiry The new expiry\n    event DelayedWithdrawalExpiryChanged(uint256 expiry);\n\n    /// @dev Emitted via `setDepositHook()`.\n    /// @param hook The new deposit hook\n    event DepositHookChanged(address hook);\n\n    /// @dev Emitted via `setWithdrawalHook()`.\n    /// @param hook The new withdraw hook\n    event WithdrawHookChanged(address hook);\n\n    /**\n     * @notice Mints Collateral tokens for `amount` Base Token.\n     * @dev Assumes approval has been given by the user for the\n     * Collateral contract to spend their funds.\n     * @param amount The amount of Base Token to deposit\n     * @return The amount of Collateral minted\n     */\n    function deposit(uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Creates a request to allow a withdrawal for `amount` Collateral\n     * in a later block.\n     * @dev The user's balance must be >= the amount requested to\n     * initiate a withdrawal. If this function is called when there is already\n     * an existing withdrawal request, the existing request is overwritten\n     * with the new `amount` and current block number.\n     * @param amount The amount of Collateral to withdraw\n     */\n    function initiateWithdrawal(uint256 amount) external;\n\n    /**\n     * @notice Resets the existing withdrawal request on record for the caller.\n     * @dev This call will not revert if a user doesn't have an existing\n     * request and will simply reset the user's already empty request record.\n     */\n    function uninitiateWithdrawal() external;\n\n    /**\n     * @notice Burns `amount` Collateral tokens in exchange for Base Token.\n     * @dev If `delayedWithdrawalExpiry` is non-zero, a withdrawal request\n     * must be initiated in a prior block no more than\n     * `delayedWithdrawalExpiry` blocks before. The amount specified in the\n     * request must match the amount being withdrawn.\n     * @param amount The amount of Collateral to burn\n     * @return Amount of Base Token withdrawn\n     */\n    function withdraw(uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Sets whether deposits to the Collateral vault are allowed.\n     * @dev Only callable by `owner()`.\n     * @param allowed Whether deposits are allowed\n     */\n    function setDepositsAllowed(bool allowed) external;\n\n    /**\n     * @notice Sets whether withdrawals from the Collateral vault are allowed.\n     * @dev Only callable by `owner()`.\n     * @param allowed Whether withdrawals are allowed\n     */\n    function setWithdrawalsAllowed(bool allowed) external;\n\n    /**\n     * @notice Sets the contract that controls which strategy funds are sent\n     * to.\n     * @dev Only callable by `owner()`.\n     * @param newController Address of a contract implementing `IStrategyController`\n     */\n    function setStrategyController(IStrategyController newController) external;\n\n    /**\n     * @notice Sets the number of blocks to pass before expiring a withdrawal\n     * request.\n     * @dev If this is set to zero, withdrawal requests are ignored.\n     *\n     * Only callable by `owner()`.\n     * @param expiry Blocks before expiring a withdrawal request\n     */\n    function setDelayedWithdrawalExpiry(uint256 expiry) external;\n\n    /**\n     * @notice Sets the fee for minting Collateral, must be a 4 decimal place\n     * percentage value e.g. 4.9999% = 49999.\n     * @dev Only callable by `owner()`.\n     * @param newMintingFee The new fee for minting Collateral\n     */\n    function setMintingFee(uint256 newMintingFee) external;\n\n    /**\n     * @notice Sets the fee for redeeming Collateral, must be a 4 decimal place\n     * percentage value e.g. 4.9999% = 49999.\n     * @dev Only callable by `owner()`.\n     * @param newRedemptionFee The new fee for redeeming Collateral\n     */\n    function setRedemptionFee(uint256 newRedemptionFee) external;\n\n    /**\n     * @notice Sets the contract implementing `IHook` that will be called\n     * during the `deposit()` function.\n     * @dev Only callable by `owner()`.\n     * @param newDepositHook Address of a contract implementing `IHook`\n     */\n    function setDepositHook(IHook newDepositHook) external;\n\n    /**\n     * @notice Sets the contract implementing `IHook` that will be called\n     * during the `withdraw()` function.\n     * @dev Only callable by `owner()`.\n     * @param newWithdrawHook Address of a contract implementing `IHook`\n     */\n    function setWithdrawHook(IHook newWithdrawHook) external;\n\n    /// @return Whether deposits are allowed\n    function getDepositsAllowed() external view returns (bool);\n\n    /// @return Whether withdrawals are allowed\n    function getWithdrawalsAllowed() external view returns (bool);\n\n    /// @return Address where fees are sent to\n    function getTreasury() external view returns (address);\n\n    /**\n     * @return Fee for minting Collateral\n     * @dev Fee has four decimals places of percentage value precision\n     * e.g. 4.9999% = 49999.\n     */\n    function getMintingFee() external view returns (uint256);\n\n    /**\n     * @return Fee for redeeming Collateral\n     * @dev Fee has four decimals places of percentage value precision\n     * e.g. 4.9999% = 49999.\n     */\n    function getRedemptionFee() external view returns (uint256);\n\n    /**\n     * @notice This asset will be required for minting Collateral, and\n     * returned when redeeming Collateral.\n     * @return The ERC20 token backing Collateral shares\n     */\n    function getBaseToken() external view returns (IERC20Upgradeable);\n\n    /**\n     * @notice The Strategy Controller intermediates any interactions between\n     * this vault and a yield-earning strategy.\n     * @return The current Strategy Controller\n     */\n    function getStrategyController()\n        external\n        view\n        returns (IStrategyController);\n\n    /**\n     * @return Blocks that can pass before a withdrawal request expires\n     */\n    function getDelayedWithdrawalExpiry() external view returns (uint256);\n\n    /// @return The withdrawal request on record for `account`\n    function getWithdrawalRequest(address account)\n        external\n        view\n        returns (WithdrawalRequest memory);\n\n    /**\n     * @return The `IHook` that runs during the `deposit()` function\n     */\n    function getDepositHook() external view returns (IHook);\n\n    /**\n     * @return The `IHook` that runs during the `withdraw()` function\n     */\n    function getWithdrawHook() external view returns (IHook);\n\n    /**\n     * @notice Gets the amount of Base Token received for redeeming `shares`\n     * Collateral.\n     * @param shares Amount of shares that would be redeemed\n     * @return Amount of Base Token received\n     */\n    function getAmountForShares(uint256 shares)\n        external\n        view\n        returns (uint256);\n\n    /// @param amount Amount of Base Token that would be deposited\n    /// @return Shares received for depositing `amount` Base Token\n    function getSharesForAmount(uint256 amount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the sum of the contract's latent Base Token balance and\n     * the estimated Base Token value of the strategy's assets.\n     * @dev This call relies on the `totalValue()` returned by the\n     * Strategy Controller. The Collateral vault trusts the Strategy Controller\n     * to relay an accurate value of the Strategy's assets.\n     * @return Total assets denominated in Base Token\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Returns the denominator for calculating fees from 4 decimal\n     * place percentage values e.g. 4.9999% = 49999.\n     * @return Denominator\n     */\n    function getFeeDenominator() external pure returns (uint256);\n\n    /**\n     * @notice Returns the fee limit of 5% represented as 4 decimal place\n     * percentage value e.g. 4.9999% = 49999.\n     * @return Fee limit\n     */\n    function getFeeLimit() external pure returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IStrategyController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./IStrategy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Strategy Controller acts as an intermediary between the Strategy\n * and the PrePO Collateral contract.\n *\n * The Collateral contract should never interact with the Strategy directly\n * and only perform operations via the Strategy Controller.\n */\ninterface IStrategyController {\n    /// @dev Emitted via `setVault()`.\n    /// @param vault The new vault address\n    event VaultChanged(address vault);\n\n    /// @dev Emitted via `migrate()`.\n    /// @param oldStrategy The old strategy address\n    /// @param newStrategy The new strategy address\n    /// @param amount The amount migrated\n    event StrategyMigrated(\n        address oldStrategy,\n        address newStrategy,\n        uint256 amount\n    );\n\n    /**\n     * @notice Deposits the specified amount of Base Token into the Strategy.\n     * @dev Only the vault (Collateral contract) may call this function.\n     *\n     * Assumes approval to transfer amount from the Collateral contract\n     * has been given.\n     * @param amount Amount of Base Token to deposit\n     */\n    function deposit(uint256 amount) external;\n\n    /**\n     * @notice Withdraws the requested amount of Base Token from the Strategy\n     * to the recipient.\n     * @dev Only the vault (Collateral contract) may call this function.\n     *\n     * This withdrawal is optimistic, returned amount might be less than\n     * the amount specified.\n     * @param amount Amount of Base Token to withdraw\n     * @param recipient Address to receive the Base Token\n     */\n    function withdraw(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Migrates funds from currently configured Strategy to a new\n     * Strategy and replaces it.\n     * @dev If a Strategy is not already set, it sets the Controller's\n     * Strategy to the new value with no funds being exchanged.\n     *\n     * Gives infinite Base Token approval to the new strategy and sets it\n     * to zero for the old one.\n     *\n     * Only callable by `owner()`.\n     * @param newStrategy Address of the new Strategy\n     */\n    function migrate(IStrategy newStrategy) external;\n\n    /**\n     * @notice Sets the vault that is allowed to deposit/withdraw through this\n     * StrategyController.\n     * @dev Only callable by `owner()`.\n     * @param newVault Address of the new vault\n     */\n    function setVault(address newVault) external;\n\n    /**\n     * @notice Returns the Base Token balance of this contract and the\n     * `totalValue()` returned by the Strategy.\n     * @return The total value of assets within the strategy\n     */\n    function totalValue() external view returns (uint256);\n\n    /**\n     * @notice Returns the vault that is allowed to deposit/withdraw through\n     * this Strategy Controller.\n     * @return The vault address\n     */\n    function getVault() external view returns (address);\n\n    /**\n     * @notice Returns the ERC20 asset that this Strategy Controller supports\n     * handling funds with.\n     * @return The Base Token address\n     */\n    function getBaseToken() external view returns (IERC20);\n\n    /**\n     * @return The Strategy that this Strategy Controller manages\n     */\n    function getStrategy() external view returns (IStrategy);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/core/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Strategy that deploys Base Token to earn yield denominated in Base\n * Token.\n * @dev `owner()` can call emergency functions and setters, only controller\n * can call deposit/withdraw.\n */\ninterface IStrategy {\n    /**\n     * @notice Deposits `amount` Base Token into the strategy.\n     * @dev Assumes the StrategyController has given infinite spend approval\n     * to the strategy.\n     * @param amount Amount of Base Token to deposit\n     */\n    function deposit(uint256 amount) external;\n\n    /**\n     * @notice Withdraws `amount` Base Token from the strategy to `recipient`.\n     * @dev This withdrawal is optimistic, returned amount might be less than\n     * the amount specified.\n     * @param recipient Address to receive the Base Token\n     * @param amount Amount of Base Token to withdraw\n     */\n    function withdraw(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Returns the Base Token balance of this contract and\n     * the estimated value of deployed assets.\n     * @return Total value of assets within the strategy\n     */\n    function totalValue() external view returns (uint256);\n\n    /**\n     * @notice Returns the Strategy Controller that intermediates interactions\n     * between a vault and this strategy.\n     * @dev Functions with the `onlyController` modifier can only be called by\n     * this Strategy Controller.\n     * @return The Strategy Controller address\n     */\n    function getController() external view returns (IStrategyController);\n\n    /**\n     * @notice The ERC20 asset that this strategy utilizes to earn yield and\n     * return profits with.\n     * @return The Base Token address\n     */\n    function getBaseToken() external view returns (IERC20);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract MulticallUpgradeable is Initializable {\n    function __Multicall_init() internal initializer {\n        __Multicall_init_unchained();\n    }\n\n    function __Multicall_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/core/PrePOMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./LongShortToken.sol\";\nimport \"./PrePOMarket.sol\";\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IPrePOMarketFactory.sol\";\n\ncontract PrePOMarketFactory is\n    IPrePOMarketFactory,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    mapping(address => bool) private _validCollateral;\n    mapping(bytes32 => address) private _deployedMarkets;\n\n    function initialize() public initializer {\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    function isCollateralValid(address _collateral)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _validCollateral[_collateral];\n    }\n\n    function getMarket(bytes32 _longShortHash)\n        external\n        view\n        override\n        returns (IPrePOMarket)\n    {\n        return IPrePOMarket(_deployedMarkets[_longShortHash]);\n    }\n\n    function createMarket(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix,\n        address _governance,\n        address _collateral,\n        uint256 _floorLongPrice,\n        uint256 _ceilingLongPrice,\n        uint256 _floorValuation,\n        uint256 _ceilingValuation,\n        uint256 _mintingFee,\n        uint256 _redemptionFee,\n        uint256 _expiryTime\n    ) external override onlyOwner nonReentrant {\n        require(_validCollateral[_collateral], \"Invalid collateral\");\n\n        (\n            LongShortToken _longToken,\n            LongShortToken _shortToken\n        ) = _createPairTokens(_tokenNameSuffix, _tokenSymbolSuffix);\n        bytes32 _salt = keccak256(abi.encodePacked(_longToken, _shortToken));\n\n        PrePOMarket _newMarket = new PrePOMarket{salt: _salt}(\n            _governance,\n            _collateral,\n            ILongShortToken(address(_longToken)),\n            ILongShortToken(address(_shortToken)),\n            _floorLongPrice,\n            _ceilingLongPrice,\n            _floorValuation,\n            _ceilingValuation,\n            _mintingFee,\n            _redemptionFee,\n            _expiryTime,\n            false\n        );\n        _deployedMarkets[_salt] = address(_newMarket);\n\n        _longToken.transferOwnership(address(_newMarket));\n        _shortToken.transferOwnership(address(_newMarket));\n        emit MarketAdded(address(_newMarket), _salt);\n    }\n\n    function setCollateralValidity(address _collateral, bool _validity)\n        external\n        override\n        onlyOwner\n    {\n        _validCollateral[_collateral] = _validity;\n        emit CollateralValidityChanged(_collateral, _validity);\n    }\n\n    function _createPairTokens(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix\n    )\n        internal\n        returns (LongShortToken _newLongToken, LongShortToken _newShortToken)\n    {\n        string memory _longTokenName = string(\n            abi.encodePacked(\"LONG\", \" \", _tokenNameSuffix)\n        );\n        string memory _shortTokenName = string(\n            abi.encodePacked(\"SHORT\", \" \", _tokenNameSuffix)\n        );\n        string memory _longTokenSymbol = string(\n            abi.encodePacked(\"L\", \"_\", _tokenSymbolSuffix)\n        );\n        string memory _shortTokenSymbol = string(\n            abi.encodePacked(\"S\", \"_\", _tokenSymbolSuffix)\n        );\n        _newLongToken = new LongShortToken(_longTokenName, _longTokenSymbol);\n        _newShortToken = new LongShortToken(\n            _shortTokenName,\n            _shortTokenSymbol\n        );\n        return (_newLongToken, _newShortToken);\n    }\n}\n"
    },
    "contracts/core/LongShortToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract LongShortToken is ERC20Burnable, Ownable {\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}\n\n    function mint(address _recipient, uint256 _amount) external onlyOwner {\n        _mint(_recipient, _amount);\n    }\n}\n"
    },
    "contracts/core/PrePOMarket.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"./interfaces/IPrePOMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {\n    address private _treasury;\n\n    IERC20 private immutable _collateral;\n    ILongShortToken private immutable _longToken;\n    ILongShortToken private immutable _shortToken;\n\n    uint256 private immutable _floorLongPrice;\n    uint256 private immutable _ceilingLongPrice;\n    uint256 private _finalLongPrice;\n\n    uint256 private immutable _floorValuation;\n    uint256 private immutable _ceilingValuation;\n\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n\n    uint256 private immutable _expiryTime;\n\n    bool private _publicMinting;\n\n    uint256 private constant MAX_PRICE = 1e18;\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    /**\n     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are\n     * valid, since they will be handled by the PrePOMarketFactory. The\n     * treasury is initialized to governance due to stack limitations.\n     *\n     * Assumes that ownership of `_longToken` and `_shortToken` has been\n     * transferred to this contract via `createMarket()` in\n     * `PrePOMarketFactory.sol`.\n     */\n    constructor(\n        address _governance,\n        address _newCollateral,\n        ILongShortToken _newLongToken,\n        ILongShortToken _newShortToken,\n        uint256 _newFloorLongPrice,\n        uint256 _newCeilingLongPrice,\n        uint256 _newFloorValuation,\n        uint256 _newCeilingValuation,\n        uint256 _newMintingFee,\n        uint256 _newRedemptionFee,\n        uint256 _newExpiryTime,\n        bool _allowed\n    ) {\n        require(\n            _newCeilingLongPrice > _newFloorLongPrice,\n            \"Ceiling must exceed floor\"\n        );\n        require(_newExpiryTime > block.timestamp, \"Invalid expiry\");\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newCeilingLongPrice <= MAX_PRICE, \"Ceiling cannot exceed 1\");\n\n        transferOwnership(_governance);\n        _treasury = _governance;\n\n        _collateral = IERC20(_newCollateral);\n        _longToken = _newLongToken;\n        _shortToken = _newShortToken;\n\n        _floorLongPrice = _newFloorLongPrice;\n        _ceilingLongPrice = _newCeilingLongPrice;\n        _finalLongPrice = MAX_PRICE + 1;\n\n        _floorValuation = _newFloorValuation;\n        _ceilingValuation = _newCeilingValuation;\n\n        _mintingFee = _newMintingFee;\n        _redemptionFee = _newRedemptionFee;\n\n        _expiryTime = _newExpiryTime;\n\n        _publicMinting = _allowed;\n\n        emit MarketCreated(\n            address(_newLongToken),\n            address(_newShortToken),\n            _newFloorLongPrice,\n            _newCeilingLongPrice,\n            _newFloorValuation,\n            _newCeilingValuation,\n            _newMintingFee,\n            _newRedemptionFee,\n            _newExpiryTime\n        );\n    }\n\n    function mintLongShortTokens(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (msg.sender != owner()) {\n            require(_publicMinting, \"Public minting disabled\");\n        }\n        require(_finalLongPrice > MAX_PRICE, \"Market ended\");\n        require(\n            _collateral.balanceOf(msg.sender) >= _amount,\n            \"Insufficient collateral\"\n        );\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is minting\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amount > _fee, \"Minting amount too small\");\n        _collateral.transferFrom(msg.sender, _treasury, _fee);\n        unchecked {\n            _amount -= _fee;\n        }\n        _collateral.transferFrom(msg.sender, address(this), _amount);\n        _longToken.mint(msg.sender, _amount);\n        _shortToken.mint(msg.sender, _amount);\n        emit Mint(msg.sender, _amount);\n        return _amount;\n    }\n\n    function redeem(uint256 _longAmount, uint256 _shortAmount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _longToken.balanceOf(msg.sender) >= _longAmount,\n            \"Insufficient long tokens\"\n        );\n        require(\n            _shortToken.balanceOf(msg.sender) >= _shortAmount,\n            \"Insufficient short tokens\"\n        );\n\n        uint256 _collateralOwed;\n        if (_finalLongPrice <= MAX_PRICE) {\n            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;\n            _collateralOwed =\n                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /\n                MAX_PRICE;\n        } else {\n            require(\n                _longAmount == _shortAmount,\n                \"Long and Short must be equal\"\n            );\n            _collateralOwed = _longAmount;\n        }\n\n        _longToken.burnFrom(msg.sender, _longAmount);\n        _shortToken.burnFrom(msg.sender, _shortAmount);\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is redeeming\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_collateralOwed * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_collateralOwed > _fee, \"Redemption amount too small\");\n        _collateral.transfer(_treasury, _fee);\n        unchecked {\n            _collateralOwed -= _fee;\n        }\n        _collateral.transfer(msg.sender, _collateralOwed);\n\n        emit Redemption(msg.sender, _collateralOwed);\n    }\n\n    function setTreasury(address _newTreasury) external override onlyOwner {\n        _treasury = _newTreasury;\n        emit TreasuryChanged(_newTreasury);\n    }\n\n    function setFinalLongPrice(uint256 _newFinalLongPrice)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _newFinalLongPrice >= _floorLongPrice,\n            \"Price cannot be below floor\"\n        );\n        require(\n            _newFinalLongPrice <= _ceilingLongPrice,\n            \"Price cannot exceed ceiling\"\n        );\n        _finalLongPrice = _newFinalLongPrice;\n        emit FinalLongPriceSet(_newFinalLongPrice);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_newMintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_newRedemptionFee);\n    }\n\n    function setPublicMinting(bool _allowed) external override onlyOwner {\n        _publicMinting = _allowed;\n        emit PublicMintingChanged(_allowed);\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getCollateral() external view override returns (IERC20) {\n        return _collateral;\n    }\n\n    function getLongToken() external view override returns (ILongShortToken) {\n        return _longToken;\n    }\n\n    function getShortToken() external view override returns (ILongShortToken) {\n        return _shortToken;\n    }\n\n    function getFloorLongPrice() external view override returns (uint256) {\n        return _floorLongPrice;\n    }\n\n    function getCeilingLongPrice() external view override returns (uint256) {\n        return _ceilingLongPrice;\n    }\n\n    function getFinalLongPrice() external view override returns (uint256) {\n        return _finalLongPrice;\n    }\n\n    function getFloorValuation() external view override returns (uint256) {\n        return _floorValuation;\n    }\n\n    function getCeilingValuation() external view override returns (uint256) {\n        return _ceilingValuation;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getExpiryTime() external view override returns (uint256) {\n        return _expiryTime;\n    }\n\n    function isPublicMintingAllowed() external view override returns (bool) {\n        return _publicMinting;\n    }\n\n    function getMaxPrice() external pure override returns (uint256) {\n        return MAX_PRICE;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n}\n"
    },
    "contracts/core/interfaces/ILongShortToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice LongShortToken contract representing PrePOMarket positions.\n *\n * The token can represent either a Long or Short position for the\n * PrePOMarket it belongs to.\n */\ninterface ILongShortToken is IERC20 {\n    /**\n     * @dev Inherited from OpenZeppelin Ownable.\n     * @return Address of the current owner\n     */\n    function owner() external returns (address);\n\n    /**\n     * @notice Mints `amount` tokens to `recipient`. Allows PrePOMarket to mint\n     * positions for users.\n     * @dev Only callable by `owner()` (should be PrePOMarket).\n     * @param recipient Address of the recipient\n     * @param amount Amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Destroys `amount` tokens from `account`, deducting from the\n     * caller's allowance.\n     * @dev Inherited from OpenZeppelin ERC20Burnable.\n     * @param account Address of the account to destroy tokens from\n     * @param amount Amount of tokens to destroy\n     */\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/core/interfaces/IPrePOMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./IPrePOMarket.sol\";\n\n/**\n * @notice Deploys a PrePOMarket and two LongShortToken contracts to serve as\n * the token pair.\n */\ninterface IPrePOMarketFactory {\n    /// @dev Emitted via `setCollateralValidity()`.\n    /// @param collateral the collateral changed\n    /// @param allowed whether the collateral is valid\n    event CollateralValidityChanged(address collateral, bool allowed);\n\n    /// @dev Emitted via `createMarket()`.\n    /// @param market The market created\n    /// @param longShortHash The market unique id\n    event MarketAdded(address market, bytes32 longShortHash);\n\n    /**\n     * @notice Deploys a PrePOMarket with the given parameters and two\n     * LongShortToken contracts to serve as the token pair.\n     * @dev Parameters are all passed along to their respective arguments\n     * in the PrePOMarket constructor.\n     *\n     * Token names are generated from `tokenNameSuffix` as the name\n     * suffix and `tokenSymbolSuffix` as the symbol suffix.\n     *\n     * \"LONG \"/\"SHORT \" are appended to respective names, \"L_\"/\"S_\" are\n     * appended to respective symbols.\n     *\n     * e.g. preSTRIPE 100-200 30-September 2021 =>\n     * LONG preSTRIPE 100-200 30-September-2021.\n     *\n     * e.g. preSTRIPE_100-200_30SEP21 => L_preSTRIPE_100-200_30SEP21.\n     * @param tokenNameSuffix The name suffix for the token pair\n     * @param tokenSymbolSuffix The symbol suffix for the token pair\n     * @param collateral The address of the collateral token\n     * @param governance The address of the governance contract\n     * @param floorLongPrice The floor price for the Long token\n     * @param ceilingLongPrice The ceiling price for the Long token\n     * @param floorValuation The floor valuation for the Market\n     * @param ceilingValuation The ceiling valuation for the Market\n     * @param mintingFee The minting fee for Long/Short tokens\n     * @param redemptionFee The redemption fee for Long/Short tokens\n     * @param expiryTime The expiry time for the Market\n     */\n    function createMarket(\n        string memory tokenNameSuffix,\n        string memory tokenSymbolSuffix,\n        address collateral,\n        address governance,\n        uint256 floorLongPrice,\n        uint256 ceilingLongPrice,\n        uint256 floorValuation,\n        uint256 ceilingValuation,\n        uint256 mintingFee,\n        uint256 redemptionFee,\n        uint256 expiryTime\n    ) external;\n\n    /**\n     * @notice Sets whether a collateral contract is valid for assignment to\n     * new PrePOMarkets.\n     * @param collateral The address of the collateral contract\n     * @param validity Whether the collateral contract should be valid\n     */\n    function setCollateralValidity(address collateral, bool validity) external;\n\n    /**\n     * @notice Returns whether collateral contract is valid for assignment to\n     * new PrePOMarkets.\n     * @param collateral The address of the collateral contract\n     * @return Whether the collateral contract is valid\n     */\n    function isCollateralValid(address collateral)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev `longShortHash` is a keccak256 hash of the long token address and\n     * short token address of the PrePOMarket.\n     * @param longShortHash PrePOMarket unique identifier\n     * @return PrePOMarket address corresponding to the market id\n     */\n    function getMarket(bytes32 longShortHash)\n        external\n        view\n        returns (IPrePOMarket);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/core/interfaces/IPrePOMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.8.7;\n\nimport \"./ILongShortToken.sol\";\nimport \"./IStrategyController.sol\";\n\n/**\n * @notice Users can mint/redeem long/short positions on a specific asset in\n * exchange for Collateral tokens.\n * @dev Position settlement prices are bound by a floor and ceiling set\n * during market initialization.\n *\n * The value of a Long and Short token should always equal 1 Collateral.\n */\ninterface IPrePOMarket {\n    /// @dev Emitted via `constructor()`\n    /// @param longToken Market Long token address\n    /// @param shortToken Market Short token address\n    /// @param shortToken Market Short token address\n    /// @param floorLongPrice Long token price floor\n    /// @param ceilingLongPrice Long token price ceiling\n    /// @param floorValuation Market valuation floor\n    /// @param ceilingValuation Market valuation ceiling\n    /// @param mintingFee Market minting fee\n    /// @param redemptionFee Market redemption fee\n    /// @param expiryTime Market expiry time\n    event MarketCreated(\n        address longToken,\n        address shortToken,\n        uint256 floorLongPrice,\n        uint256 ceilingLongPrice,\n        uint256 floorValuation,\n        uint256 ceilingValuation,\n        uint256 mintingFee,\n        uint256 redemptionFee,\n        uint256 expiryTime\n    );\n\n    /// @dev Emitted via `mintLongShortTokens()`.\n    /// @param minter The address of the minter\n    /// @param amount The amount of Long/Short tokens minted\n    event Mint(address indexed minter, uint256 amount);\n\n    /// @dev Emitted via `redeem()`.\n    /// @param redeemer The address of the redeemer\n    /// @param amount The amount of Long/Short tokens redeemed\n    event Redemption(address indexed redeemer, uint256 amount);\n\n    /// @dev Emitted via `setTreasury()`.\n    /// @param treasury The new treasury address\n    event TreasuryChanged(address treasury);\n\n    /// @dev Emitted via `setFinalLongPrice()`.\n    /// @param price The final Long price\n    event FinalLongPriceSet(uint256 price);\n\n    /// @dev Emitted via `setMintingFee()`.\n    /// @param fee The new minting fee\n    event MintingFeeChanged(uint256 fee);\n\n    /// @dev Emitted via `setRedemptionFee()`.\n    /// @param fee The new redemption fee\n    event RedemptionFeeChanged(uint256 fee);\n\n    /// @dev Emitted via `setPublicMinting()`.\n    /// @param allowed The new public minting status\n    event PublicMintingChanged(bool allowed);\n\n    /**\n     * @notice Mints Long and Short tokens in exchange for `amount`\n     * Collateral.\n     * @dev Minting is not allowed after the market has ended.\n     *\n     * `owner()` may mint tokens before PublicMinting is enabled to\n     * bootstrap a market with an initial supply.\n     * @param amount Amount of Collateral to deposit\n     * @return Long/Short tokens minted\n     */\n    function mintLongShortTokens(uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Redeem `longAmount` Long and `shortAmount` Short tokens for\n     * Collateral.\n     * @dev Before the market ends, redemptions can only be done with equal\n     * parts N Long/Short tokens for N Collateral.\n     *\n     * After the market has ended, users can redeem any amount of\n     * Long/Short tokens for Collateral.\n     * @param longAmount Amount of Long tokens to redeem\n     * @param shortAmount Amount of Short tokens to redeem\n     */\n    function redeem(uint256 longAmount, uint256 shortAmount) external;\n\n    /**\n     * @notice Sets the treasury address minting/redemption fees are sent to.\n     * @dev Only callable by `owner()`.\n     * @param newTreasury New treasury address\n     */\n    function setTreasury(address newTreasury) external;\n\n    /**\n     * @notice Sets the price a Long token can be redeemed for after the\n     * market has ended (in wei units of Collateral).\n     * @dev The contract initializes this to > MAX_PRICE and knows the market\n     * has ended when it is set to <= MAX_PRICE.\n     *\n     * Only callable by `owner()`.\n     * @param newFinalLongPrice Price to set Long token redemptions\n     */\n    function setFinalLongPrice(uint256 newFinalLongPrice) external;\n\n    /**\n     * @notice Sets the fee for minting Long/Short tokens, must be a 4\n     * decimal place percentage value e.g. 4.9999% = 49999.\n     * @dev Only callable by `owner()`.\n     * @param newMintingFee New minting fee\n     */\n    function setMintingFee(uint256 newMintingFee) external;\n\n    /**\n     * @notice Sets the fee for redeeming Long/Short tokens, must be a 4\n     * decimal place percentage value e.g. 4.9999% = 49999.\n     * @dev Only callable by `owner()`.\n     * @param newRedemptionFee New redemption fee\n     */\n    function setRedemptionFee(uint256 newRedemptionFee) external;\n\n    /**\n     * @notice Sets whether or not everyone is allowed to mint Long/Short\n     * tokens.\n     * @dev Only callable by `owner()`.\n     * @param allowed Whether or not to allow everyone to mint Long/Short\n     */\n    function setPublicMinting(bool allowed) external;\n\n    /// @return Treasury address where minting/redemption fees are sent\n    function getTreasury() external view returns (address);\n\n    /// @return Collateral token used to fund Long/Short positions\n    function getCollateral() external view returns (IERC20);\n\n    /**\n     * @dev The PrePOMarket is the owner of this token contract.\n     * @return Long token for this market\n     */\n    function getLongToken() external view returns (ILongShortToken);\n\n    /**\n     * @dev The PrePOMarket is the owner of this token contract.\n     * @return Short token for this market\n     */\n    function getShortToken() external view returns (ILongShortToken);\n\n    /**\n     * @notice Returns the lower bound of what a Long token can be priced at\n     * (in wei units of Collateral).\n     * @dev Must be less than ceilingLongPrice and MAX_PRICE.\n     * @return Minimum Long token price\n     */\n    function getFloorLongPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns the upper bound of what a Long token can be priced at\n     * (in wei units of Collateral).\n     * @dev Must be less than MAX_PRICE.\n     * @return Maximum Long token price\n     */\n    function getCeilingLongPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns the price a Long token can be redeemed for after the\n     * market has ended (in wei units of Collateral).\n     * @dev The contract initializes this to > MAX_PRICE and knows the market\n     * has ended when it is set to <= MAX_PRICE.\n     * @return Final Long token price\n     */\n    function getFinalLongPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns valuation of a market when the price of a Long\n     * token is at the floor.\n     * @return Market valuation floor\n     */\n    function getFloorValuation() external view returns (uint256);\n\n    /**\n     * @notice Returns valuation of a market when the price of a Long\n     * token is at the ceiling.\n     * @return Market valuation ceiling\n     */\n    function getCeilingValuation() external view returns (uint256);\n\n    /**\n     * @notice Returns the fee for minting Long/Short tokens as a 4 decimal\n     * place percentage value e.g. 4.9999% = 49999.\n     * @return Minting fee\n     */\n    function getMintingFee() external view returns (uint256);\n\n    /**\n     * @notice Returns the fee for redeeming Long/Short tokens as a 4 decimal\n     * place percentage value e.g. 4.9999% = 49999.\n     * @return Redemption fee\n     */\n    function getRedemptionFee() external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp of when the market will expire.\n     * @return Market expiry timestamp\n     */\n    function getExpiryTime() external view returns (uint256);\n\n    /**\n     * @notice Returns whether Long/Short token minting is open to everyone.\n     * @dev If true, anyone can mint Long/Short tokens, if false, only\n     * `owner()` may mint.\n     * @return Whether or not public minting is allowed\n     */\n    function isPublicMintingAllowed() external view returns (bool);\n\n    /**\n     * @notice Long prices cannot exceed this value, equivalent to 1 ether\n     * unit of Collateral.\n     * @return Max Long token price\n     */\n    function getMaxPrice() external pure returns (uint256);\n\n    /**\n     * @notice Returns the denominator for calculating fees from 4 decimal\n     * place percentage values e.g. 4.9999% = 49999.\n     * @return Denominator for calculating fees\n     */\n    function getFeeDenominator() external pure returns (uint256);\n\n    /**\n     * @notice Fee limit of 5% represented as 4 decimal place percentage\n     * value e.g. 4.9999% = 49999.\n     * @return Fee limit\n     */\n    function getFeeLimit() external pure returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/core/SingleStrategyController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}\n"
    },
    "contracts/core/mocks/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"../interfaces/ILongShortToken.sol\";\nimport \"../interfaces/IStrategyController.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockStrategy is IStrategy, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IStrategyController private _controller;\n    /**\n     * This would be an IERC20 in a real strategy, but we are using\n     * ILongShortToken due to this being a mock strategy that needs\n     * to mint/burn its `_baseToken`\n     */\n    ILongShortToken private _baseToken;\n\n    /**\n     * This would not exist in an actual strategy since strategies are vault\n     * agnostic, only exists because we need to know vault shares supply to\n     * simulate a `totalValue()`\n     */\n    IERC20 public vault;\n    // Timestamp to denote when virtual yield can begin to accumulate\n    uint256 public beginning;\n    /**\n     * Integer percent APY for mock strategy, editable in case we need to\n     * modify later for testnet\n     */\n    uint256 public apy;\n    // Virtual value of a vault share is initialized to 1 `_baseToken`\n    uint256 public constant INITIAL_SHARE_VALUE = 1e18;\n\n    event VaultChanged(address vault);\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(_controller),\n            \"Caller is not the controller\"\n        );\n        _;\n    }\n\n    constructor(address _newController, address _newBaseToken) {\n        _controller = IStrategyController(_newController);\n        _baseToken = ILongShortToken(_newBaseToken);\n        beginning = block.timestamp;\n    }\n\n    /**\n     * `_baseToken` must blacklist users besides governance and controller\n     * from sending to this contract to prevent unwanted share inflation from\n     * users directly sending funds to the strategy\n     */\n    function deposit(uint256 _amount) external override onlyController {\n        uint256 _actualBalance = _baseToken.balanceOf(address(this));\n        uint256 _virtualBalance = _getVirtualBalance();\n        if (_actualBalance > 0) {\n            /**\n             * Bring `_baseToken` balance in line with our expected virtual\n             * balance, this is so that the difference in `totalValue()`\n             * before/after reflects the deposit amount\n             */\n            if (_virtualBalance > _actualBalance) {\n                /**\n                 * Mint tokens to bring `_baseToken` balance up to\n                 * `_virtualBalance` before deposit\n                 */\n                _baseToken.mint(\n                    address(this),\n                    _virtualBalance - _actualBalance\n                );\n            }\n        }\n        IERC20(_baseToken).safeTransferFrom(\n            address(_controller),\n            address(this),\n            _amount\n        );\n    }\n\n    /**\n     * We enforce `_baseToken` ownership here and not in the initializer since\n     * we would have to deterministically figure out strategy deployment\n     * address ahead of time\n     */\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyController\n    {\n        if (_amount > _baseToken.balanceOf(address(this))) {\n            uint256 _shortfall = _amount - _baseToken.balanceOf(address(this));\n            _baseToken.mint(address(this), _shortfall);\n        }\n        IERC20(_baseToken).safeTransfer(_recipient, _amount);\n    }\n\n    function setVault(IERC20 _newVault) external onlyOwner {\n        vault = _newVault;\n        emit VaultChanged(address(vault));\n    }\n\n    /**\n     * Initializes to current timestamp, changeable by governance if needed\n     * later\n     */\n    function setBeginning(uint256 _beginning) external onlyOwner {\n        beginning = _beginning;\n    }\n\n    /**\n     * Virtual APY yields will be calculated from the starting value of\n     * INITIAL_SHARE_VALUE\n     */\n    function setApy(uint256 _apy) external onlyOwner {\n        apy = _apy;\n    }\n\n    /**\n     * Virtual balance is the amount owed to all shareholders based on the\n     * current timestamp and virtual APY. This returns the actual `_baseToken`\n     * balance if it is greater than the `_virtualBalance`, which for this\n     * mock strategy, will always be when a user deposits funds prior to\n     * minting shares.\n     *\n     * After a user deposits funds via `deposit()`, `totalValue()`\n     * should return the `_actualBalance` to allow Collateral to determine how\n     * many shares to mint for a user. Once the shares are minted, the\n     * `_virtualBalance` will once again surpass the `_actualBalance`.\n     */\n    function totalValue() external view override returns (uint256) {\n        uint256 _actualBalance = _baseToken.balanceOf(address(this));\n        uint256 _virtualBalance = _getVirtualBalance();\n        if (_actualBalance > _virtualBalance) {\n            return _actualBalance;\n        } else {\n            return _virtualBalance;\n        }\n    }\n\n    function getController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _controller;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return IERC20(_baseToken);\n    }\n\n    function _getVirtualBalance() internal view returns (uint256) {\n        return\n            (vault.totalSupply() * _currentShareValue()) / INITIAL_SHARE_VALUE;\n    }\n\n    /**\n     * INITIAL_SHARE_VALUE is only being re-used here as a denominator for wei\n     * token math.\n     */\n    function _currentShareValue() internal view returns (uint256) {\n        uint256 _returnPerSecond = (INITIAL_SHARE_VALUE * apy) /\n            100 /\n            31536000;\n        uint256 _timeDeployed = block.timestamp - beginning;\n        return INITIAL_SHARE_VALUE + (_returnPerSecond * _timeDeployed);\n    }\n}\n"
    },
    "contracts/core/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockERC20 is ERC20, Ownable {\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}\n\n    function mint(address _recipient, uint256 _amount) external onlyOwner {\n        _mint(_recipient, _amount);\n    }\n}\n"
    },
    "contracts/core/mocks/MockBaseToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockBaseToken is ERC20, Ownable {\n    address private _mockStrategy;\n\n    constructor(string memory _newName, string memory _newSymbol)\n        ERC20(_newName, _newSymbol)\n    {}\n\n    modifier onlyMockStrategy() {\n        require(msg.sender == _mockStrategy, \"Caller is not MockStrategy\");\n        _;\n    }\n\n    function mint(address _recipient, uint256 _amount)\n        external\n        onlyMockStrategy\n    {\n        _mint(_recipient, _amount);\n    }\n\n    function ownerMint(uint256 _amount) external onlyOwner {\n        _mint(owner(), _amount);\n    }\n\n    function setMockStrategy(address _newMockStrategy) external onlyOwner {\n        _mockStrategy = _newMockStrategy;\n    }\n\n    function getMockStrategy() external view returns (address) {\n        return _mockStrategy;\n    }\n}\n"
    },
    "contracts/core/Collateral.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ICollateral.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"./interfaces/IHook.sol\";\nimport \"../ERC20UpgradeableRenameable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract Collateral is\n    ICollateral,\n    ERC20UpgradeableRenameable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bool private _depositsAllowed;\n    bool private _withdrawalsAllowed;\n    address private _treasury;\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n    IERC20Upgradeable private _baseToken;\n    IStrategyController private _strategyController;\n\n    uint256 private _delayedWithdrawalExpiry;\n    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n    IHook private _depositHook;\n    IHook private _withdrawHook;\n\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    function initialize(address _newBaseToken, address _newTreasury)\n        public\n        initializer\n    {\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(\n            string(\"prePO Collateral Token\"),\n            string(\"preCT\")\n        );\n        _baseToken = IERC20Upgradeable(_newBaseToken);\n        _treasury = _newTreasury;\n    }\n\n    function deposit(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_depositsAllowed, \"Deposits not allowed\");\n        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n        // Calculate fees and shares to mint including latent contract funds\n        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n        // Record deposit before fee is taken\n        if (address(_depositHook) != address(0)) {\n            _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n        }\n        /**\n         * Add 1 to avoid rounding to zero, only process deposit if user is\n         * depositing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amountToDeposit > _fee, \"Deposit amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        unchecked {\n            _amountToDeposit -= _fee;\n        }\n\n        uint256 _valueBefore = _strategyController.totalValue();\n        _baseToken.approve(address(_strategyController), _amountToDeposit);\n        _strategyController.deposit(_amountToDeposit);\n        uint256 _valueAfter = _strategyController.totalValue();\n        _amountToDeposit = _valueAfter - _valueBefore;\n\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amountToDeposit;\n        } else {\n            /**\n             * # of shares owed = amount deposited / cost per share, cost per\n             * share = total supply / total value.\n             */\n            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n        }\n        _mint(msg.sender, _shares);\n        return _shares;\n    }\n\n    function initiateWithdrawal(uint256 _amount) external override {\n        /**\n         * Checking the balance before initiation is necessary since a user\n         * could initiate an unlimited withdrawal amount ahead of time,\n         * negating the protection a delayed withdrawal offers.\n         */\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        _accountToWithdrawalRequest[msg.sender].amount = _amount;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n    }\n\n    function uninitiateWithdrawal() external override {\n        _accountToWithdrawalRequest[msg.sender].amount = 0;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n    }\n\n    function _processDelayedWithdrawal(address _account, uint256 _amount)\n        internal\n    {\n        /**\n         * Verify that the withdrawal being processed matches what was\n         * recorded during initiation.\n         */\n        require(\n            _accountToWithdrawalRequest[_account].amount == _amount,\n            \"Initiated amount does not match\"\n        );\n        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n            .blockNumber;\n        require(\n            _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n            \"Must withdraw before expiry\"\n        );\n        require(\n            block.number > _recordedBlock,\n            \"Must withdraw in a later block\"\n        );\n        // Reset the initiation prior to withdrawal.\n        _accountToWithdrawalRequest[_account].amount = 0;\n        _accountToWithdrawalRequest[_account].blockNumber = 0;\n    }\n\n    function withdraw(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n        if (_delayedWithdrawalExpiry != 0) {\n            _processDelayedWithdrawal(msg.sender, _amount);\n        }\n        uint256 _owed = (_strategyController.totalValue() * _amount) /\n            totalSupply();\n        _burn(msg.sender, _amount);\n\n        uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n        _strategyController.withdraw(address(this), _owed);\n        uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n        // Record withdrawal before fee is taken\n        if (address(_withdrawHook) != address(0)) {\n            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n        }\n\n        /**\n         * Send redemption fee to the protocol treasury. Add 1 to avoid\n         * rounding to zero, only process withdrawal if user is\n         * withdrawing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        unchecked {\n            _amountWithdrawn -= _fee;\n        }\n        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n        return _amountWithdrawn;\n    }\n\n    function setName(string memory _newName) external onlyOwner {\n        _name = _newName;\n        emit NameChanged(_newName);\n    }\n\n    function setSymbol(string memory _newSymbol) external onlyOwner {\n        _symbol = _newSymbol;\n        emit SymbolChanged(_newSymbol);\n    }\n\n    function setDepositsAllowed(bool _allowed) external override onlyOwner {\n        _depositsAllowed = _allowed;\n        emit DepositsAllowedChanged(_allowed);\n    }\n\n    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n        _withdrawalsAllowed = _allowed;\n        emit WithdrawalsAllowedChanged(_allowed);\n    }\n\n    function setStrategyController(IStrategyController _newStrategyController)\n        external\n        override\n        onlyOwner\n    {\n        _strategyController = _newStrategyController;\n        emit StrategyControllerChanged(address(_strategyController));\n    }\n\n    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n        external\n        override\n        onlyOwner\n    {\n        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_mintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_redemptionFee);\n    }\n\n    function setDepositHook(IHook _newDepositHook)\n        external\n        override\n        onlyOwner\n    {\n        _depositHook = _newDepositHook;\n        emit DepositHookChanged(address(_depositHook));\n    }\n\n    function setWithdrawHook(IHook _newWithdrawHook)\n        external\n        override\n        onlyOwner\n    {\n        _withdrawHook = _newWithdrawHook;\n        emit WithdrawHookChanged(address(_withdrawHook));\n    }\n\n    function getDepositsAllowed() external view override returns (bool) {\n        return _depositsAllowed;\n    }\n\n    function getWithdrawalsAllowed() external view override returns (bool) {\n        return _withdrawalsAllowed;\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getBaseToken()\n        external\n        view\n        override\n        returns (IERC20Upgradeable)\n    {\n        return _baseToken;\n    }\n\n    function getStrategyController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _strategyController;\n    }\n\n    function getDelayedWithdrawalExpiry()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _delayedWithdrawalExpiry;\n    }\n\n    function getWithdrawalRequest(address _account)\n        external\n        view\n        override\n        returns (WithdrawalRequest memory)\n    {\n        return _accountToWithdrawalRequest[_account];\n    }\n\n    function getDepositHook() external view override returns (IHook) {\n        return _depositHook;\n    }\n\n    function getWithdrawHook() external view override returns (IHook) {\n        return _withdrawHook;\n    }\n\n    function getAmountForShares(uint256 _shares)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return _shares;\n        }\n        return (_shares * totalAssets()) / totalSupply();\n    }\n\n    function getSharesForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _totalAssets = totalAssets();\n        return\n            (_totalAssets > 0)\n                ? ((_amount * totalSupply()) / _totalAssets)\n                : 0;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return\n            _baseToken.balanceOf(address(this)) +\n            _strategyController.totalValue();\n    }\n}\n"
    },
    "contracts/ERC20UpgradeableRenameable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeableRenameable is\n    Initializable,\n    ContextUpgradeable,\n    IERC20Upgradeable,\n    IERC20MetadataUpgradeable\n{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_)\n        internal\n        initializer\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\n        internal\n        initializer\n    {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(\n                _msgSender(),\n                spender,\n                currentAllowance - subtractedValue\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(\n            recipient != address(0),\n            \"ERC20: transfer to the zero address\"\n        );\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(\n            accountBalance >= amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/core/mocks/TestCollateral.sol": {
      "content": "pragma solidity =0.8.7;\n\nimport \"../Collateral.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\n\ncontract TestCollateral is Collateral, MulticallUpgradeable {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
